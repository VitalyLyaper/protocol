{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Rarible Protocol \u00b6 Rarible Multichain Protocol is a decentralized toolset that simplifies the way developers can work with NFTs. Protocol builds an abstraction layer for several blockchains and isolates the developer from their specifics with Multichain SDK. Rarible Multichain SDK is fully blockchain-agnostic. You can find a list of supported blockchains on our Features page. How to start \u00b6 Read Getting Started guide to learn how to Install Multichain SDK , mint your first NFT and put it on sale Get better understanding of Rarible Multichain Protocol with Protocol Overview Chapter Learn how to use SDK with our Reference Try using our API Review successful cases from our partners using Rarible Multichain Protocol in Use Cases section Try to look on fully functional Example Application If you still have questions, join open discussion on Community Resources .","title":"Home"},{"location":"#rarible-protocol","text":"Rarible Multichain Protocol is a decentralized toolset that simplifies the way developers can work with NFTs. Protocol builds an abstraction layer for several blockchains and isolates the developer from their specifics with Multichain SDK. Rarible Multichain SDK is fully blockchain-agnostic. You can find a list of supported blockchains on our Features page.","title":"Rarible Protocol"},{"location":"#how-to-start","text":"Read Getting Started guide to learn how to Install Multichain SDK , mint your first NFT and put it on sale Get better understanding of Rarible Multichain Protocol with Protocol Overview Chapter Learn how to use SDK with our Reference Try using our API Review successful cases from our partners using Rarible Multichain Protocol in Use Cases section Try to look on fully functional Example Application If you still have questions, join open discussion on Community Resources .","title":"How to start"},{"location":"LICENSE/","text":"GNU GENERAL PUBLIC LICENSE Version 3, 29 June 2007 Copyright (C) 2007 Free Software Foundation, Inc. https://fsf.org/ Everyone is permitted to copy and distribute verbatim copies of this license document, but changing it is not allowed. Preamble The GNU General Public License is a free, copyleft license for software and other kinds of works. The licenses for most software and other practical works are designed to take away your freedom to share and change the works. By contrast, the GNU General Public License is intended to guarantee your freedom to share and change all versions of a program--to make sure it remains free software for all its users. We, the Free Software Foundation, use the GNU General Public License for most of our software; it applies also to any other work released this way by its authors. You can apply it to your programs, too. When we speak of free software, we are referring to freedom, not price. Our General Public Licenses are designed to make sure that you have the freedom to distribute copies of free software (and charge for them if you wish), that you receive source code or can get it if you want it, that you can change the software or use pieces of it in new free programs, and that you know you can do these things. To protect your rights, we need to prevent others from denying you these rights or asking you to surrender the rights. Therefore, you have certain responsibilities if you distribute copies of the software, or if you modify it: responsibilities to respect the freedom of others. For example, if you distribute copies of such a program, whether gratis or for a fee, you must pass on to the recipients the same freedoms that you received. You must make sure that they, too, receive or can get the source code. And you must show them these terms so they know their rights. Developers that use the GNU GPL protect your rights with two steps: (1) assert copyright on the software, and (2) offer you this License giving you legal permission to copy, distribute and/or modify it. For the developers' and authors' protection, the GPL clearly explains that there is no warranty for this free software. For both users' and authors' sake, the GPL requires that modified versions be marked as changed, so that their problems will not be attributed erroneously to authors of previous versions. Some devices are designed to deny users access to install or run modified versions of the software inside them, although the manufacturer can do so. This is fundamentally incompatible with the aim of protecting users' freedom to change the software. The systematic pattern of such abuse occurs in the area of products for individuals to use, which is precisely where it is most unacceptable. Therefore, we have designed this version of the GPL to prohibit the practice for those products. If such problems arise substantially in other domains, we stand ready to extend this provision to those domains in future versions of the GPL, as needed to protect the freedom of users. Finally, every program is threatened constantly by software patents. States should not allow patents to restrict development and use of software on general-purpose computers, but in those that do, we wish to avoid the special danger that patents applied to a free program could make it effectively proprietary. To prevent this, the GPL assures that patents cannot be used to render the program non-free. The precise terms and conditions for copying, distribution and modification follow. TERMS AND CONDITIONS Definitions. \"This License\" refers to version 3 of the GNU General Public License. \"Copyright\" also means copyright-like laws that apply to other kinds of works, such as semiconductor masks. \"The Program\" refers to any copyrightable work licensed under this License. Each licensee is addressed as \"you\". \"Licensees\" and \"recipients\" may be individuals or organizations. To \"modify\" a work means to copy from or adapt all or part of the work in a fashion requiring copyright permission, other than the making of an exact copy. The resulting work is called a \"modified version\" of the earlier work or a work \"based on\" the earlier work. A \"covered work\" means either the unmodified Program or a work based on the Program. To \"propagate\" a work means to do anything with it that, without permission, would make you directly or secondarily liable for infringement under applicable copyright law, except executing it on a computer or modifying a private copy. Propagation includes copying, distribution (with or without modification), making available to the public, and in some countries other activities as well. To \"convey\" a work means any kind of propagation that enables other parties to make or receive copies. Mere interaction with a user through a computer network, with no transfer of a copy, is not conveying. An interactive user interface displays \"Appropriate Legal Notices\" to the extent that it includes a convenient and prominently visible feature that (1) displays an appropriate copyright notice, and (2) tells the user that there is no warranty for the work (except to the extent that warranties are provided), that licensees may convey the work under this License, and how to view a copy of this License. If the interface presents a list of user commands or options, such as a menu, a prominent item in the list meets this criterion. Source Code. The \"source code\" for a work means the preferred form of the work for making modifications to it. \"Object code\" means any non-source form of a work. A \"Standard Interface\" means an interface that either is an official standard defined by a recognized standards body, or, in the case of interfaces specified for a particular programming language, one that is widely used among developers working in that language. The \"System Libraries\" of an executable work include anything, other than the work as a whole, that (a) is included in the normal form of packaging a Major Component, but which is not part of that Major Component, and (b) serves only to enable use of the work with that Major Component, or to implement a Standard Interface for which an implementation is available to the public in source code form. A \"Major Component\", in this context, means a major essential component (kernel, window system, and so on) of the specific operating system (if any) on which the executable work runs, or a compiler used to produce the work, or an object code interpreter used to run it. The \"Corresponding Source\" for a work in object code form means all the source code needed to generate, install, and (for an executable work) run the object code and to modify the work, including scripts to control those activities. However, it does not include the work's System Libraries, or general-purpose tools or generally available free programs which are used unmodified in performing those activities but which are not part of the work. For example, Corresponding Source includes interface definition files associated with source files for the work, and the source code for shared libraries and dynamically linked subprograms that the work is specifically designed to require, such as by intimate data communication or control flow between those subprograms and other parts of the work. The Corresponding Source need not include anything that users can regenerate automatically from other parts of the Corresponding Source. The Corresponding Source for a work in source code form is that same work. Basic Permissions. All rights granted under this License are granted for the term of copyright on the Program, and are irrevocable provided the stated conditions are met. This License explicitly affirms your unlimited permission to run the unmodified Program. The output from running a covered work is covered by this License only if the output, given its content, constitutes a covered work. This License acknowledges your rights of fair use or other equivalent, as provided by copyright law. You may make, run and propagate covered works that you do not convey, without conditions so long as your license otherwise remains in force. You may convey covered works to others for the sole purpose of having them make modifications exclusively for you, or provide you with facilities for running those works, provided that you comply with the terms of this License in conveying all material for which you do not control copyright. Those thus making or running the covered works for you must do so exclusively on your behalf, under your direction and control, on terms that prohibit them from making any copies of your copyrighted material outside their relationship with you. Conveying under any other circumstances is permitted solely under the conditions stated below. Sublicensing is not allowed; section 10 makes it unnecessary. Protecting Users' Legal Rights From Anti-Circumvention Law. No covered work shall be deemed part of an effective technological measure under any applicable law fulfilling obligations under article 11 of the WIPO copyright treaty adopted on 20 December 1996, or similar laws prohibiting or restricting circumvention of such measures. When you convey a covered work, you waive any legal power to forbid circumvention of technological measures to the extent such circumvention is effected by exercising rights under this License with respect to the covered work, and you disclaim any intention to limit operation or modification of the work as a means of enforcing, against the work's users, your or third parties' legal rights to forbid circumvention of technological measures. Conveying Verbatim Copies. You may convey verbatim copies of the Program's source code as you receive it, in any medium, provided that you conspicuously and appropriately publish on each copy an appropriate copyright notice; keep intact all notices stating that this License and any non-permissive terms added in accord with section 7 apply to the code; keep intact all notices of the absence of any warranty; and give all recipients a copy of this License along with the Program. You may charge any price or no price for each copy that you convey, and you may offer support or warranty protection for a fee. Conveying Modified Source Versions. You may convey a work based on the Program, or the modifications to produce it from the Program, in the form of source code under the terms of section 4, provided that you also meet all of these conditions: a) The work must carry prominent notices stating that you modified it, and giving a relevant date. b) The work must carry prominent notices stating that it is released under this License and any conditions added under section 7. This requirement modifies the requirement in section 4 to \"keep intact all notices\". c) You must license the entire work, as a whole, under this License to anyone who comes into possession of a copy. This License will therefore apply, along with any applicable section 7 additional terms, to the whole of the work, and all its parts, regardless of how they are packaged. This License gives no permission to license the work in any other way, but it does not invalidate such permission if you have separately received it. d) If the work has interactive user interfaces, each must display Appropriate Legal Notices; however, if the Program has interactive interfaces that do not display Appropriate Legal Notices, your work need not make them do so. A compilation of a covered work with other separate and independent works, which are not by their nature extensions of the covered work, and which are not combined with it such as to form a larger program, in or on a volume of a storage or distribution medium, is called an \"aggregate\" if the compilation and its resulting copyright are not used to limit the access or legal rights of the compilation's users beyond what the individual works permit. Inclusion of a covered work in an aggregate does not cause this License to apply to the other parts of the aggregate. Conveying Non-Source Forms. You may convey a covered work in object code form under the terms of sections 4 and 5, provided that you also convey the machine-readable Corresponding Source under the terms of this License, in one of these ways: a) Convey the object code in, or embodied in, a physical product (including a physical distribution medium), accompanied by the Corresponding Source fixed on a durable physical medium customarily used for software interchange. b) Convey the object code in, or embodied in, a physical product (including a physical distribution medium), accompanied by a written offer, valid for at least three years and valid for as long as you offer spare parts or customer support for that product model, to give anyone who possesses the object code either (1) a copy of the Corresponding Source for all the software in the product that is covered by this License, on a durable physical medium customarily used for software interchange, for a price no more than your reasonable cost of physically performing this conveying of source, or (2) access to copy the Corresponding Source from a network server at no charge. c) Convey individual copies of the object code with a copy of the written offer to provide the Corresponding Source. This alternative is allowed only occasionally and noncommercially, and only if you received the object code with such an offer, in accord with subsection 6b. d) Convey the object code by offering access from a designated place (gratis or for a charge), and offer equivalent access to the Corresponding Source in the same way through the same place at no further charge. You need not require recipients to copy the Corresponding Source along with the object code. If the place to copy the object code is a network server, the Corresponding Source may be on a different server (operated by you or a third party) that supports equivalent copying facilities, provided you maintain clear directions next to the object code saying where to find the Corresponding Source. Regardless of what server hosts the Corresponding Source, you remain obligated to ensure that it is available for as long as needed to satisfy these requirements. e) Convey the object code using peer-to-peer transmission, provided you inform other peers where the object code and Corresponding Source of the work are being offered to the general public at no charge under subsection 6d. A separable portion of the object code, whose source code is excluded from the Corresponding Source as a System Library, need not be included in conveying the object code work. A \"User Product\" is either (1) a \"consumer product\", which means any tangible personal property which is normally used for personal, family, or household purposes, or (2) anything designed or sold for incorporation into a dwelling. In determining whether a product is a consumer product, doubtful cases shall be resolved in favor of coverage. For a particular product received by a particular user, \"normally used\" refers to a typical or common use of that class of product, regardless of the status of the particular user or of the way in which the particular user actually uses, or expects or is expected to use, the product. A product is a consumer product regardless of whether the product has substantial commercial, industrial or non-consumer uses, unless such uses represent the only significant mode of use of the product. \"Installation Information\" for a User Product means any methods, procedures, authorization keys, or other information required to install and execute modified versions of a covered work in that User Product from a modified version of its Corresponding Source. The information must suffice to ensure that the continued functioning of the modified object code is in no case prevented or interfered with solely because modification has been made. If you convey an object code work under this section in, or with, or specifically for use in, a User Product, and the conveying occurs as part of a transaction in which the right of possession and use of the User Product is transferred to the recipient in perpetuity or for a fixed term (regardless of how the transaction is characterized), the Corresponding Source conveyed under this section must be accompanied by the Installation Information. But this requirement does not apply if neither you nor any third party retains the ability to install modified object code on the User Product (for example, the work has been installed in ROM). The requirement to provide Installation Information does not include a requirement to continue to provide support service, warranty, or updates for a work that has been modified or installed by the recipient, or for the User Product in which it has been modified or installed. Access to a network may be denied when the modification itself materially and adversely affects the operation of the network or violates the rules and protocols for communication across the network. Corresponding Source conveyed, and Installation Information provided, in accord with this section must be in a format that is publicly documented (and with an implementation available to the public in source code form), and must require no special password or key for unpacking, reading or copying. Additional Terms. \"Additional permissions\" are terms that supplement the terms of this License by making exceptions from one or more of its conditions. Additional permissions that are applicable to the entire Program shall be treated as though they were included in this License, to the extent that they are valid under applicable law. If additional permissions apply only to part of the Program, that part may be used separately under those permissions, but the entire Program remains governed by this License without regard to the additional permissions. When you convey a copy of a covered work, you may at your option remove any additional permissions from that copy, or from any part of it. (Additional permissions may be written to require their own removal in certain cases when you modify the work.) You may place additional permissions on material, added by you to a covered work, for which you have or can give appropriate copyright permission. Notwithstanding any other provision of this License, for material you add to a covered work, you may (if authorized by the copyright holders of that material) supplement the terms of this License with terms: a) Disclaiming warranty or limiting liability differently from the terms of sections 15 and 16 of this License; or b) Requiring preservation of specified reasonable legal notices or author attributions in that material or in the Appropriate Legal Notices displayed by works containing it; or c) Prohibiting misrepresentation of the origin of that material, or requiring that modified versions of such material be marked in reasonable ways as different from the original version; or d) Limiting the use for publicity purposes of names of licensors or authors of the material; or e) Declining to grant rights under trademark law for use of some trade names, trademarks, or service marks; or f) Requiring indemnification of licensors and authors of that material by anyone who conveys the material (or modified versions of it) with contractual assumptions of liability to the recipient, for any liability that these contractual assumptions directly impose on those licensors and authors. All other non-permissive additional terms are considered \"further restrictions\" within the meaning of section 10. If the Program as you received it, or any part of it, contains a notice stating that it is governed by this License along with a term that is a further restriction, you may remove that term. If a license document contains a further restriction but permits relicensing or conveying under this License, you may add to a covered work material governed by the terms of that license document, provided that the further restriction does not survive such relicensing or conveying. If you add terms to a covered work in accord with this section, you must place, in the relevant source files, a statement of the additional terms that apply to those files, or a notice indicating where to find the applicable terms. Additional terms, permissive or non-permissive, may be stated in the form of a separately written license, or stated as exceptions; the above requirements apply either way. Termination. You may not propagate or modify a covered work except as expressly provided under this License. Any attempt otherwise to propagate or modify it is void, and will automatically terminate your rights under this License (including any patent licenses granted under the third paragraph of section 11). However, if you cease all violation of this License, then your license from a particular copyright holder is reinstated (a) provisionally, unless and until the copyright holder explicitly and finally terminates your license, and (b) permanently, if the copyright holder fails to notify you of the violation by some reasonable means prior to 60 days after the cessation. Moreover, your license from a particular copyright holder is reinstated permanently if the copyright holder notifies you of the violation by some reasonable means, this is the first time you have received notice of violation of this License (for any work) from that copyright holder, and you cure the violation prior to 30 days after your receipt of the notice. Termination of your rights under this section does not terminate the licenses of parties who have received copies or rights from you under this License. If your rights have been terminated and not permanently reinstated, you do not qualify to receive new licenses for the same material under section 10. Acceptance Not Required for Having Copies. You are not required to accept this License in order to receive or run a copy of the Program. Ancillary propagation of a covered work occurring solely as a consequence of using peer-to-peer transmission to receive a copy likewise does not require acceptance. However, nothing other than this License grants you permission to propagate or modify any covered work. These actions infringe copyright if you do not accept this License. Therefore, by modifying or propagating a covered work, you indicate your acceptance of this License to do so. Automatic Licensing of Downstream Recipients. Each time you convey a covered work, the recipient automatically receives a license from the original licensors, to run, modify and propagate that work, subject to this License. You are not responsible for enforcing compliance by third parties with this License. An \"entity transaction\" is a transaction transferring control of an organization, or substantially all assets of one, or subdividing an organization, or merging organizations. If propagation of a covered work results from an entity transaction, each party to that transaction who receives a copy of the work also receives whatever licenses to the work the party's predecessor in interest had or could give under the previous paragraph, plus a right to possession of the Corresponding Source of the work from the predecessor in interest, if the predecessor has it or can get it with reasonable efforts. You may not impose any further restrictions on the exercise of the rights granted or affirmed under this License. For example, you may not impose a license fee, royalty, or other charge for exercise of rights granted under this License, and you may not initiate litigation (including a cross-claim or counterclaim in a lawsuit) alleging that any patent claim is infringed by making, using, selling, offering for sale, or importing the Program or any portion of it. Patents. A \"contributor\" is a copyright holder who authorizes use under this License of the Program or a work on which the Program is based. The work thus licensed is called the contributor's \"contributor version\". A contributor's \"essential patent claims\" are all patent claims owned or controlled by the contributor, whether already acquired or hereafter acquired, that would be infringed by some manner, permitted by this License, of making, using, or selling its contributor version, but do not include claims that would be infringed only as a consequence of further modification of the contributor version. For purposes of this definition, \"control\" includes the right to grant patent sublicenses in a manner consistent with the requirements of this License. Each contributor grants you a non-exclusive, worldwide, royalty-free patent license under the contributor's essential patent claims, to make, use, sell, offer for sale, import and otherwise run, modify and propagate the contents of its contributor version. In the following three paragraphs, a \"patent license\" is any express agreement or commitment, however denominated, not to enforce a patent (such as an express permission to practice a patent or covenant not to sue for patent infringement). To \"grant\" such a patent license to a party means to make such an agreement or commitment not to enforce a patent against the party. If you convey a covered work, knowingly relying on a patent license, and the Corresponding Source of the work is not available for anyone to copy, free of charge and under the terms of this License, through a publicly available network server or other readily accessible means, then you must either (1) cause the Corresponding Source to be so available, or (2) arrange to deprive yourself of the benefit of the patent license for this particular work, or (3) arrange, in a manner consistent with the requirements of this License, to extend the patent license to downstream recipients. \"Knowingly relying\" means you have actual knowledge that, but for the patent license, your conveying the covered work in a country, or your recipient's use of the covered work in a country, would infringe one or more identifiable patents in that country that you have reason to believe are valid. If, pursuant to or in connection with a single transaction or arrangement, you convey, or propagate by procuring conveyance of, a covered work, and grant a patent license to some of the parties receiving the covered work authorizing them to use, propagate, modify or convey a specific copy of the covered work, then the patent license you grant is automatically extended to all recipients of the covered work and works based on it. A patent license is \"discriminatory\" if it does not include within the scope of its coverage, prohibits the exercise of, or is conditioned on the non-exercise of one or more of the rights that are specifically granted under this License. You may not convey a covered work if you are a party to an arrangement with a third party that is in the business of distributing software, under which you make payment to the third party based on the extent of your activity of conveying the work, and under which the third party grants, to any of the parties who would receive the covered work from you, a discriminatory patent license (a) in connection with copies of the covered work conveyed by you (or copies made from those copies), or (b) primarily for and in connection with specific products or compilations that contain the covered work, unless you entered into that arrangement, or that patent license was granted, prior to 28 March 2007. Nothing in this License shall be construed as excluding or limiting any implied license or other defenses to infringement that may otherwise be available to you under applicable patent law. No Surrender of Others' Freedom. If conditions are imposed on you (whether by court order, agreement or otherwise) that contradict the conditions of this License, they do not excuse you from the conditions of this License. If you cannot convey a covered work so as to satisfy simultaneously your obligations under this License and any other pertinent obligations, then as a consequence you may not convey it at all. For example, if you agree to terms that obligate you to collect a royalty for further conveying from those to whom you convey the Program, the only way you could satisfy both those terms and this License would be to refrain entirely from conveying the Program. Use with the GNU Affero General Public License. Notwithstanding any other provision of this License, you have permission to link or combine any covered work with a work licensed under version 3 of the GNU Affero General Public License into a single combined work, and to convey the resulting work. The terms of this License will continue to apply to the part which is the covered work, but the special requirements of the GNU Affero General Public License, section 13, concerning interaction through a network will apply to the combination as such. Revised Versions of this License. The Free Software Foundation may publish revised and/or new versions of the GNU General Public License from time to time. Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns. Each version is given a distinguishing version number. If the Program specifies that a certain numbered version of the GNU General Public License \"or any later version\" applies to it, you have the option of following the terms and conditions either of that numbered version or of any later version published by the Free Software Foundation. If the Program does not specify a version number of the GNU General Public License, you may choose any version ever published by the Free Software Foundation. If the Program specifies that a proxy can decide which future versions of the GNU General Public License can be used, that proxy's public statement of acceptance of a version permanently authorizes you to choose that version for the Program. Later license versions may give you additional or different permissions. However, no additional obligations are imposed on any author or copyright holder as a result of your choosing to follow a later version. Disclaimer of Warranty. THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION. Limitation of Liability. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. Interpretation of Sections 15 and 16. If the disclaimer of warranty and limitation of liability provided above cannot be given local legal effect according to their terms, reviewing courts shall apply local law that most closely approximates an absolute waiver of all civil liability in connection with the Program, unless a warranty or assumption of liability accompanies a copy of the Program in return for a fee. END OF TERMS AND CONDITIONS How to Apply These Terms to Your New Programs If you develop a new program, and you want it to be of the greatest possible use to the public, the best way to achieve this is to make it free software which everyone can redistribute and change under these terms. To do so, attach the following notices to the program. It is safest to attach them to the start of each source file to most effectively state the exclusion of warranty; and each file should have at least the \"copyright\" line and a pointer to where the full notice is found. <one line to give the program's name and a brief idea of what it does.> Copyright (C) <year> <name of author> This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program. If not, see <https://www.gnu.org/licenses/>. Also add information on how to contact you by electronic and paper mail. If the program does terminal interaction, make it output a short notice like this when it starts in an interactive mode: <program> Copyright (C) <year> <name of author> This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'. This is free software, and you are welcome to redistribute it under certain conditions; type `show c' for details. The hypothetical commands show w' and show c' should show the appropriate parts of the General Public License. Of course, your program's commands might be different; for a GUI interface, you would use an \"about box\". You should also get your employer (if you work as a programmer) or school, if any, to sign a \"copyright disclaimer\" for the program, if necessary. For more information on this, and how to apply and follow the GNU GPL, see https://www.gnu.org/licenses/ . The GNU General Public License does not permit incorporating your program into proprietary programs. If your program is a subroutine library, you may consider it more useful to permit linking proprietary applications with the library. If this is what you want to do, use the GNU Lesser General Public License instead of this License. But first, please read https://www.gnu.org/licenses/why-not-lgpl.html .","title":"LICENSE"},{"location":"MIT-LICENSE/","text":"Copyright (c) 2021, Rarible DAO Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"MIT LICENSE"},{"location":"api-reference/","text":"API Reference \u00b6 Documentation and base URL \u00b6 Use these base URLs to access our API on different networks. api.rarible.org or any testnet equivalent is compatible with all blockchains supported by the Rarible Protocol. We also use the term multichain to describe this compatibility case in the docs. Documentation Base URL Environments multichain-api.rarible.org For all environments api.rarible.org/v0.1/doc https://api.rarible.org/v0.1 Production (Mainnet) api-staging.rarible.org/v0.1/doc https://api-staging.rarible.org/v0.1 Staging (Rinkeby, Mumbai) dev-api.rarible.org/v0.1/doc https://dev-api.rarible.org/v0.1 Development (Ropsten, Mumbai, Ithaca) On the multichain-api.rarible.org page, you can make API requests using the TryIt function. To start using: Change environments on the top left side Choose API method Click Try it button: Configure the request parameters if required Click Send button Also see additional information and API usage examples on the Search Capabilities page. Environments \u00b6 The API interacts with different blockchain networks for different environments. Production : Ethereum: mainnet Tezos: mainnet Flow: mainnet Polygon: mainnet Staging : Ethereum: rinkeby Flow: devnet Polygon: mumbai Development : Ethereum: ropsten Tezos: ithaca Flow: devnet Polygon: mumbai","title":"API References"},{"location":"api-reference/#api-reference","text":"","title":"API Reference"},{"location":"api-reference/#documentation-and-base-url","text":"Use these base URLs to access our API on different networks. api.rarible.org or any testnet equivalent is compatible with all blockchains supported by the Rarible Protocol. We also use the term multichain to describe this compatibility case in the docs. Documentation Base URL Environments multichain-api.rarible.org For all environments api.rarible.org/v0.1/doc https://api.rarible.org/v0.1 Production (Mainnet) api-staging.rarible.org/v0.1/doc https://api-staging.rarible.org/v0.1 Staging (Rinkeby, Mumbai) dev-api.rarible.org/v0.1/doc https://dev-api.rarible.org/v0.1 Development (Ropsten, Mumbai, Ithaca) On the multichain-api.rarible.org page, you can make API requests using the TryIt function. To start using: Change environments on the top left side Choose API method Click Try it button: Configure the request parameters if required Click Send button Also see additional information and API usage examples on the Search Capabilities page.","title":"Documentation and base URL"},{"location":"api-reference/#environments","text":"The API interacts with different blockchain networks for different environments. Production : Ethereum: mainnet Tezos: mainnet Flow: mainnet Polygon: mainnet Staging : Ethereum: rinkeby Flow: devnet Polygon: mumbai Development : Ethereum: ropsten Tezos: ithaca Flow: devnet Polygon: mumbai","title":"Environments"},{"location":"faq/","text":"Frequently Asked Questions \u00b6 See Discussion QA section on our GitHub repo, Discord , and documentation for more answers. If you haven't found an answer to your question, you can create a new discussion here . WIP. It's the first FAQ version. Do I need tokenId to lazy minting NFT through SDK? \u00b6 Token id is optional and generates inside the SDK if not provided. Just generate it using the API call and pass it to mint. How to connect Metamask with SDK? \u00b6 Something like that: new EthereumWallet(new Web3Ethereum({ web3: web31 })) Now you can pass your wallet to the create SDK factory. See Rarible Protocol SDK for more information about using SDK. Why the price in the sell order can't be updated to a higher value? \u00b6 That's a security issue. If you signed a message stating that you want to sell something for 1 ETH, you can't just ignore this and pretend that you want to sell for 1.5 ETH. If there is somewhere saved previous message, it can be used in the smart contract. So, to make the price higher, you should cancel the order and sign a new message. What does the union-service repo do? \u00b6 Multichain service also known as union service is a layer that connects different Blockchain APIs. It sits on top of all of them. What kind of fee model does the protocol use? \u00b6 See Smart contracts for Rarible protocol repo on GitHub for more information about fees. Also, you can find more information about fees in Rarible Protocol Ethereum docs. What is \"deploy\" in the SDK used for? \u00b6 It's used for deploying ERC-721/ERC-1155 token contracts. Users can deploy new collection contracts, for example.","title":"FAQ"},{"location":"faq/#frequently-asked-questions","text":"See Discussion QA section on our GitHub repo, Discord , and documentation for more answers. If you haven't found an answer to your question, you can create a new discussion here . WIP. It's the first FAQ version.","title":"Frequently Asked Questions"},{"location":"faq/#do-i-need-tokenid-to-lazy-minting-nft-through-sdk","text":"Token id is optional and generates inside the SDK if not provided. Just generate it using the API call and pass it to mint.","title":"Do I need tokenId to lazy minting NFT through SDK?"},{"location":"faq/#how-to-connect-metamask-with-sdk","text":"Something like that: new EthereumWallet(new Web3Ethereum({ web3: web31 })) Now you can pass your wallet to the create SDK factory. See Rarible Protocol SDK for more information about using SDK.","title":"How to connect Metamask with SDK?"},{"location":"faq/#why-the-price-in-the-sell-order-cant-be-updated-to-a-higher-value","text":"That's a security issue. If you signed a message stating that you want to sell something for 1 ETH, you can't just ignore this and pretend that you want to sell for 1.5 ETH. If there is somewhere saved previous message, it can be used in the smart contract. So, to make the price higher, you should cancel the order and sign a new message.","title":"Why the price in the sell order can't be updated to a higher value?"},{"location":"faq/#what-does-the-union-service-repo-do","text":"Multichain service also known as union service is a layer that connects different Blockchain APIs. It sits on top of all of them.","title":"What does the union-service repo do?"},{"location":"faq/#what-kind-of-fee-model-does-the-protocol-use","text":"See Smart contracts for Rarible protocol repo on GitHub for more information about fees. Also, you can find more information about fees in Rarible Protocol Ethereum docs.","title":"What kind of fee model does the protocol use?"},{"location":"faq/#what-is-deploy-in-the-sdk-used-for","text":"It's used for deploying ERC-721/ERC-1155 token contracts. Users can deploy new collection contracts, for example.","title":"What is \"deploy\" in the SDK used for?"},{"location":"features/","text":"Rarible Protocol Features List \u00b6 Ethereum Flow Tezos Polygon Solana Multichain Protocol supported features NFTs types ERC-721 , ERC-1155 Flow NFT standart FA2 (TZIP-012) ERC-721 , ERC-1155 Metaplex NFT standart Buy now Sell NFTs Bids 2022 Q2 2022 Q2 Floor bid Create, update and cancel orders Create NFT collection Alpha testing Mint NFTs Lazy mint NFTs Transfer NFTs Burn NFTs Fees and Royalties On-chain Auction Alpha testing Alpha testing Alpha testing Alpha testing Alpha testing Seaching/Data retrieval features Search tokens by parameters Search blockchain events Search orders by parameters Create or update orders Get collections information Indexer Fetch NFTs from blockchain Fetch fungible tokens from blockchain 2022 Q2 Fetch balances Fetch Orders from the other marketplaces (on-chain) NFT Storefront Objkt 2022 Q2 fixed price sale Degenerate Ape Academy Hic Et Nunc 2022 Q2 fixed price sale Fetch orders from the other marketplaces (off-chain) OpenSea OpenSea Additional NFT collections CryptoPunks MotoGP, Evolution, Mugen ARt, Vault by CNN, Starly, Matrix World Voucher, Matrix World Flow Fest, VersusArt, DisruptArt, OneFootball, Jambb, Fanfare, Chainmonsters, Barter Yard Club, ClosedSrc Degenerate Ape Academy","title":"Features"},{"location":"features/#rarible-protocol-features-list","text":"Ethereum Flow Tezos Polygon Solana Multichain Protocol supported features NFTs types ERC-721 , ERC-1155 Flow NFT standart FA2 (TZIP-012) ERC-721 , ERC-1155 Metaplex NFT standart Buy now Sell NFTs Bids 2022 Q2 2022 Q2 Floor bid Create, update and cancel orders Create NFT collection Alpha testing Mint NFTs Lazy mint NFTs Transfer NFTs Burn NFTs Fees and Royalties On-chain Auction Alpha testing Alpha testing Alpha testing Alpha testing Alpha testing Seaching/Data retrieval features Search tokens by parameters Search blockchain events Search orders by parameters Create or update orders Get collections information Indexer Fetch NFTs from blockchain Fetch fungible tokens from blockchain 2022 Q2 Fetch balances Fetch Orders from the other marketplaces (on-chain) NFT Storefront Objkt 2022 Q2 fixed price sale Degenerate Ape Academy Hic Et Nunc 2022 Q2 fixed price sale Fetch orders from the other marketplaces (off-chain) OpenSea OpenSea Additional NFT collections CryptoPunks MotoGP, Evolution, Mugen ARt, Vault by CNN, Starly, Matrix World Voucher, Matrix World Flow Fest, VersusArt, DisruptArt, OneFootball, Jambb, Fanfare, Chainmonsters, Barter Yard Club, ClosedSrc Degenerate Ape Academy","title":"Rarible Protocol Features List"},{"location":"roadmap/","text":"Rarible Protocol Roadmap \u00b6 Q1 2022 Q2 2022 Q3 2022 Whitelabel Closed beta Public beta Multichain vision Solana Immutable X NEAR Avalanche Algorand API keys and rate-limits Easy to host Protocol Status page & Monitoring Rarible API hosted at the node providers Shared order book between multiple instances Everything about NFTs On-chain auctions NFT Data & Analytics API Events for the Developers Protocol Hackathon","title":"Rarible Protocol Roadmap"},{"location":"roadmap/#rarible-protocol-roadmap","text":"Q1 2022 Q2 2022 Q3 2022 Whitelabel Closed beta Public beta Multichain vision Solana Immutable X NEAR Avalanche Algorand API keys and rate-limits Easy to host Protocol Status page & Monitoring Rarible API hosted at the node providers Shared order book between multiple instances Everything about NFTs On-chain auctions NFT Data & Analytics API Events for the Developers Protocol Hackathon","title":"Rarible Protocol Roadmap"},{"location":"getting-started/community/","text":"Community and resources \u00b6 DAO \u00b6 If you're a builder, or you're looking to participate in the Rarible Protocol DAO, here are a few valuable places you'll find support and like-minded builders. Discord is one of the main places where the DAO is being organized, and builders take their first steps towards building with the protocol. GitHub is where everything lives. Since we are open-source, many resources and help from other builders are available there. OpenAPI is where we document the current API capabilities. Resources \u00b6 Rarible YouTube Rarible Protocol Twitter Rarible Hackathon Docs HackMD by Isaac for Ethereum network. Submitting \u00b6 You are welcome to suggest features and report bugs found! You can do it here: Submit an issue Submit a question or suggestion Audits \u00b6 Rarible Protocol is audited. Check this report by ChainSecurity.com . License \u00b6 Rarible Protocol is available under GPL v3 . SDK and OpenAPI (with generated clients) are available under MIT .","title":"Community and resources"},{"location":"getting-started/community/#community-and-resources","text":"","title":"Community and resources"},{"location":"getting-started/community/#dao","text":"If you're a builder, or you're looking to participate in the Rarible Protocol DAO, here are a few valuable places you'll find support and like-minded builders. Discord is one of the main places where the DAO is being organized, and builders take their first steps towards building with the protocol. GitHub is where everything lives. Since we are open-source, many resources and help from other builders are available there. OpenAPI is where we document the current API capabilities.","title":"DAO"},{"location":"getting-started/community/#resources","text":"Rarible YouTube Rarible Protocol Twitter Rarible Hackathon Docs HackMD by Isaac for Ethereum network.","title":"Resources"},{"location":"getting-started/community/#submitting","text":"You are welcome to suggest features and report bugs found! You can do it here: Submit an issue Submit a question or suggestion","title":"Submitting"},{"location":"getting-started/community/#audits","text":"Rarible Protocol is audited. Check this report by ChainSecurity.com .","title":"Audits"},{"location":"getting-started/community/#license","text":"Rarible Protocol is available under GPL v3 . SDK and OpenAPI (with generated clients) are available under MIT .","title":"License"},{"location":"getting-started/fetch-nft-data/","text":"How to fetch NFT data using Rarible Multichain API \u00b6 In the previous article , we showed you how to find NFTs you\u2019re interested in, by using different searching parameters (such as collection, address, or user name) on a marketplace\u2019s website. In general, that\u2019s a very simple process\u2026unless you want to fetch details from many different NFTs. In this article, we\u2019ll learn how to get information on NFTs-related activities, straight from the source. In other words, we will cover how you can implement the same functionality you see on the Rarible Marketplace , using the Rarible Multichain Protocol. The Rarible Multichain Protocol is an API developed by the Rarible team that allows you to fetch activity information of different NFT projects \u2014 NFTs details, orders, owners, bids, etc. Since we will be using an API to get information, you\u2019ll be able to fully automate the search process and do it in a structured and repetitive manner. API Overview \u00b6 The Rarible Multichain Protocol organizes search capabilities in a set of controllers. Each controller provides a fine-grained API to retrieve certain pieces of information about the NFT, or any of its attributes. The API comprises the following controllers: Signature Controller \u2014 responsible for verifying signatures of messages Currency Controller \u2014 it allows us to get a USDC rate for a given token Item Controller \u2014 it lets us check all sorts of item-related information, like item details, owner, collection, etc. Ownership Controller \u2014 returns ownership details Order Controller \u2014 responsible for fetching order information, like sell order, order by id, orders by the maker Auction Controller \u2014 auctions related information (auctions are not yet supported on the API) Activity Controller \u2014 activity information, such as token transfer, minting, burning, aggregated by users, items, collections Collection Controller \u2014 collections-related information As you can see, there is a controller for every imaginable parameter, so getting the desired information won\u2019t be a problem. The hard part is to easily navigate through the information we get from them, and make our logic as simple as possible. Search for a collection \u00b6 Let\u2019s recreate a simple scenario, just to put this into context. Let\u2019s say that the only information we have about a collection is its ID, aka collection address. It\u2019s the moonbird collection , and we want to know everything about it. We access the Rarible Multichain API docs and start building. Since the only information we have is the collection address, the first endpoint we\u2019ll use is getCollectionById . To be precise, it\u2019s this one. As we can see, we have to pass the collection address as a parameter, along with the blockchain name in which the contract resides. To get the contract address of a collection, we access the Rarible website and find the collection by name. There, we\u2019re able to get the contract address, which appears right under the collection\u2019s name. We\u2019re now ready to make the first request. curl https://api.rarible.org/v0.1/collections/ETHEREUM:0x23581767a106ae21c074b2276d25e5c3e136a68b We\u2019re then able to retrieve the following information: Collections response { \"id\" : \"ETHEREUM:0x23581767a106ae21c074b2276d25e5c3e136a68b\" , \"blockchain\" : \"ETHEREUM\" , \"type\" : \"ERC721\" , \"name\" : \"Moonbirds\" , \"symbol\" : \"MOONBIRD\" , \"owner\" : \"ETHEREUM:0x83895f7508926741cd2147c4aac65c30a851cc30\" , \"features\" : [ \"APPROVE_FOR_ALL\" ], \"minters\" : [], \"meta\" : { \"name\" : \"Moonbirds\" , \"description\" : \"A collection of 10,000 utility-enabled PFPs that feature a richly diverse and unique pool of rarity-powered traits. What's more, each Moonbird unlocks private club membership and additional benefits the longer you hold them. We call it nesting \u2013 because, obviously.\" , \"content\" : [ { \"@type\" : \"IMAGE\" , \"url\" : \"https://lh3.googleusercontent.com/sn5iLHUcNuUO98w_9Z7cat32hiqvVkPYr6tzHUacESg4PePh9M3jySvpttyWWXHD2e8M4PNQqgorU9sUvpX-FHQHXFBiCpKjloC2nA=s120\" , \"representation\" : \"ORIGINAL\" } ], \"externalLink\" : \"https://moonbirds.xyz\" , \"sellerFeeBasisPoints\" : 250 , \"feeRecipient\" : \"ETHEREUM:0xc8a5592031f93debea5d9e67a396944ee01bb2ca\" }, \"bestBidOrder\" : { \"id\" : \"ETHEREUM:0x299628bf0f59e046b3edd259bbf66c4e11dc5b02dcc13a65cf86cf7d02ce9b34\" , \"fill\" : \"0\" , \"platform\" : \"RARIBLE\" , \"status\" : \"ACTIVE\" , \"makeStock\" : \"11.1\" , \"cancelled\" : false , \"createdAt\" : \"2022-06-20T14:46:47.960Z\" , \"lastUpdatedAt\" : \"2022-06-22T04:11:45Z\" , \"dbUpdatedAt\" : \"2022-06-22T04:12:09.894Z\" , \"takePrice\" : \"11.1\" , \"takePriceUsd\" : \"12042.01013500119849\" , \"maker\" : \"ETHEREUM:0x0272aafe06eff7a72420835b1e5a60ba118cb2fc\" , \"make\" : { \"type\" : { \"@type\" : \"ERC20\" , \"contract\" : \"ETHEREUM:0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2\" }, \"value\" : \"11.1\" }, \"take\" : { \"type\" : { \"@type\" : \"COLLECTION\" , \"contract\" : \"ETHEREUM:0x23581767a106ae21c074b2276d25e5c3e136a68b\" }, \"value\" : \"1\" }, \"salt\" : \"0x270199a227cc7cddb27513ab58ccbb803e6c7b9f4c677d9023462af182b8b5df\" , \"signature\" : \"0x2a3804723ded47b71f7ca3acf64c0bb3f1f507603ca67dab3c0ba123915aedf251be329e0e5fe5157404a16099e1603cdd5b38d55af6dfa7fd1a894289105b0c01\" , \"pending\" : [], \"data\" : { \"@type\" : \"ETH_RARIBLE_V2\" , \"payouts\" : [], \"originFees\" : [ { \"account\" : \"ETHEREUM:0x1cf0df2a5a20cd61d68d4489eebbf85b8d39e18a\" , \"value\" : 100 } ] } } } Let\u2019s examine the received data. With the above response, we can see which blockchain the collection was minted on, what type of NFT it represents (ERC721 vs ERC1155), who is the owner of the collection (in other words, which address deployed the contract) and metadata information (which tells you the collection name, description, etc.). Moving on, we have the bestBidOrder parameter, which looks like this: bestBidOrder \"bestBidOrder\" : { \"id\" : \"ETHEREUM:0x299628bf0f59e046b3edd259bbf66c4e11dc5b02dcc13a65cf86cf7d02ce9b34\" , \"fill\" : \"0\" , \"platform\" : \"RARIBLE\" , \"status\" : \"ACTIVE\" , \"makeStock\" : \"11.1\" , \"cancelled\" : false , \"createdAt\" : \"2022-06-20T14:46:47.960Z\" , \"lastUpdatedAt\" : \"2022-06-22T04:11:45Z\" , \"dbUpdatedAt\" : \"2022-06-22T04:12:09.894Z\" , \"takePrice\" : \"11.1\" , \"takePriceUsd\" : \"12042.01013500119849\" , \"maker\" : \"ETHEREUM:0x0272aafe06eff7a72420835b1e5a60ba118cb2fc\" , \"make\" : { \"type\" : { \"@type\" : \"ERC20\" , \"contract\" : \"ETHEREUM:0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2\" }, \"value\" : \"11.1\" }, \"take\" : { \"type\" : { \"@type\" : \"COLLECTION\" , \"contract\" : \"ETHEREUM:0x23581767a106ae21c074b2276d25e5c3e136a68b\" }, \"value\" : \"1\" }, \"salt\" : \"0x270199a227cc7cddb27513ab58ccbb803e6c7b9f4c677d9023462af182b8b5df\" , \"signature\" : \"0x2a3804723ded47b71f7ca3acf64c0bb3f1f507603ca67dab3c0ba123915aedf251be329e0e5fe5157404a16099e1603cdd5b38d55af6dfa7fd1a894289105b0c01\" , \"pending\" : [], \"data\" : { \"@type\" : \"ETH_RARIBLE_V2\" , \"payouts\" : [], \"originFees\" : [ { \"account\" : \"ETHEREUM:0x1cf0df2a5a20cd61d68d4489eebbf85b8d39e18a\" , \"value\" : 100 } ] } } Here, we can see the bestBidOrder information related to the collection, which shows the details of an offer someone made to an NFT in this collection. We can also see which platform the offer was created on, if it\u2019s active or not, the value associated with this offer, etc. In addition to the maker and taker parameters, we\u2019re able to see what type of assets are offered. In this example, the maker offers 11.1 ERC20 tokens from a given address. You can check which token was offered, by typing its address on etherscan . In this case, the offer was made in DAI tokens. You can also check what the offer maker wants in return, in the take parameter. It\u2019s a collection type token from a given contract. In our case, the moonbird collection token. Get all NFTs in a collection \u00b6 Moving on, since NFTs are created inside a collection, the next logical step will be to find all the NFTs in that collection. We will do it by using an item controller and the getItemsByCollection endpoint. curl https://api.rarible.org/v0.1/items/byCollection?collection = ETHEREUM:0x23581767a106ae21c074b2276d25e5c3e136a68b An example of a received response can be seen below. { \"total\" : 50 , \"continuation\" : \"1655744480000_0x23581767a106ae21c074b2276d25e5c3e136a68b:8902\" , \"items\" : [{ \"...\" }] } Since the moonbirds collection contains 10.000 NFTs, we won\u2019t be able to fetch all of them with a single request. With a single request we\u2019re able to get up to 50 items and the continuation string, which allows us to iterate over the next set of items. We just need to make a new request with added continuation string as a query parameter, like this: curl https://api.rarible.org/v0.1/items/byCollection?collection = ETHEREUM:0x23581767a106ae21c074b2276d25e5c3e136a68b & continuation = 1655744480000_0x23581767a106ae21c074b2276d25e5c3e136a68b:8902 The continuation string will be present until we fetch all the NFTs. This is an example of how the JSON items looks. As you can see in the response below, you can find all the information related to the NFT. items { \"id\" : \"ETHEREUM:0x23581767a106ae21c074b2276d25e5c3e136a68b:1474\" , \"blockchain\" : \"ETHEREUM\" , \"collection\" : \"ETHEREUM:0x23581767a106ae21c074b2276d25e5c3e136a68b\" , \"contract\" : \"ETHEREUM:0x23581767a106ae21c074b2276d25e5c3e136a68b\" , \"tokenId\" : \"1474\" , \"creators\" : [{ \"account\" : \"ETHEREUM:0x1bcb5e317671cf1931a2095cbc2ff1a1378a2fd4\" , \"value\" : 10000 }], \"owners\" : [], \"royalties\" : [{ \"account\" : \"ETHEREUM:0xc8a5592031f93debea5d9e67a396944ee01bb2ca\" , \"value\" : 500 }], \"lazySupply\" : \"0\" , \"pending\" : [], \"mintedAt\" : \"2022-04-16T15:47:56Z\" , \"lastUpdatedAt\" : \"2022-04-29T08:28:35Z\" , \"supply\" : \"1\" , \"meta\" : { \"name\" : \"#1474\" , \"attributes\" : [{ \"key\" : \"Eyes\" , \"value\" : \"Open\" }, { \"key\" : \"Headwear\" , \"value\" : \"Halo\" }, { \"key\" : \"Body\" , \"value\" : \"Crescent\" }, { \"key\" : \"Feathers\" , \"value\" : \"Purple\" }, { \"key\" : \"Background\" , \"value\" : \"Yellow\" }, { \"key\" : \"Beak\" , \"value\" : \"Long\" }], \"content\" : [{ \"@type\" : \"IMAGE\" , \"url\" : \"https://live---metadata-5covpqijaa-uc.a.run.app/images/1474\" , \"representation\" : \"ORIGINAL\" , \"mimeType\" : \"image/png\" , \"width\" : 1008 , \"height\" : 1008 }], \"restrictions\" : [] }, \"deleted\" : false , \"auctions\" : [], \"totalStock\" : \"0\" , \"sellers\" : 0 , \"lastSale\" : { \"date\" : \"2022-04-26T00:58:00Z\" , \"seller\" : \"ETHEREUM:0xf16e9d68e71fb936cf7d35c4c2b25e1f7d13e70a\" , \"buyer\" : \"ETHEREUM:0x9e7e99d56f8cadb8fde5956bc1c9b9ab1550ed2f\" , \"value\" : \"1\" , \"currency\" : { \"@type\" : \"ETH\" , \"blockchain\" : \"ETHEREUM\" }, \"price\" : \"27\" } } Now the fun begins! \ud83e\udd73 Since you\u2019re able to fetch all the NFT details, you can use this information to gather orders assigned to it. Get information on NFT activities \u00b6 So far, we know how to fetch collections and NFTs information. Now, we\u2019re gonna learn how we can do the same with NFT activities. We\u2019re gonna elevate an activity controller for that. To start, let\u2019s quickly remember what the activity is. An activity represents any action taken on the blockchain. Examples of activities include: minting, burning, making a bid, buying, etc. Since Rarible has its own custom indexer (for people interested in this topic, we\u2019ll cover it in other articles), it stores all of this data in a database, which you\u2019re free to explore and use. Activities can be fetched by a number of different parameters. You can get activities by user, item, or collection. The structure is similar to the one used in previous requests. Let\u2019s fetch an activity of type MINT by item, with the following request : curl https://api.rarible.org/v0.1/activities/byItem?itemId=ETHEREUM:0x23581767a106ae21c074b2276d25e5c3e136a68b:1746&type=MINT Which provides us with this information: getActivitiesByItem response { \"cursor\" : \"1650124806000_14597286_368_594483237825392469\" , \"activities\" : [ { \"@type\" : \"MINT\" , \"id\" : \"ETHEREUM:625ae855037fb52f6c436181\" , \"date\" : \"2022-04-16T16:00:06Z\" , \"lastUpdatedAt\" : \"2022-04-16T16:01:25.414Z\" , \"cursor\" : \"1650124806000_14597286_368_594483237825392469\" , \"reverted\" : false , \"owner\" : \"ETHEREUM:0xef51c6b7eff0d16038743bf924879d295a4b971f\" , \"contract\" : \"ETHEREUM:0x23581767a106ae21c074b2276d25e5c3e136a68b\" , \"tokenId\" : \"1746\" , \"itemId\" : \"ETHEREUM:0x23581767a106ae21c074b2276d25e5c3e136a68b:1746\" , \"value\" : \"1\" , \"transactionHash\" : \"0xda308c38b554ad01310444760fac3dba0ff614d08985a0a3b76ce1230c29c853\" , \"blockchainInfo\" : { \"transactionHash\" : \"0xda308c38b554ad01310444760fac3dba0ff614d08985a0a3b76ce1230c29c853\" , \"blockHash\" : \"0xe2190936e3d748e26ab6d3a0351d053e2c7219eab18d4420a24b8c39d2b8e768\" , \"blockNumber\" : 14597286 , \"logIndex\" : 368 } } ] } You can now see all available activity info, such as type, date, reverted (it tells you if the transaction was indexed but not reflected in the blockchain), etc. Summary \u00b6 In this article, we gave you an overview of the Rarible Multichain Protocol API , which allows you to fetch much different information about NFT collections, activities, and more. We mainly focused on the most used controllers, i.e., items , and collection controllers. There are many more, though! The Rarible Multichain API can be used to build your own custom apps. It\u2019s free, and it allows you to include tons of functionalities out of the box. You can list NFTs, activities, and marketplaces, all without a single line of solidity code.","title":"Fetch NFT data"},{"location":"getting-started/fetch-nft-data/#how-to-fetch-nft-data-using-rarible-multichain-api","text":"In the previous article , we showed you how to find NFTs you\u2019re interested in, by using different searching parameters (such as collection, address, or user name) on a marketplace\u2019s website. In general, that\u2019s a very simple process\u2026unless you want to fetch details from many different NFTs. In this article, we\u2019ll learn how to get information on NFTs-related activities, straight from the source. In other words, we will cover how you can implement the same functionality you see on the Rarible Marketplace , using the Rarible Multichain Protocol. The Rarible Multichain Protocol is an API developed by the Rarible team that allows you to fetch activity information of different NFT projects \u2014 NFTs details, orders, owners, bids, etc. Since we will be using an API to get information, you\u2019ll be able to fully automate the search process and do it in a structured and repetitive manner.","title":"How to fetch NFT data using Rarible Multichain API"},{"location":"getting-started/fetch-nft-data/#api-overview","text":"The Rarible Multichain Protocol organizes search capabilities in a set of controllers. Each controller provides a fine-grained API to retrieve certain pieces of information about the NFT, or any of its attributes. The API comprises the following controllers: Signature Controller \u2014 responsible for verifying signatures of messages Currency Controller \u2014 it allows us to get a USDC rate for a given token Item Controller \u2014 it lets us check all sorts of item-related information, like item details, owner, collection, etc. Ownership Controller \u2014 returns ownership details Order Controller \u2014 responsible for fetching order information, like sell order, order by id, orders by the maker Auction Controller \u2014 auctions related information (auctions are not yet supported on the API) Activity Controller \u2014 activity information, such as token transfer, minting, burning, aggregated by users, items, collections Collection Controller \u2014 collections-related information As you can see, there is a controller for every imaginable parameter, so getting the desired information won\u2019t be a problem. The hard part is to easily navigate through the information we get from them, and make our logic as simple as possible.","title":"API Overview"},{"location":"getting-started/fetch-nft-data/#search-for-a-collection","text":"Let\u2019s recreate a simple scenario, just to put this into context. Let\u2019s say that the only information we have about a collection is its ID, aka collection address. It\u2019s the moonbird collection , and we want to know everything about it. We access the Rarible Multichain API docs and start building. Since the only information we have is the collection address, the first endpoint we\u2019ll use is getCollectionById . To be precise, it\u2019s this one. As we can see, we have to pass the collection address as a parameter, along with the blockchain name in which the contract resides. To get the contract address of a collection, we access the Rarible website and find the collection by name. There, we\u2019re able to get the contract address, which appears right under the collection\u2019s name. We\u2019re now ready to make the first request. curl https://api.rarible.org/v0.1/collections/ETHEREUM:0x23581767a106ae21c074b2276d25e5c3e136a68b We\u2019re then able to retrieve the following information: Collections response { \"id\" : \"ETHEREUM:0x23581767a106ae21c074b2276d25e5c3e136a68b\" , \"blockchain\" : \"ETHEREUM\" , \"type\" : \"ERC721\" , \"name\" : \"Moonbirds\" , \"symbol\" : \"MOONBIRD\" , \"owner\" : \"ETHEREUM:0x83895f7508926741cd2147c4aac65c30a851cc30\" , \"features\" : [ \"APPROVE_FOR_ALL\" ], \"minters\" : [], \"meta\" : { \"name\" : \"Moonbirds\" , \"description\" : \"A collection of 10,000 utility-enabled PFPs that feature a richly diverse and unique pool of rarity-powered traits. What's more, each Moonbird unlocks private club membership and additional benefits the longer you hold them. We call it nesting \u2013 because, obviously.\" , \"content\" : [ { \"@type\" : \"IMAGE\" , \"url\" : \"https://lh3.googleusercontent.com/sn5iLHUcNuUO98w_9Z7cat32hiqvVkPYr6tzHUacESg4PePh9M3jySvpttyWWXHD2e8M4PNQqgorU9sUvpX-FHQHXFBiCpKjloC2nA=s120\" , \"representation\" : \"ORIGINAL\" } ], \"externalLink\" : \"https://moonbirds.xyz\" , \"sellerFeeBasisPoints\" : 250 , \"feeRecipient\" : \"ETHEREUM:0xc8a5592031f93debea5d9e67a396944ee01bb2ca\" }, \"bestBidOrder\" : { \"id\" : \"ETHEREUM:0x299628bf0f59e046b3edd259bbf66c4e11dc5b02dcc13a65cf86cf7d02ce9b34\" , \"fill\" : \"0\" , \"platform\" : \"RARIBLE\" , \"status\" : \"ACTIVE\" , \"makeStock\" : \"11.1\" , \"cancelled\" : false , \"createdAt\" : \"2022-06-20T14:46:47.960Z\" , \"lastUpdatedAt\" : \"2022-06-22T04:11:45Z\" , \"dbUpdatedAt\" : \"2022-06-22T04:12:09.894Z\" , \"takePrice\" : \"11.1\" , \"takePriceUsd\" : \"12042.01013500119849\" , \"maker\" : \"ETHEREUM:0x0272aafe06eff7a72420835b1e5a60ba118cb2fc\" , \"make\" : { \"type\" : { \"@type\" : \"ERC20\" , \"contract\" : \"ETHEREUM:0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2\" }, \"value\" : \"11.1\" }, \"take\" : { \"type\" : { \"@type\" : \"COLLECTION\" , \"contract\" : \"ETHEREUM:0x23581767a106ae21c074b2276d25e5c3e136a68b\" }, \"value\" : \"1\" }, \"salt\" : \"0x270199a227cc7cddb27513ab58ccbb803e6c7b9f4c677d9023462af182b8b5df\" , \"signature\" : \"0x2a3804723ded47b71f7ca3acf64c0bb3f1f507603ca67dab3c0ba123915aedf251be329e0e5fe5157404a16099e1603cdd5b38d55af6dfa7fd1a894289105b0c01\" , \"pending\" : [], \"data\" : { \"@type\" : \"ETH_RARIBLE_V2\" , \"payouts\" : [], \"originFees\" : [ { \"account\" : \"ETHEREUM:0x1cf0df2a5a20cd61d68d4489eebbf85b8d39e18a\" , \"value\" : 100 } ] } } } Let\u2019s examine the received data. With the above response, we can see which blockchain the collection was minted on, what type of NFT it represents (ERC721 vs ERC1155), who is the owner of the collection (in other words, which address deployed the contract) and metadata information (which tells you the collection name, description, etc.). Moving on, we have the bestBidOrder parameter, which looks like this: bestBidOrder \"bestBidOrder\" : { \"id\" : \"ETHEREUM:0x299628bf0f59e046b3edd259bbf66c4e11dc5b02dcc13a65cf86cf7d02ce9b34\" , \"fill\" : \"0\" , \"platform\" : \"RARIBLE\" , \"status\" : \"ACTIVE\" , \"makeStock\" : \"11.1\" , \"cancelled\" : false , \"createdAt\" : \"2022-06-20T14:46:47.960Z\" , \"lastUpdatedAt\" : \"2022-06-22T04:11:45Z\" , \"dbUpdatedAt\" : \"2022-06-22T04:12:09.894Z\" , \"takePrice\" : \"11.1\" , \"takePriceUsd\" : \"12042.01013500119849\" , \"maker\" : \"ETHEREUM:0x0272aafe06eff7a72420835b1e5a60ba118cb2fc\" , \"make\" : { \"type\" : { \"@type\" : \"ERC20\" , \"contract\" : \"ETHEREUM:0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2\" }, \"value\" : \"11.1\" }, \"take\" : { \"type\" : { \"@type\" : \"COLLECTION\" , \"contract\" : \"ETHEREUM:0x23581767a106ae21c074b2276d25e5c3e136a68b\" }, \"value\" : \"1\" }, \"salt\" : \"0x270199a227cc7cddb27513ab58ccbb803e6c7b9f4c677d9023462af182b8b5df\" , \"signature\" : \"0x2a3804723ded47b71f7ca3acf64c0bb3f1f507603ca67dab3c0ba123915aedf251be329e0e5fe5157404a16099e1603cdd5b38d55af6dfa7fd1a894289105b0c01\" , \"pending\" : [], \"data\" : { \"@type\" : \"ETH_RARIBLE_V2\" , \"payouts\" : [], \"originFees\" : [ { \"account\" : \"ETHEREUM:0x1cf0df2a5a20cd61d68d4489eebbf85b8d39e18a\" , \"value\" : 100 } ] } } Here, we can see the bestBidOrder information related to the collection, which shows the details of an offer someone made to an NFT in this collection. We can also see which platform the offer was created on, if it\u2019s active or not, the value associated with this offer, etc. In addition to the maker and taker parameters, we\u2019re able to see what type of assets are offered. In this example, the maker offers 11.1 ERC20 tokens from a given address. You can check which token was offered, by typing its address on etherscan . In this case, the offer was made in DAI tokens. You can also check what the offer maker wants in return, in the take parameter. It\u2019s a collection type token from a given contract. In our case, the moonbird collection token.","title":"Search for a collection"},{"location":"getting-started/fetch-nft-data/#get-all-nfts-in-a-collection","text":"Moving on, since NFTs are created inside a collection, the next logical step will be to find all the NFTs in that collection. We will do it by using an item controller and the getItemsByCollection endpoint. curl https://api.rarible.org/v0.1/items/byCollection?collection = ETHEREUM:0x23581767a106ae21c074b2276d25e5c3e136a68b An example of a received response can be seen below. { \"total\" : 50 , \"continuation\" : \"1655744480000_0x23581767a106ae21c074b2276d25e5c3e136a68b:8902\" , \"items\" : [{ \"...\" }] } Since the moonbirds collection contains 10.000 NFTs, we won\u2019t be able to fetch all of them with a single request. With a single request we\u2019re able to get up to 50 items and the continuation string, which allows us to iterate over the next set of items. We just need to make a new request with added continuation string as a query parameter, like this: curl https://api.rarible.org/v0.1/items/byCollection?collection = ETHEREUM:0x23581767a106ae21c074b2276d25e5c3e136a68b & continuation = 1655744480000_0x23581767a106ae21c074b2276d25e5c3e136a68b:8902 The continuation string will be present until we fetch all the NFTs. This is an example of how the JSON items looks. As you can see in the response below, you can find all the information related to the NFT. items { \"id\" : \"ETHEREUM:0x23581767a106ae21c074b2276d25e5c3e136a68b:1474\" , \"blockchain\" : \"ETHEREUM\" , \"collection\" : \"ETHEREUM:0x23581767a106ae21c074b2276d25e5c3e136a68b\" , \"contract\" : \"ETHEREUM:0x23581767a106ae21c074b2276d25e5c3e136a68b\" , \"tokenId\" : \"1474\" , \"creators\" : [{ \"account\" : \"ETHEREUM:0x1bcb5e317671cf1931a2095cbc2ff1a1378a2fd4\" , \"value\" : 10000 }], \"owners\" : [], \"royalties\" : [{ \"account\" : \"ETHEREUM:0xc8a5592031f93debea5d9e67a396944ee01bb2ca\" , \"value\" : 500 }], \"lazySupply\" : \"0\" , \"pending\" : [], \"mintedAt\" : \"2022-04-16T15:47:56Z\" , \"lastUpdatedAt\" : \"2022-04-29T08:28:35Z\" , \"supply\" : \"1\" , \"meta\" : { \"name\" : \"#1474\" , \"attributes\" : [{ \"key\" : \"Eyes\" , \"value\" : \"Open\" }, { \"key\" : \"Headwear\" , \"value\" : \"Halo\" }, { \"key\" : \"Body\" , \"value\" : \"Crescent\" }, { \"key\" : \"Feathers\" , \"value\" : \"Purple\" }, { \"key\" : \"Background\" , \"value\" : \"Yellow\" }, { \"key\" : \"Beak\" , \"value\" : \"Long\" }], \"content\" : [{ \"@type\" : \"IMAGE\" , \"url\" : \"https://live---metadata-5covpqijaa-uc.a.run.app/images/1474\" , \"representation\" : \"ORIGINAL\" , \"mimeType\" : \"image/png\" , \"width\" : 1008 , \"height\" : 1008 }], \"restrictions\" : [] }, \"deleted\" : false , \"auctions\" : [], \"totalStock\" : \"0\" , \"sellers\" : 0 , \"lastSale\" : { \"date\" : \"2022-04-26T00:58:00Z\" , \"seller\" : \"ETHEREUM:0xf16e9d68e71fb936cf7d35c4c2b25e1f7d13e70a\" , \"buyer\" : \"ETHEREUM:0x9e7e99d56f8cadb8fde5956bc1c9b9ab1550ed2f\" , \"value\" : \"1\" , \"currency\" : { \"@type\" : \"ETH\" , \"blockchain\" : \"ETHEREUM\" }, \"price\" : \"27\" } } Now the fun begins! \ud83e\udd73 Since you\u2019re able to fetch all the NFT details, you can use this information to gather orders assigned to it.","title":"Get all NFTs in a collection"},{"location":"getting-started/fetch-nft-data/#get-information-on-nft-activities","text":"So far, we know how to fetch collections and NFTs information. Now, we\u2019re gonna learn how we can do the same with NFT activities. We\u2019re gonna elevate an activity controller for that. To start, let\u2019s quickly remember what the activity is. An activity represents any action taken on the blockchain. Examples of activities include: minting, burning, making a bid, buying, etc. Since Rarible has its own custom indexer (for people interested in this topic, we\u2019ll cover it in other articles), it stores all of this data in a database, which you\u2019re free to explore and use. Activities can be fetched by a number of different parameters. You can get activities by user, item, or collection. The structure is similar to the one used in previous requests. Let\u2019s fetch an activity of type MINT by item, with the following request : curl https://api.rarible.org/v0.1/activities/byItem?itemId=ETHEREUM:0x23581767a106ae21c074b2276d25e5c3e136a68b:1746&type=MINT Which provides us with this information: getActivitiesByItem response { \"cursor\" : \"1650124806000_14597286_368_594483237825392469\" , \"activities\" : [ { \"@type\" : \"MINT\" , \"id\" : \"ETHEREUM:625ae855037fb52f6c436181\" , \"date\" : \"2022-04-16T16:00:06Z\" , \"lastUpdatedAt\" : \"2022-04-16T16:01:25.414Z\" , \"cursor\" : \"1650124806000_14597286_368_594483237825392469\" , \"reverted\" : false , \"owner\" : \"ETHEREUM:0xef51c6b7eff0d16038743bf924879d295a4b971f\" , \"contract\" : \"ETHEREUM:0x23581767a106ae21c074b2276d25e5c3e136a68b\" , \"tokenId\" : \"1746\" , \"itemId\" : \"ETHEREUM:0x23581767a106ae21c074b2276d25e5c3e136a68b:1746\" , \"value\" : \"1\" , \"transactionHash\" : \"0xda308c38b554ad01310444760fac3dba0ff614d08985a0a3b76ce1230c29c853\" , \"blockchainInfo\" : { \"transactionHash\" : \"0xda308c38b554ad01310444760fac3dba0ff614d08985a0a3b76ce1230c29c853\" , \"blockHash\" : \"0xe2190936e3d748e26ab6d3a0351d053e2c7219eab18d4420a24b8c39d2b8e768\" , \"blockNumber\" : 14597286 , \"logIndex\" : 368 } } ] } You can now see all available activity info, such as type, date, reverted (it tells you if the transaction was indexed but not reflected in the blockchain), etc.","title":"Get information on NFT activities"},{"location":"getting-started/fetch-nft-data/#summary","text":"In this article, we gave you an overview of the Rarible Multichain Protocol API , which allows you to fetch much different information about NFT collections, activities, and more. We mainly focused on the most used controllers, i.e., items , and collection controllers. There are many more, though! The Rarible Multichain API can be used to build your own custom apps. It\u2019s free, and it allows you to include tons of functionalities out of the box. You can list NFTs, activities, and marketplaces, all without a single line of solidity code.","title":"Summary"},{"location":"getting-started/flow-blockchain-tutorial/","text":"How to create NFTs on Flow Blockchain using Rarible Protocol \u00b6 If you\u2019re looking for alternatives to the Ethereum blockchain, there are plenty of different options. One of them is Flow, a blockchain developed by the CryptoKitties and Dapper creators. It was built with scalability in mind and was tailored for intense blockchain usage. In this article, we will walk through Flow features in more detail, talk about what makes it unique, and explore the creation of NFTs on the Flow blockchain using Rarible Protocol. What is the Flow Blockchain \u00b6 Speaking in marketing terms, Flow is \u201ca fast, decentralized, and developer-friendly blockchain, designed as the foundation for a new generation of games, apps, and the digital assets that power them.\u201d To be honest, after researching it for a while, it does appear so. Let\u2019s break it down a little, and highlight all the pros. There are 4 main reasons why Flow is considered unique, often referenced as the \u201cFour Pillars\u201d , which are: Multirole architecture Resource-oriented programming Developer ergonomics Consumer onboarding We\u2019ll now break down each pillar, so you can get a better understanding of Flow blockchain. Multirole architecture On Flow, instead of every node managing everything around transactions processes (like storing the entire state), the dev team had them split into pipelines. What that means in practice is that the work is split into a few different parts, which allows the blockchain to scale dramatically. Resource-oriented programming What resources mean, in this context, is a new way of representing asset ownership. Thanks to Cadence (which is the native language of Flow\u2019s smart contracts) \u2014 \u201cdevelopers can create uniquely durable digital artifacts where ownership is tracked by the language itself, enabling a powerful new category of applications\u201d ( source ). Developer ergonomics By developer ergonomics, Flow means: developer-friendly smart contracts creation. Additionally, smart contracts on Flow are upgradable . On Flow, you are allowed to deploy a contract to mainnet in its \u201cbeta state\u201d, allowing the authors to incrementally update the code. Users are alerted about the status of the contract and are able to choose if they want to trust it now, or only after it\u2019s finalized. Consumer onboarding Flow puts a lot of effort on consumers. For example, ETH transactions contain very little information about the transaction itself. You just trust it, which is not ideal. On Flow, you get detailed transaction info and guarantees about what transactions can and cannot do. In my honest opinion, Flow does sound pretty neat . Now it\u2019s time to dive into how we can take advantage of it with Rarible Protocol. Flow contracts on Rarible Protocol \u00b6 As mentioned in the introduction, I will also provide the contracts Rarible Protocol distribute on Flow. There are four of them at the time of writing. RaribleFee: fee manager that holds the rates and addresses fees. LicensedNFT: contract interface adds royalties to NFT. You can implement this LicensedNFT on your contract (along with NFT), and your royalties will be distributed when trading on Rarible . RaribleNFT: the Rarible NFT contract that implements the Flow NFT standard is equivalent to ERC-721 or ERC-1155 on Ethereum. RaribleOrder: marketplace contract is the wrapper for the standard NFTStorefront , handling market orders. Smart Contracts Addresses Another important thing is the address of the Smart Contract that we want to use. Currently, Rarible has 4 contracts deployed, you can see them below. If you want to copy or read them, you can find all the information here . We need those addresses because, in the Multichain SDK (which used to be called Union SDK), we\u2019re referencing entities like collection ID, token ID by Union Addresses, which consists of blockchain name and address after colon, like this: FLOW:A.ebf4ae01d1284af8.RaribleNFT How can you create NFTs on Flow using the Multichain SDK? \u00b6 You can follow the project template that we\u2019ve created. The hardest part about using the Multichain SDK is setting it up, but we\u2019ve already done that for you on the GitHub template. Now, let's walk you through the Flow-specific aspects of the process. Which wallet should we use for Flow? The first important question is, which wallet can you use for Flow? Unfortunately, you can\u2019t access it from Metamask. According to official Flow suggestions , there are two options: Blocto Ledger In this example, you'll be using Blocto (which is also referenced as FCL). Create a new account, and let\u2019s get started. Coding Part \u00b6 Finally! It\u2019s time for the coding part. \ud83e\udd73 We will make this process as easy as possible. 1. Choose FCL as the desired wallet in \\_app.tsx When it comes to working with the Multichain SDK, there are two things that have to be right in order for the rest to work: Network environment Multichain address A network environment is needed for sending and signing transactions. You can treat it just like a login functionality. Multichain addresses, on the other hand, are needed because we\u2019re interacting with a few blockchains using one code base. So the code needs to know which blockchain (first part of the Multichain Address) and which entity (second part of the Multichain Address) we want to interact with. Values on \u201cdesired wallets\u201d will translate to buttons on the frontend (you can style them on an sdk-wallet-connector file using the Options function), which allows users to connect with chosen blockchains. 2. Prepare Mint Get information about the way you can mint a token. Information such as: Is lazy minting supported? Is multiple minting supported? Is the provided collection address valid? Remember that you can always check what\u2019s inside a response just by consoling it out. At the end of the function, we\u2019re storing the values which we\u2019re interested in, within useState hooks. 3. Minting In this step, we\u2019re submitting the response that we got in step #2. The best way to do it is to store it in the useState hook \ud83e\ude9d. In order to successfully mint an NFT, we also need URI, lazymint, and supply. One more thing I wanna cover in greater detail is URI. First things first, in order to successfully display an image on Rarible, the URI has to be in the following format: ipfs://ipfs/{hash} e.g. ipfs://ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp The second thing is that the URI should point to a metadata object like the one shown below. If you want to check out what\u2019s under your URI on IPFS, you have to merge https://rarible.mypinata.cloud/ipfs/ with your hash. That\u2019s it! \ud83d\ude0e Summary \u00b6 In this article, we\u2019ve walked through the process of creating NFTs with Multichain SDK, talked about how the Flow blockchain works and what makes it unique, and covered what is the proper way to store the URI.","title":"How to create NFTs on Flow Blockchain using Rarible Protocol"},{"location":"getting-started/flow-blockchain-tutorial/#how-to-create-nfts-on-flow-blockchain-using-rarible-protocol","text":"If you\u2019re looking for alternatives to the Ethereum blockchain, there are plenty of different options. One of them is Flow, a blockchain developed by the CryptoKitties and Dapper creators. It was built with scalability in mind and was tailored for intense blockchain usage. In this article, we will walk through Flow features in more detail, talk about what makes it unique, and explore the creation of NFTs on the Flow blockchain using Rarible Protocol.","title":"How to create NFTs on Flow Blockchain using Rarible Protocol"},{"location":"getting-started/flow-blockchain-tutorial/#what-is-the-flow-blockchain","text":"Speaking in marketing terms, Flow is \u201ca fast, decentralized, and developer-friendly blockchain, designed as the foundation for a new generation of games, apps, and the digital assets that power them.\u201d To be honest, after researching it for a while, it does appear so. Let\u2019s break it down a little, and highlight all the pros. There are 4 main reasons why Flow is considered unique, often referenced as the \u201cFour Pillars\u201d , which are: Multirole architecture Resource-oriented programming Developer ergonomics Consumer onboarding We\u2019ll now break down each pillar, so you can get a better understanding of Flow blockchain. Multirole architecture On Flow, instead of every node managing everything around transactions processes (like storing the entire state), the dev team had them split into pipelines. What that means in practice is that the work is split into a few different parts, which allows the blockchain to scale dramatically. Resource-oriented programming What resources mean, in this context, is a new way of representing asset ownership. Thanks to Cadence (which is the native language of Flow\u2019s smart contracts) \u2014 \u201cdevelopers can create uniquely durable digital artifacts where ownership is tracked by the language itself, enabling a powerful new category of applications\u201d ( source ). Developer ergonomics By developer ergonomics, Flow means: developer-friendly smart contracts creation. Additionally, smart contracts on Flow are upgradable . On Flow, you are allowed to deploy a contract to mainnet in its \u201cbeta state\u201d, allowing the authors to incrementally update the code. Users are alerted about the status of the contract and are able to choose if they want to trust it now, or only after it\u2019s finalized. Consumer onboarding Flow puts a lot of effort on consumers. For example, ETH transactions contain very little information about the transaction itself. You just trust it, which is not ideal. On Flow, you get detailed transaction info and guarantees about what transactions can and cannot do. In my honest opinion, Flow does sound pretty neat . Now it\u2019s time to dive into how we can take advantage of it with Rarible Protocol.","title":"What is the Flow Blockchain"},{"location":"getting-started/flow-blockchain-tutorial/#flow-contracts-on-rarible-protocol","text":"As mentioned in the introduction, I will also provide the contracts Rarible Protocol distribute on Flow. There are four of them at the time of writing. RaribleFee: fee manager that holds the rates and addresses fees. LicensedNFT: contract interface adds royalties to NFT. You can implement this LicensedNFT on your contract (along with NFT), and your royalties will be distributed when trading on Rarible . RaribleNFT: the Rarible NFT contract that implements the Flow NFT standard is equivalent to ERC-721 or ERC-1155 on Ethereum. RaribleOrder: marketplace contract is the wrapper for the standard NFTStorefront , handling market orders. Smart Contracts Addresses Another important thing is the address of the Smart Contract that we want to use. Currently, Rarible has 4 contracts deployed, you can see them below. If you want to copy or read them, you can find all the information here . We need those addresses because, in the Multichain SDK (which used to be called Union SDK), we\u2019re referencing entities like collection ID, token ID by Union Addresses, which consists of blockchain name and address after colon, like this: FLOW:A.ebf4ae01d1284af8.RaribleNFT","title":"Flow contracts on Rarible Protocol"},{"location":"getting-started/flow-blockchain-tutorial/#how-can-you-create-nfts-on-flow-using-the-multichain-sdk","text":"You can follow the project template that we\u2019ve created. The hardest part about using the Multichain SDK is setting it up, but we\u2019ve already done that for you on the GitHub template. Now, let's walk you through the Flow-specific aspects of the process. Which wallet should we use for Flow? The first important question is, which wallet can you use for Flow? Unfortunately, you can\u2019t access it from Metamask. According to official Flow suggestions , there are two options: Blocto Ledger In this example, you'll be using Blocto (which is also referenced as FCL). Create a new account, and let\u2019s get started.","title":"How can you create NFTs on Flow using the Multichain SDK?"},{"location":"getting-started/flow-blockchain-tutorial/#coding-part","text":"Finally! It\u2019s time for the coding part. \ud83e\udd73 We will make this process as easy as possible. 1. Choose FCL as the desired wallet in \\_app.tsx When it comes to working with the Multichain SDK, there are two things that have to be right in order for the rest to work: Network environment Multichain address A network environment is needed for sending and signing transactions. You can treat it just like a login functionality. Multichain addresses, on the other hand, are needed because we\u2019re interacting with a few blockchains using one code base. So the code needs to know which blockchain (first part of the Multichain Address) and which entity (second part of the Multichain Address) we want to interact with. Values on \u201cdesired wallets\u201d will translate to buttons on the frontend (you can style them on an sdk-wallet-connector file using the Options function), which allows users to connect with chosen blockchains. 2. Prepare Mint Get information about the way you can mint a token. Information such as: Is lazy minting supported? Is multiple minting supported? Is the provided collection address valid? Remember that you can always check what\u2019s inside a response just by consoling it out. At the end of the function, we\u2019re storing the values which we\u2019re interested in, within useState hooks. 3. Minting In this step, we\u2019re submitting the response that we got in step #2. The best way to do it is to store it in the useState hook \ud83e\ude9d. In order to successfully mint an NFT, we also need URI, lazymint, and supply. One more thing I wanna cover in greater detail is URI. First things first, in order to successfully display an image on Rarible, the URI has to be in the following format: ipfs://ipfs/{hash} e.g. ipfs://ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp The second thing is that the URI should point to a metadata object like the one shown below. If you want to check out what\u2019s under your URI on IPFS, you have to merge https://rarible.mypinata.cloud/ipfs/ with your hash. That\u2019s it! \ud83d\ude0e","title":"Coding Part"},{"location":"getting-started/flow-blockchain-tutorial/#summary","text":"In this article, we\u2019ve walked through the process of creating NFTs with Multichain SDK, talked about how the Flow blockchain works and what makes it unique, and covered what is the proper way to store the URI.","title":"Summary"},{"location":"getting-started/glossary/","text":"Glossary \u00b6 This document contains a glossary with an alphabetical list, definitions, and terms related to API. A | B | C | E | I | F | L | M | N | O | P | R | S | T A \u00b6 API Application Programming Interface enables different systems to interact with each other programmatically. Activity Event history with orders or NFT tokens. Asset Type Type of asset on the blockchain (NFT, Fungible Token, Native token, etc.). Asset Class Class of blockchain Assets (Ethereum, ERC20, ERC721, FA2, etc.). B \u00b6 Bid Offer a certain amount in cryptocurrency for an NFT token, and compete with other people to buy it. Burn Burning NFT effectively destroys the token and removes it entirely from the blockchain. C \u00b6 Collection NFTs are grouped in collections. Usually, in Rarible Protocol, collections are smart contracts in which NFTs are minted. Continuation Continuation token from the previous response. Contract Address of the Smart Contract. Creator Address of the NFT item creator. E \u00b6 ERC-20 The standard for fungible tokens. They have a property that makes each token the same (in type and value) as another token. ERC-721 The standard for NFT. This token type is unique and can have a different value than another token from the same smart contract. ERC-1155 The multi-token standard for NFT. A single deployed contract may include any combination of fungible tokens, non-fungible tokens, or other configurations. I \u00b6 Item Address of the NFT item. Id of the Item has format ${contract}:${tokenId} . F \u00b6 Fee Fee value for the operation. It can be Protocol fees, Origin fees, or Royalties. L \u00b6 Lazy Mint The way to defer the cost of minting an NFT until the moment it's sold to its first buyer. The gas fee for minting is included in the same transaction that assigns the NFT to the buyer. M \u00b6 Make Make the side of the Order. Make - what maker (order creator) has. Maker Creator of the order. Mint, Minting Minting is the act of publishing a unique instance of the token on the blockchain. N \u00b6 NFT Non-Fungible Tokens are one-of-a-kind tokens that represent a unique good or asset, like digital art. O \u00b6 Origin Fee Extra fee that can be included in the order. This fee will be paid by exchange smart contract when order is matched. Usually, frontends can include custom origin fees to monetize. Owner Address of the NFT item owner. Ownership Entity which links owner and NFT (Item). It holds value - the amount of NFTs owned by the user. Id of the Ownership has format ${contract}:${tokenId}:${owner} . P \u00b6 Payouts Who will benefit when order is matched. If payouts are not specified, then order maker is the beneficiary. Otherwise, order maker can redirect payouts of assets to other user or users. Platform The platform where the order was created. R \u00b6 Royalties Fees that are usually paid to the creator on every sale. S \u00b6 Salt Salt is a string of data that is passed to the hash function along with the input array of data to calculate the hash. Smart Contract The programs stored on a blockchain that run when predetermined conditions are met. Supply Total number of tokens minted or to be minted. T \u00b6 Take Take the side of the order, what order creator wants to get in return for make side. Token ID Token identifier.","title":"Rarible Protocol Glossary"},{"location":"getting-started/glossary/#glossary","text":"This document contains a glossary with an alphabetical list, definitions, and terms related to API. A | B | C | E | I | F | L | M | N | O | P | R | S | T","title":"Glossary"},{"location":"getting-started/glossary/#a","text":"API Application Programming Interface enables different systems to interact with each other programmatically. Activity Event history with orders or NFT tokens. Asset Type Type of asset on the blockchain (NFT, Fungible Token, Native token, etc.). Asset Class Class of blockchain Assets (Ethereum, ERC20, ERC721, FA2, etc.).","title":"A"},{"location":"getting-started/glossary/#b","text":"Bid Offer a certain amount in cryptocurrency for an NFT token, and compete with other people to buy it. Burn Burning NFT effectively destroys the token and removes it entirely from the blockchain.","title":"B"},{"location":"getting-started/glossary/#c","text":"Collection NFTs are grouped in collections. Usually, in Rarible Protocol, collections are smart contracts in which NFTs are minted. Continuation Continuation token from the previous response. Contract Address of the Smart Contract. Creator Address of the NFT item creator.","title":"C"},{"location":"getting-started/glossary/#e","text":"ERC-20 The standard for fungible tokens. They have a property that makes each token the same (in type and value) as another token. ERC-721 The standard for NFT. This token type is unique and can have a different value than another token from the same smart contract. ERC-1155 The multi-token standard for NFT. A single deployed contract may include any combination of fungible tokens, non-fungible tokens, or other configurations.","title":"E"},{"location":"getting-started/glossary/#i","text":"Item Address of the NFT item. Id of the Item has format ${contract}:${tokenId} .","title":"I"},{"location":"getting-started/glossary/#f","text":"Fee Fee value for the operation. It can be Protocol fees, Origin fees, or Royalties.","title":"F"},{"location":"getting-started/glossary/#l","text":"Lazy Mint The way to defer the cost of minting an NFT until the moment it's sold to its first buyer. The gas fee for minting is included in the same transaction that assigns the NFT to the buyer.","title":"L"},{"location":"getting-started/glossary/#m","text":"Make Make the side of the Order. Make - what maker (order creator) has. Maker Creator of the order. Mint, Minting Minting is the act of publishing a unique instance of the token on the blockchain.","title":"M"},{"location":"getting-started/glossary/#n","text":"NFT Non-Fungible Tokens are one-of-a-kind tokens that represent a unique good or asset, like digital art.","title":"N"},{"location":"getting-started/glossary/#o","text":"Origin Fee Extra fee that can be included in the order. This fee will be paid by exchange smart contract when order is matched. Usually, frontends can include custom origin fees to monetize. Owner Address of the NFT item owner. Ownership Entity which links owner and NFT (Item). It holds value - the amount of NFTs owned by the user. Id of the Ownership has format ${contract}:${tokenId}:${owner} .","title":"O"},{"location":"getting-started/glossary/#p","text":"Payouts Who will benefit when order is matched. If payouts are not specified, then order maker is the beneficiary. Otherwise, order maker can redirect payouts of assets to other user or users. Platform The platform where the order was created.","title":"P"},{"location":"getting-started/glossary/#r","text":"Royalties Fees that are usually paid to the creator on every sale.","title":"R"},{"location":"getting-started/glossary/#s","text":"Salt Salt is a string of data that is passed to the hash function along with the input array of data to calculate the hash. Smart Contract The programs stored on a blockchain that run when predetermined conditions are met. Supply Total number of tokens minted or to be minted.","title":"S"},{"location":"getting-started/glossary/#t","text":"Take Take the side of the order, what order creator wants to get in return for make side. Token ID Token identifier.","title":"T"},{"location":"getting-started/instagram-to-nft-part-1/","text":"Instagram to NFT service with Rarible Protocol. Part 1 \u00b6 In this tutorial, you're going to learn how you can build a CocoNFT clone. What is CocoNFT, you\u2019d probably ask? It\u2019s a service that allows you to mint your Instagram posts as NFTs. Project is splitted into a 2 part series. Including everything into one article would feel overwhelming. In the first part (the one you\u2019re currently reading), we're going to explain how to let users Authorize their Instagram accounts on the app, so they can fetch their photos. In the second part , we\u2019re going to dive deeper into integrating the application with Metamask and many different wallets. This will allow users to interact with a bunch of different blockchains, such as Polygon, Ethereum, Flow, Tezos, to name a few. All of this will be done using Rarible Protocol APIs/SDK. If you want to follow along with the finished code, here is the GitHub repo . Create an Instagram App that can authorize a user \u00b6 Since scraping websites like Facebook or Instagram is a daunting task, it\u2019s much easier to just use their API, because, well\u2026 they provide it. First, you have to go to the Facebook for Developers website . There, you have to go to \u201cMy Apps\u201d. Click the big green button \u201cCreate an app\u201d (no screenshot included here, because you won\u2019t miss it for sure). After that, you can choose an app type. There are quite a few different types here, but let\u2019s select \u201cConsumer\u201d. From here, we can set up more products. Since we\u2019re focused on Instagram, click the \u201cSet Up\u201d button under the \u201cInstagram Basic Display\u201d option. From now on, you should see Instagram\u2019s Basic Display on the left sidebar. If you\u2019re following this tutorial, you should also see a big red error. Don\u2019t worry, we\u2019re going to solve it now. Go to Settings > Basic. You can then see App ID and App Secret. While we\u2019re on top of the page, you should also add the Privacy Policy URL and User Data Deletion. These fields are mandatory. What\u2019s funny is that it can be a totally fake URL (that would kinda breach the ToS of Meta and GDPR, I think). It just needs to have HTTPS and return status 200. I\u2019m using httpstat.us/200 which is basically a tool that always returns the 200 status code. There is one more thing that we have to do while we are still on the Settings / Basic page: adding a platform. Localize a big \u201c Add Platform\u201d button on the bottom, click on it, and you should see the following popup. Select the website option. Add a website URL. After we filled in all required URLs and added a platform, we are able to create a New App on Instagram Basic Display. You\u2019ll need to provide the correct URLs. This step is very important, because the Valid OAuth Redirect URI is an address where the Instagram Authorize window will redirect you with the Authorization Token as a query parameter. So in an ideal scenario, you would pass your backend API address here, save the token in the database, and then redirect the user to the proper page. The next step is to add the following options to submission. They are required to allow us to fetch user data. Okay, the setup step is already done\u2026 almost \ud83e\udd70. You also have to add an Instagram test user to be able to use the Instagram API in development mode. You can do it by going to Roles / Roles on the sidebar, and adding Instagram testers. Finally\u2026 the last step. You have to agree on becoming a test user. You can do it by going to Instagram > Settings > Apps and Websites. That\u2019s the end of the 1st section. You\u2019ve learned: How to create a Facebook App How to create an Instagram App How to invite a Test User Get all necessary tokens needed to get user medias \u00b6 When it comes to the tokens, we\u2019ll need: 1. Authorization Token \u2014 The one we receive after informing we want to authorize our app. The Authorization Token is one-time usage only, but if you mess this step up don\u2019t worry, you can always show it again. 2. Short-Lived Token \u2014 At this stage, we have an Authorization Token, which we can trade for the Short-Lived Token. It allows us to query the Instagram API for 60 minutes! That\u2019s where its name came from. But we can also go one step further, and trade it for\u2026 3. Long-Lived Token \u2014 After obtaining it, you\u2019re able to use it for up to 60 days. You\u2019re also able to extend it after 24 hours from creating it. What it means in practice, is that you will not have to ask a user for an Authorization again. Big UX win! \ud83d\udc4a Before we learn how we can obtain it, you should prepare the two values below. They will interchange in a lot of requests. APP_ID APP_SECRET We can get both of them on the FB For Developers Instagram Panel. Authorization Token \u00b6 In order to retrieve the Authorization Token, first, we have to prepare the following URL: https://api.instagram.com/oauth/authorize?client_id=6201234567890178&redirect_uri=https://httpstat.us/200&scope=user_profile,user_media&response_type=code You\u2019ll need a few parameters here. client_id , redirect_uri , the scope of granted access. We talked about all of them earlier. After the URL creation, simply paste it to the browser. Then, the authorize page will pop up like it was shown earlier. Click on Authorization, and it will take you to the Redirect URI, which you\u2019ve provided, but (and that\u2019s the fun part) with an added code parameter. An example of a URL looks like this: https://httpstat.us/200?code=AQBvJwCZtYdj1zLH_5myoAA1GRRpDhs1vcHFMzB4gvRk6dLkq5dNd24EVZ5FD9WoqQhfSuo6arUB17MPu2gRqEzP6EpsAl-9_2eC9-L6mWYQdWDyarkwDSNEs8T3gvoH-WLMHzhwwd6DJqP5PxJGf2ve53m7aGMEua3MzV8FZQVz5AfwWPN3G87n25jMBGgGGVj6G4pxJ9HqzNKmdpYK8GHKnRn_G03scHtUraFlEX5faCvz6ZO7Xw#_ This is the code we require, so copy it and delete the last two characters, \u201c#_\u201d to be precise. They are always added, and you have to delete them. Short-Lived Token \u00b6 In order to obtain this one, we\u2019ll need to do a POST request with form data added. We\u2019ll need: CLIENT_ID \u2014 which you can grab on FB For Developers / Instagram Display Page, it\u2019s called App ID on the page CLIENT_SECRET \u2014 same as above, only it\u2019s located to the right GRANT_TYPE \u2014 \u201cauthorization_code\u201d REDIRECT_URI \u2014 redirection URI which you\u2019ve provided CODE \u2014 authorization token which we obtained in the previous step If you\u2019re using Postman, which I highly recommend for doing HTTP requests, your page should look similar to mine. Names in between curly braces are called Environment Variables. You can set them in global, and reuse them throughout the app. https://api.instagram.com/oauth/access_token After sending a successful request, you should see the following answer. If you mess something up, just read the error description and repeat the step to obtain the Authorization Token. Remember that it can only be used once. Going back to response values, access_token is our short-lived token, and user_id is, well, our user ID. It doesn\u2019t change at all, so you can also store it in the Global Vars on Postman. Congratulations! You\u2019re now able to fetch user data! For now, it\u2019s valid only for 60 minutes, so let\u2019s work on that right now. Long-Lived Token \u00b6 In order to change the Short-Lived Token into the Long-Lived one, you\u2019re going to have to do a GET request to this address: https://graph.instagram.com/v13.0/access_token?client_secret={{APP_SECRET}}&access_token={{ACCESS_TOKEN}}&grant_type=ig_exchange_token In exchange, you\u2019ll get a self-explanatory response. Grab an access_token value, and you\u2019re good to go. You have a Long-Lived Token, now! Fetch media details \u00b6 We\u2019ve come a long way, but we\u2019re finally here! After creating an Instagram App and getting a Long-Lived Token, we\u2019re now ready to do some coding. Since we don\u2019t really have an HTTPS on localhost, we\u2019ll just use an access_token straight from the code. If you\u2019d like to go live with that, you just need to change a few things. Maybe create some sort of backend API, replace the Instagram Redirect URI to your website\u2019s one, and take it from there. This is just for tutorial purposes, so I won\u2019t do that here. Of course, there are a lot of different ways to achieve the same goal, so it\u2019s better to focus on concepts here. The URLs which you\u2019ll need in order to get those data are: 1. Fetch IDs of user media https://graph.instagram.com/v13.0/{{USER_ID}}/media?access_token={{LONG_LIVE_TOKEN}}&fields=id,timestamp Ids are the MEDIA_ID . 2. Fetch media URL, using previously obtained IDs https://graph.instagram.com/v13.0/{{MEDIA_ID}}/media?access_token={{LONG_LIVE_TOKEN}}&fields=media_url,media_type Where MEDIA_ID are the IDs fetched earlier. Finally, \u2014 here comes my favourite part: To the code soldiers! \ud83e\udd73 Compared to the work that we\u2019ve already done, it will be pretty quick. 1. Fetch IDs of users\u2019 media 2. Fetch portion of retrieved posts Since there is an API requests rate limit, which equals 200 requests per hour per token, I prefer to fetch posts in portions when a user actually wants to fetch more than X. Thanks to that, we\u2019re saving our requests rate, as well as internet throughput. 3. Display fetched media In the final step, you just have to map the media details array and use media_url as an image source. Summing it up \u00b6 We know that the article was quite big, but look how much you've done. You\u2019ve created an Instagram App, set it up, authorized a user, created a long-lived token, fetched IDs of users\u2019 media, got media URLs, and in the final step, displayed it. Feel free to read it again, especially the token creation part, just to understand better how the flow works. In the second part , you'll implement the NFT creation out of Instagram posts.","title":"Instagram to NFT service with Rarible Part 1"},{"location":"getting-started/instagram-to-nft-part-1/#instagram-to-nft-service-with-rarible-protocol-part-1","text":"In this tutorial, you're going to learn how you can build a CocoNFT clone. What is CocoNFT, you\u2019d probably ask? It\u2019s a service that allows you to mint your Instagram posts as NFTs. Project is splitted into a 2 part series. Including everything into one article would feel overwhelming. In the first part (the one you\u2019re currently reading), we're going to explain how to let users Authorize their Instagram accounts on the app, so they can fetch their photos. In the second part , we\u2019re going to dive deeper into integrating the application with Metamask and many different wallets. This will allow users to interact with a bunch of different blockchains, such as Polygon, Ethereum, Flow, Tezos, to name a few. All of this will be done using Rarible Protocol APIs/SDK. If you want to follow along with the finished code, here is the GitHub repo .","title":"Instagram to NFT service with Rarible Protocol. Part 1"},{"location":"getting-started/instagram-to-nft-part-1/#create-an-instagram-app-that-can-authorize-a-user","text":"Since scraping websites like Facebook or Instagram is a daunting task, it\u2019s much easier to just use their API, because, well\u2026 they provide it. First, you have to go to the Facebook for Developers website . There, you have to go to \u201cMy Apps\u201d. Click the big green button \u201cCreate an app\u201d (no screenshot included here, because you won\u2019t miss it for sure). After that, you can choose an app type. There are quite a few different types here, but let\u2019s select \u201cConsumer\u201d. From here, we can set up more products. Since we\u2019re focused on Instagram, click the \u201cSet Up\u201d button under the \u201cInstagram Basic Display\u201d option. From now on, you should see Instagram\u2019s Basic Display on the left sidebar. If you\u2019re following this tutorial, you should also see a big red error. Don\u2019t worry, we\u2019re going to solve it now. Go to Settings > Basic. You can then see App ID and App Secret. While we\u2019re on top of the page, you should also add the Privacy Policy URL and User Data Deletion. These fields are mandatory. What\u2019s funny is that it can be a totally fake URL (that would kinda breach the ToS of Meta and GDPR, I think). It just needs to have HTTPS and return status 200. I\u2019m using httpstat.us/200 which is basically a tool that always returns the 200 status code. There is one more thing that we have to do while we are still on the Settings / Basic page: adding a platform. Localize a big \u201c Add Platform\u201d button on the bottom, click on it, and you should see the following popup. Select the website option. Add a website URL. After we filled in all required URLs and added a platform, we are able to create a New App on Instagram Basic Display. You\u2019ll need to provide the correct URLs. This step is very important, because the Valid OAuth Redirect URI is an address where the Instagram Authorize window will redirect you with the Authorization Token as a query parameter. So in an ideal scenario, you would pass your backend API address here, save the token in the database, and then redirect the user to the proper page. The next step is to add the following options to submission. They are required to allow us to fetch user data. Okay, the setup step is already done\u2026 almost \ud83e\udd70. You also have to add an Instagram test user to be able to use the Instagram API in development mode. You can do it by going to Roles / Roles on the sidebar, and adding Instagram testers. Finally\u2026 the last step. You have to agree on becoming a test user. You can do it by going to Instagram > Settings > Apps and Websites. That\u2019s the end of the 1st section. You\u2019ve learned: How to create a Facebook App How to create an Instagram App How to invite a Test User","title":"Create an Instagram App that can authorize a user"},{"location":"getting-started/instagram-to-nft-part-1/#get-all-necessary-tokens-needed-to-get-user-medias","text":"When it comes to the tokens, we\u2019ll need: 1. Authorization Token \u2014 The one we receive after informing we want to authorize our app. The Authorization Token is one-time usage only, but if you mess this step up don\u2019t worry, you can always show it again. 2. Short-Lived Token \u2014 At this stage, we have an Authorization Token, which we can trade for the Short-Lived Token. It allows us to query the Instagram API for 60 minutes! That\u2019s where its name came from. But we can also go one step further, and trade it for\u2026 3. Long-Lived Token \u2014 After obtaining it, you\u2019re able to use it for up to 60 days. You\u2019re also able to extend it after 24 hours from creating it. What it means in practice, is that you will not have to ask a user for an Authorization again. Big UX win! \ud83d\udc4a Before we learn how we can obtain it, you should prepare the two values below. They will interchange in a lot of requests. APP_ID APP_SECRET We can get both of them on the FB For Developers Instagram Panel.","title":"Get all necessary tokens needed to get user medias"},{"location":"getting-started/instagram-to-nft-part-1/#authorization-token","text":"In order to retrieve the Authorization Token, first, we have to prepare the following URL: https://api.instagram.com/oauth/authorize?client_id=6201234567890178&redirect_uri=https://httpstat.us/200&scope=user_profile,user_media&response_type=code You\u2019ll need a few parameters here. client_id , redirect_uri , the scope of granted access. We talked about all of them earlier. After the URL creation, simply paste it to the browser. Then, the authorize page will pop up like it was shown earlier. Click on Authorization, and it will take you to the Redirect URI, which you\u2019ve provided, but (and that\u2019s the fun part) with an added code parameter. An example of a URL looks like this: https://httpstat.us/200?code=AQBvJwCZtYdj1zLH_5myoAA1GRRpDhs1vcHFMzB4gvRk6dLkq5dNd24EVZ5FD9WoqQhfSuo6arUB17MPu2gRqEzP6EpsAl-9_2eC9-L6mWYQdWDyarkwDSNEs8T3gvoH-WLMHzhwwd6DJqP5PxJGf2ve53m7aGMEua3MzV8FZQVz5AfwWPN3G87n25jMBGgGGVj6G4pxJ9HqzNKmdpYK8GHKnRn_G03scHtUraFlEX5faCvz6ZO7Xw#_ This is the code we require, so copy it and delete the last two characters, \u201c#_\u201d to be precise. They are always added, and you have to delete them.","title":"Authorization Token"},{"location":"getting-started/instagram-to-nft-part-1/#short-lived-token","text":"In order to obtain this one, we\u2019ll need to do a POST request with form data added. We\u2019ll need: CLIENT_ID \u2014 which you can grab on FB For Developers / Instagram Display Page, it\u2019s called App ID on the page CLIENT_SECRET \u2014 same as above, only it\u2019s located to the right GRANT_TYPE \u2014 \u201cauthorization_code\u201d REDIRECT_URI \u2014 redirection URI which you\u2019ve provided CODE \u2014 authorization token which we obtained in the previous step If you\u2019re using Postman, which I highly recommend for doing HTTP requests, your page should look similar to mine. Names in between curly braces are called Environment Variables. You can set them in global, and reuse them throughout the app. https://api.instagram.com/oauth/access_token After sending a successful request, you should see the following answer. If you mess something up, just read the error description and repeat the step to obtain the Authorization Token. Remember that it can only be used once. Going back to response values, access_token is our short-lived token, and user_id is, well, our user ID. It doesn\u2019t change at all, so you can also store it in the Global Vars on Postman. Congratulations! You\u2019re now able to fetch user data! For now, it\u2019s valid only for 60 minutes, so let\u2019s work on that right now.","title":"Short-Lived Token"},{"location":"getting-started/instagram-to-nft-part-1/#long-lived-token","text":"In order to change the Short-Lived Token into the Long-Lived one, you\u2019re going to have to do a GET request to this address: https://graph.instagram.com/v13.0/access_token?client_secret={{APP_SECRET}}&access_token={{ACCESS_TOKEN}}&grant_type=ig_exchange_token In exchange, you\u2019ll get a self-explanatory response. Grab an access_token value, and you\u2019re good to go. You have a Long-Lived Token, now!","title":"Long-Lived Token"},{"location":"getting-started/instagram-to-nft-part-1/#fetch-media-details","text":"We\u2019ve come a long way, but we\u2019re finally here! After creating an Instagram App and getting a Long-Lived Token, we\u2019re now ready to do some coding. Since we don\u2019t really have an HTTPS on localhost, we\u2019ll just use an access_token straight from the code. If you\u2019d like to go live with that, you just need to change a few things. Maybe create some sort of backend API, replace the Instagram Redirect URI to your website\u2019s one, and take it from there. This is just for tutorial purposes, so I won\u2019t do that here. Of course, there are a lot of different ways to achieve the same goal, so it\u2019s better to focus on concepts here. The URLs which you\u2019ll need in order to get those data are: 1. Fetch IDs of user media https://graph.instagram.com/v13.0/{{USER_ID}}/media?access_token={{LONG_LIVE_TOKEN}}&fields=id,timestamp Ids are the MEDIA_ID . 2. Fetch media URL, using previously obtained IDs https://graph.instagram.com/v13.0/{{MEDIA_ID}}/media?access_token={{LONG_LIVE_TOKEN}}&fields=media_url,media_type Where MEDIA_ID are the IDs fetched earlier. Finally, \u2014 here comes my favourite part: To the code soldiers! \ud83e\udd73 Compared to the work that we\u2019ve already done, it will be pretty quick. 1. Fetch IDs of users\u2019 media 2. Fetch portion of retrieved posts Since there is an API requests rate limit, which equals 200 requests per hour per token, I prefer to fetch posts in portions when a user actually wants to fetch more than X. Thanks to that, we\u2019re saving our requests rate, as well as internet throughput. 3. Display fetched media In the final step, you just have to map the media details array and use media_url as an image source.","title":"Fetch media details"},{"location":"getting-started/instagram-to-nft-part-1/#summing-it-up","text":"We know that the article was quite big, but look how much you've done. You\u2019ve created an Instagram App, set it up, authorized a user, created a long-lived token, fetched IDs of users\u2019 media, got media URLs, and in the final step, displayed it. Feel free to read it again, especially the token creation part, just to understand better how the flow works. In the second part , you'll implement the NFT creation out of Instagram posts.","title":"Summing it up"},{"location":"getting-started/instagram-to-nft-part-2/","text":"Instagram to NFT service with Rarible Protocol. Part 2 \u00b6 Let\u2019s continue our journey to create a CocoNFT clone, a service that allows you to connect your Instagram and mint your posts as NFTs. Today, we are going to work on the process of creating NFT\u2019s out of the Instagram posts. Before we start, check out the first part . Setting up a connector \u00b6 When it comes to the connector-setup.tsx file, there aren\u2019t many changes you\u2019ll need to perform. It\u2019s important, though, to know what\u2019s happening. In this file, we set up available wallets. All available providers and their implementation can be found here . We\u2019ve included just the Metamask and FCL wallet for the sake of simplicity. The most critical variable in this file is a \u201cconnector\u201d, which allows us to connect to the desired wallets. As you can see, we create it wi th injected and state variables, and then, in case we want to add other options, we call add on the method chain. Summing it up, I think that it\u2019s safe to say that we use a connector only to initialize wallet implementations and export them so that we can use them elsewhere. Creating SdkWalletConnector Wrapper \u00b6 In the SdkWalletConnector element, the most important is the \"if\" statement. Here, we can control what we display in different connection statuses. For example, if the connection status is either disconnected or connecting, we display the option\u2019s element, which is responsible for showing the wallet connect buttons. It\u2019s essential to remember that we will wrap a whole app in this element because we want to have access to the SDK in every place. This means that the child element which we\u2019re passing as an argument is basically the page. Let\u2019s have a short recap of what we\u2019ve gone through so far. If the connection status is either \u201cdisconnected\u201d or \u201cconnecting\u201d on the screen, we\u2019ll see only the connect buttons because we\u2019re not displaying the child element here. The option element is pretty simple. We take all we added to connector wallets (what we added to Connector.create(injected, state). add(fcl) ), and iterate through them. If you would like to create a unique button style for every wallet, you should use the \u201coption\u201d key from objects, which we get back from the connector.getOptions() function. Going back to the if statement, in case we manage to successfully connect to the wallet, we create an SDK and display a disconnect button in accordance with the child element, which is our page. Creating SDKContext \u00b6 Since we want to be able to use SDK on every page, we elevate the possibilities that React gave us and create a context object. Wrapping an app in a SdkWalletConnector as well as in an SDKContext \u00b6 It\u2019s time to put everything we\u2019ve already created in place. First, we wrap the whole app in a SdkWalletConnector , since it\u2019s the element that creates an SDK for us. After that, we pass the SDKContext which allows us to use the SDK out of the box in all of our pages. Then, we simply pass a Component element. Using an SDK to mint an NFT \u00b6 If you had the chance to read our previous article/articles, this part will probably look familiar to you. Let\u2019s start the coding journey once again! Since this article is only dedicated to the NFT creation part, we won\u2019t cover the code from the first part . First and foremost, we need an IPFS connection in order to be able to save our NFT on IPFS. The process of adding data to IPFS is pretty straightforward. We\u2019ll connect to the appropriate node (we use the Infura one in this example). Then, we just wait for the add method. In the return statement, we need to append \u201cipfs:/\u201d to the beginning since it\u2019s the required format. In this step, we do as follows: Save post details on IPFS, and get its URI/CID address back. Define Rarible Smart Contract on Rinkeby address. Prepare mint request. Call sdk.nft.mint method with previously defined mintRequest as an argument, from the response you can also get additional info about minting possibilities such as: is lazy minting enabled?, or is multiple minting enabled? Submit the response (this line will open a Metamask window, so you can sign your transaction, it\u2019s cost-free). Result? Freshly created NFT! If you want to check out your NFT, remember to use https://rinkeby.rarible.com/token/{contractAddress}:{tokenId} as a URL. For my specific example, it is: https://rinkeby.rarible.com/token/0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:55143609719300586327244080327388661151936544170854464635146779205246455382070","title":"Instagram to NFT service with Rarible Part 2"},{"location":"getting-started/instagram-to-nft-part-2/#instagram-to-nft-service-with-rarible-protocol-part-2","text":"Let\u2019s continue our journey to create a CocoNFT clone, a service that allows you to connect your Instagram and mint your posts as NFTs. Today, we are going to work on the process of creating NFT\u2019s out of the Instagram posts. Before we start, check out the first part .","title":"Instagram to NFT service with Rarible Protocol. Part 2"},{"location":"getting-started/instagram-to-nft-part-2/#setting-up-a-connector","text":"When it comes to the connector-setup.tsx file, there aren\u2019t many changes you\u2019ll need to perform. It\u2019s important, though, to know what\u2019s happening. In this file, we set up available wallets. All available providers and their implementation can be found here . We\u2019ve included just the Metamask and FCL wallet for the sake of simplicity. The most critical variable in this file is a \u201cconnector\u201d, which allows us to connect to the desired wallets. As you can see, we create it wi th injected and state variables, and then, in case we want to add other options, we call add on the method chain. Summing it up, I think that it\u2019s safe to say that we use a connector only to initialize wallet implementations and export them so that we can use them elsewhere.","title":"Setting up a connector"},{"location":"getting-started/instagram-to-nft-part-2/#creating-sdkwalletconnector-wrapper","text":"In the SdkWalletConnector element, the most important is the \"if\" statement. Here, we can control what we display in different connection statuses. For example, if the connection status is either disconnected or connecting, we display the option\u2019s element, which is responsible for showing the wallet connect buttons. It\u2019s essential to remember that we will wrap a whole app in this element because we want to have access to the SDK in every place. This means that the child element which we\u2019re passing as an argument is basically the page. Let\u2019s have a short recap of what we\u2019ve gone through so far. If the connection status is either \u201cdisconnected\u201d or \u201cconnecting\u201d on the screen, we\u2019ll see only the connect buttons because we\u2019re not displaying the child element here. The option element is pretty simple. We take all we added to connector wallets (what we added to Connector.create(injected, state). add(fcl) ), and iterate through them. If you would like to create a unique button style for every wallet, you should use the \u201coption\u201d key from objects, which we get back from the connector.getOptions() function. Going back to the if statement, in case we manage to successfully connect to the wallet, we create an SDK and display a disconnect button in accordance with the child element, which is our page.","title":"Creating SdkWalletConnector Wrapper"},{"location":"getting-started/instagram-to-nft-part-2/#creating-sdkcontext","text":"Since we want to be able to use SDK on every page, we elevate the possibilities that React gave us and create a context object.","title":"Creating SDKContext"},{"location":"getting-started/instagram-to-nft-part-2/#wrapping-an-app-in-a-sdkwalletconnector-as-well-as-in-an-sdkcontext","text":"It\u2019s time to put everything we\u2019ve already created in place. First, we wrap the whole app in a SdkWalletConnector , since it\u2019s the element that creates an SDK for us. After that, we pass the SDKContext which allows us to use the SDK out of the box in all of our pages. Then, we simply pass a Component element.","title":"Wrapping an app in a SdkWalletConnector as well as in an SDKContext"},{"location":"getting-started/instagram-to-nft-part-2/#using-an-sdk-to-mint-an-nft","text":"If you had the chance to read our previous article/articles, this part will probably look familiar to you. Let\u2019s start the coding journey once again! Since this article is only dedicated to the NFT creation part, we won\u2019t cover the code from the first part . First and foremost, we need an IPFS connection in order to be able to save our NFT on IPFS. The process of adding data to IPFS is pretty straightforward. We\u2019ll connect to the appropriate node (we use the Infura one in this example). Then, we just wait for the add method. In the return statement, we need to append \u201cipfs:/\u201d to the beginning since it\u2019s the required format. In this step, we do as follows: Save post details on IPFS, and get its URI/CID address back. Define Rarible Smart Contract on Rinkeby address. Prepare mint request. Call sdk.nft.mint method with previously defined mintRequest as an argument, from the response you can also get additional info about minting possibilities such as: is lazy minting enabled?, or is multiple minting enabled? Submit the response (this line will open a Metamask window, so you can sign your transaction, it\u2019s cost-free). Result? Freshly created NFT! If you want to check out your NFT, remember to use https://rinkeby.rarible.com/token/{contractAddress}:{tokenId} as a URL. For my specific example, it is: https://rinkeby.rarible.com/token/0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:55143609719300586327244080327388661151936544170854464635146779205246455382070","title":"Using an SDK to mint an NFT"},{"location":"getting-started/ipfs-example/","text":"Example of uploading & using Metadata with IPFS \u00b6 Uploading images to IPFS \u00b6 To upload images to IPFS, we will use the Pinata service. Here you can see an example using Node JS to upload an image using the Pinata API. const axios = require ( \"axios\" ); const fs = require ( \"fs\" ); const FormData = require ( \"form-data\" ); export const pinFileToIPFS = ( pinataApiKey , pinataSecretApiKey ) => { const url = `https://api.pinata.cloud/pinning/pinJSONToIPFS` ; let data = new FormData (); data . append ( \"file\" , fs . createReadStream ( \"./yourfile.png\" )); return axios . post ( url , data , { headers : { \"Content-Type\" : `multipart/form-data; boundary= ${ data . _boundary } ` , pinata_api_key : pinataApiKey , pinata_secret_api_key : pinataSecretApiKey , }, }) . then ( function ( response ) { console . log ( repsonse . IpfsHash ); }) . catch ( function ( error ) { console . log ( error ) }); }; Response to the request: { IpfsHash : // This is the IPFS multi-hash provided back for your content, PinSize : // This is how large (in bytes) the content you just pinned is, Timestamp : // This is the timestamp for your content pinning (represented in ISO 8601 format) } Creating a Metadata file for NFT \u00b6 With the IpfsHash , we can create a Metadata file. It will be connected to the NFT inside the blockchain network. { \"name\" : /* NFT Name - This must be a string */ , \"description\" : /* Description of the NFT - This must be a string */ , \"image\" : /* IPFS Hash to our content, this must be prefixed with \"ipfs://ipfs/{{ IPFS_HASH ))\" - This must be a string */ , \"external_url\" : /* This is the link to Rarible which we currently don't have, we can fill this in shortly */ , \"animation_url\" : /* IPFS Hash just as image field, but it allows every type of multimedia files. Like mp3, mp4 etc */ , // the below section is not needed. \"attributes\" : [ { \"key\" : /* Key name - This must be a string */ , \"trait_type\" : /* Trait name - This must be a string */ , \"value\" : /* Key Value - This must be a string */ } ] } Adding generated Metadata to IPFS \u00b6 Specify external_url in the format ${contractAddress}:${tokenId} , for example: \"external_url\" : \"https://app.rarible.com/0x60f80121c31a0d46b5279700f9df786054aa5ee5:123913\" Publish Metadata to IPFS: var axios = require ( 'axios' ); var data = JSON . stringify ({ \"name\" : \"Test NFT\" , \"description\" : \"Test NFT\" , \"image\" : \"ipfs://ipfs/QmW4P1Mgoka8NRCsFAaJt5AaR6XKF6Az97uCiVtGmg1FuG/image.png\" , \"external_url\" : \"https://app.rarible.com/0x60f80121c31a0d46b5279700f9df786054aa5ee5:123913\" , \"attributes\" : [{ \"key\" : \"Test\" , \"trait_type\" : \"Test\" , \"value\" : \"Test\" }]}); var config = { method : 'post' , url : 'https://api.pinata.cloud/pinning/pinFileToIPFS' , headers : { 'pinata_api_key' : // KEY_HERE, 'pinata_secret_api_key' : // SECRET_KEY_HERE, 'Content-Type' : 'application/json' }, data : data }; axios ( config ). then ( function ( response ) { console . log ( JSON . stringify ( response . data )); }). catch ( function ( error ) { console . log ( error ); }); Response example: { \"IpfsHash\" : \"QmNybufJtuvWCZ355HGejvKfUXK8VeLcPA5G7CxT9MXJJp\" , \"PinSize\" : 290 , \"Timestamp\" : \"2021-02-10T14:06:09.255Z\" } Attach the new IpfsHash to your NFT.","title":"Example of uploading & using Metadata with IPFS"},{"location":"getting-started/ipfs-example/#example-of-uploading-using-metadata-with-ipfs","text":"","title":"Example of uploading &amp; using Metadata with IPFS"},{"location":"getting-started/ipfs-example/#uploading-images-to-ipfs","text":"To upload images to IPFS, we will use the Pinata service. Here you can see an example using Node JS to upload an image using the Pinata API. const axios = require ( \"axios\" ); const fs = require ( \"fs\" ); const FormData = require ( \"form-data\" ); export const pinFileToIPFS = ( pinataApiKey , pinataSecretApiKey ) => { const url = `https://api.pinata.cloud/pinning/pinJSONToIPFS` ; let data = new FormData (); data . append ( \"file\" , fs . createReadStream ( \"./yourfile.png\" )); return axios . post ( url , data , { headers : { \"Content-Type\" : `multipart/form-data; boundary= ${ data . _boundary } ` , pinata_api_key : pinataApiKey , pinata_secret_api_key : pinataSecretApiKey , }, }) . then ( function ( response ) { console . log ( repsonse . IpfsHash ); }) . catch ( function ( error ) { console . log ( error ) }); }; Response to the request: { IpfsHash : // This is the IPFS multi-hash provided back for your content, PinSize : // This is how large (in bytes) the content you just pinned is, Timestamp : // This is the timestamp for your content pinning (represented in ISO 8601 format) }","title":"Uploading images to IPFS"},{"location":"getting-started/ipfs-example/#creating-a-metadata-file-for-nft","text":"With the IpfsHash , we can create a Metadata file. It will be connected to the NFT inside the blockchain network. { \"name\" : /* NFT Name - This must be a string */ , \"description\" : /* Description of the NFT - This must be a string */ , \"image\" : /* IPFS Hash to our content, this must be prefixed with \"ipfs://ipfs/{{ IPFS_HASH ))\" - This must be a string */ , \"external_url\" : /* This is the link to Rarible which we currently don't have, we can fill this in shortly */ , \"animation_url\" : /* IPFS Hash just as image field, but it allows every type of multimedia files. Like mp3, mp4 etc */ , // the below section is not needed. \"attributes\" : [ { \"key\" : /* Key name - This must be a string */ , \"trait_type\" : /* Trait name - This must be a string */ , \"value\" : /* Key Value - This must be a string */ } ] }","title":"Creating a Metadata file for NFT"},{"location":"getting-started/ipfs-example/#adding-generated-metadata-to-ipfs","text":"Specify external_url in the format ${contractAddress}:${tokenId} , for example: \"external_url\" : \"https://app.rarible.com/0x60f80121c31a0d46b5279700f9df786054aa5ee5:123913\" Publish Metadata to IPFS: var axios = require ( 'axios' ); var data = JSON . stringify ({ \"name\" : \"Test NFT\" , \"description\" : \"Test NFT\" , \"image\" : \"ipfs://ipfs/QmW4P1Mgoka8NRCsFAaJt5AaR6XKF6Az97uCiVtGmg1FuG/image.png\" , \"external_url\" : \"https://app.rarible.com/0x60f80121c31a0d46b5279700f9df786054aa5ee5:123913\" , \"attributes\" : [{ \"key\" : \"Test\" , \"trait_type\" : \"Test\" , \"value\" : \"Test\" }]}); var config = { method : 'post' , url : 'https://api.pinata.cloud/pinning/pinFileToIPFS' , headers : { 'pinata_api_key' : // KEY_HERE, 'pinata_secret_api_key' : // SECRET_KEY_HERE, 'Content-Type' : 'application/json' }, data : data }; axios ( config ). then ( function ( response ) { console . log ( JSON . stringify ( response . data )); }). catch ( function ( error ) { console . log ( error ); }); Response example: { \"IpfsHash\" : \"QmNybufJtuvWCZ355HGejvKfUXK8VeLcPA5G7CxT9MXJJp\" , \"PinSize\" : 290 , \"Timestamp\" : \"2021-02-10T14:06:09.255Z\" } Attach the new IpfsHash to your NFT.","title":"Adding generated Metadata to IPFS"},{"location":"getting-started/managing-sdk/","text":"Managing SDK and connecting blockchain wallets \u00b6 We're glad you're here! It means that you gave us a chance. Now it's our turn. You are able to do cool things with NFTs using Rarible Protocol like: minting burning selling transferring And basically, everything else that you can imagine. There is just one step in-between, which is setting up an SDK. The fastest way to set up Multichain SDK is to clone the template which we prepared for you. It already has all the necessary packages installed. Configure all wallets you want to use \u00b6 In order to add a wallet of your choice (like fcl, mew, beacon, flow) you have to append chain it into Connector create in src/sdk/connectors-setup file. In sdk-template there is only Metamask implemented, if you want to add other ones, please refer to official tutorial there . // Example of adding new wallet handler function mapEthereumWallet < O > ( provider : AbstractConnectionProvider < O , EthereumProviderConnectionResult > ) : ConnectionProvider < O , WalletAndAddress > { return provider . map (( state ) => ({ wallet : new EthereumWallet ( new Web3Ethereum ({ web3 : new Web3 ( state . provider ), from : state.address }) ), address : state.address , })); } const mew = mapEthereumWallet ( new MEWConnectionProvider ({ networkId : 4 , rpcUrl : ethereumRpcMap [ 4 ], }) ); After adding all the desired wallets, you have to chain them to the connector, with Metamask being first, in create method. It should look like that: // Adding all wallets which you've earlier initalised const connector = Connector . create ( injected , state ) . add ( torus ) . add ( walletLink ) . add ( mew ) . add ( beacon ) . add ( fcl ) . add ( walletConnect ); Changing buttons appearance \u00b6 If you want to change buttons appearance (e.g. different one for Metamask, different one for flow), you can do it in src/sdk/sdk-wallet-connector file. To be precise, you can do it in the Options function, right where you see the o.option. Feel free to create a component for every button and just switch the o.option which basically is just a string literal of the wallet i.e. \"Metamask\", \"fcl\", etc. function Options < C > ({ connector , connectionState } : OptionsProps < C > ) { const options$ = useMemo (() => from ( connector . getOptions ()), [ connector ]); return ( < Rx value$ = { options$ } > {( options ) => ( < div > { options . map (( o ) => ( < div key = { o . option } > < button className = \"p-2 border-radius border-gray-200 border-2\" onClick = {() => connector . connect ( o )} > Connect to { o . option } < /button> { connectionState . status === \"connecting\" && connectionState . providerId === o . provider . getId () ? \"Connecting...\" : null } < /div> ))} < /div> )} < /Rx> ); } App setup \u00b6 function MyApp ({ Component , pageProps }) { return ( < SdkWalletConnector connector = { connector } > {( sdk , wallet , connection ) => { return ( < SDKContext . Provider value = {{ sdk , wallet , connection }} > < Component {... pageProps } /> < /SDKContext.Provider> ); }} < /SdkWalletConnector> ); } Setup of an App is pretty easy, you basically don't have to change anything there, but if you're curious \u2014 SdkWalletConnector is a file where we create buttons from a connector that we defined in the first step. It's responsible for showing a different view according to the current connection state. If the user has not connected his wallet, yet it will show a different view, and if he has connected his wallet it will show a Component function, which in that is just the desired page, on which we'll be able to use an SDK. SDKContext is just a wrapper that holds information about SDK, wallet, and connection, so you can easily, and without any trouble, use it on every page. // Just like that const { sdk , wallet } = useSdkContext (); TLDR \u00b6 When setting up the SDK, there are three main files: connectors-setup \u2014 responsible for desired wallet's configuration sdk-wallet-connector \u2014 responsible for buttons appearance and wrapping a whole app app.js \u2014 which we wrap inside SDKWalletConnector and SDKContext , so we can have easy access to SDK on every page from now on","title":"Managing SDK and connecting wallets"},{"location":"getting-started/managing-sdk/#managing-sdk-and-connecting-blockchain-wallets","text":"We're glad you're here! It means that you gave us a chance. Now it's our turn. You are able to do cool things with NFTs using Rarible Protocol like: minting burning selling transferring And basically, everything else that you can imagine. There is just one step in-between, which is setting up an SDK. The fastest way to set up Multichain SDK is to clone the template which we prepared for you. It already has all the necessary packages installed.","title":"Managing SDK and connecting blockchain wallets"},{"location":"getting-started/managing-sdk/#configure-all-wallets-you-want-to-use","text":"In order to add a wallet of your choice (like fcl, mew, beacon, flow) you have to append chain it into Connector create in src/sdk/connectors-setup file. In sdk-template there is only Metamask implemented, if you want to add other ones, please refer to official tutorial there . // Example of adding new wallet handler function mapEthereumWallet < O > ( provider : AbstractConnectionProvider < O , EthereumProviderConnectionResult > ) : ConnectionProvider < O , WalletAndAddress > { return provider . map (( state ) => ({ wallet : new EthereumWallet ( new Web3Ethereum ({ web3 : new Web3 ( state . provider ), from : state.address }) ), address : state.address , })); } const mew = mapEthereumWallet ( new MEWConnectionProvider ({ networkId : 4 , rpcUrl : ethereumRpcMap [ 4 ], }) ); After adding all the desired wallets, you have to chain them to the connector, with Metamask being first, in create method. It should look like that: // Adding all wallets which you've earlier initalised const connector = Connector . create ( injected , state ) . add ( torus ) . add ( walletLink ) . add ( mew ) . add ( beacon ) . add ( fcl ) . add ( walletConnect );","title":"Configure all wallets you want to use"},{"location":"getting-started/managing-sdk/#changing-buttons-appearance","text":"If you want to change buttons appearance (e.g. different one for Metamask, different one for flow), you can do it in src/sdk/sdk-wallet-connector file. To be precise, you can do it in the Options function, right where you see the o.option. Feel free to create a component for every button and just switch the o.option which basically is just a string literal of the wallet i.e. \"Metamask\", \"fcl\", etc. function Options < C > ({ connector , connectionState } : OptionsProps < C > ) { const options$ = useMemo (() => from ( connector . getOptions ()), [ connector ]); return ( < Rx value$ = { options$ } > {( options ) => ( < div > { options . map (( o ) => ( < div key = { o . option } > < button className = \"p-2 border-radius border-gray-200 border-2\" onClick = {() => connector . connect ( o )} > Connect to { o . option } < /button> { connectionState . status === \"connecting\" && connectionState . providerId === o . provider . getId () ? \"Connecting...\" : null } < /div> ))} < /div> )} < /Rx> ); }","title":"Changing buttons appearance"},{"location":"getting-started/managing-sdk/#app-setup","text":"function MyApp ({ Component , pageProps }) { return ( < SdkWalletConnector connector = { connector } > {( sdk , wallet , connection ) => { return ( < SDKContext . Provider value = {{ sdk , wallet , connection }} > < Component {... pageProps } /> < /SDKContext.Provider> ); }} < /SdkWalletConnector> ); } Setup of an App is pretty easy, you basically don't have to change anything there, but if you're curious \u2014 SdkWalletConnector is a file where we create buttons from a connector that we defined in the first step. It's responsible for showing a different view according to the current connection state. If the user has not connected his wallet, yet it will show a different view, and if he has connected his wallet it will show a Component function, which in that is just the desired page, on which we'll be able to use an SDK. SDKContext is just a wrapper that holds information about SDK, wallet, and connection, so you can easily, and without any trouble, use it on every page. // Just like that const { sdk , wallet } = useSdkContext ();","title":"App setup"},{"location":"getting-started/managing-sdk/#tldr","text":"When setting up the SDK, there are three main files: connectors-setup \u2014 responsible for desired wallet's configuration sdk-wallet-connector \u2014 responsible for buttons appearance and wrapping a whole app app.js \u2014 which we wrap inside SDKWalletConnector and SDKContext , so we can have easy access to SDK on every page from now on","title":"TLDR"},{"location":"getting-started/nft-101/","text":"NFT 101: What you need to know, before buying your first NFT \u00b6 This article is a non-technical one, and its main goal is to help you feel comfortable navigating the different marketplaces and buying your first NFTs. Wallets \u00b6 First things first. On the internet, everything that involves possession needs some sort of authentication. In a blockchain, we achieve this by using wallets . A wallet is a pair of private and public keys, which can be used to sign a transaction and verify your identity. The private key should always be securely stored securely, because if anyone gets it, they will be able to do anything they want with your possessions (tokens, NFTs, etc.), even take them away from you. \ud83d\ude28 Metamask is the most commonly used wallet. It\u2019s a browser extension as well as a mobile app. You can install it on google extensions. Common Marketplaces \u00b6 Let\u2019s start with the question: what is an NFT marketplace after all? Every website can create its own marketplace. NFT marketplaces are nothing more than places where NFTs are accumulated and that allow users to interact and take actions towards these NFTs, e.g. buying, selling, transferring. On the marketplace, you can search for NFTs, create (or mint) them, or buy them from someone else. Some examples of big marketplaces out there would be: OpenSea OpenSea is the biggest NFT marketplace out there. It has all sorts of different assets, it\u2019s free to sign up and it generally has an easy UX. Rarible Rarible is one of the biggest players out there. It supports NFTs on a few different chains, as well as a whole lot of different digital assets. There are not only big marketplaces out there There are a ton of different marketplaces out there. As I\u2019ve said earlier, anyone can create one. Some of them are exclusive to some use cases, like the Axie Marketplace which basically revolves around the Axie Infinity game, or NiftyGateway which works exclusively with NFT drops. There are also small, private marketplaces. Metaangels or Wanderers can be two examples of those. Since they\u2019re white-labeled by Rarible it means that they can be trusted, are safe to use, and reliable. In any case, remember to follow your instincts and if something looks shady, it\u2019s better to always check it a second time. You can end up with no support and no one to contact about stolen funds. We\u2019re (currently) in the wild west, baby \ud83d\ude0e NFTs properties \u00b6 Okay, we already know some things about NFTs. We know that in order to create our account we will need a wallet, and we know where to find NFTs for sale. Technically speaking, we can create an NFT out of anything, but as I mentioned in the beginning this is not a technical article, so we\u2019re gonna focus only on what you can expect to see on a usual NFT, displayed on marketplaces. Basically, every NFT you\u2019ll see on marketplaces will have a similar information structure. Let\u2019s break them down even further. Visual asset Almost every NFT will represent some sort of a visual asset. It can be a gif, video, mp4, 3D model, or an image. Title A title is simply a name that we assign to an NFT, it doesn\u2019t have to be unique. After all, every NFT, even if it looks exactly the same as another one, is unique on its own. Collection This one is important . Basically, the collection allows us to know from which origin the NFT was created. As said earlier, nothing stops you from creating exactly the same NFT as someone else. Collections, on the other hand, are the guarantees of an origin. Often, they come as smart contracts created for this purpose. So you should always check the collections you\u2019re buying from. \u2705 Attributes Attributes are additional properties that creators can add to the NFT. If they\u2019re creating an NFT game, maybe they can add strength or agility properties that will represent some functions in the app. How can you find out if a collection is valid? The best way to do that, is to access the website of the project you want to buy. Let\u2019s say it\u2019s BAYC . You can go to their website, which you can identify thanks to the HTTPS, and you look for the marketplace\u2019s link (here\u2019s Rarible \u2019s). You then look for the collection address which is a hex address of the contract. It looks like this : \u201c 0xbc4ca0eda7647a8ab7c2061c2e118a18a936f13d \u201d. On Rarible , you can even see the verified badge, in addition to the project\u2019s website and collection address. Basically, collections allow you to check if the NFT you want to buy is a legit, original NFT from the right author, and not a \u201cfake Gucci\u201d. How can you find the collection you\u2019re looking for? If you know what you\u2019re looking for, the best way to check if the collection is legitimate, it\u2019s to start by looking into the project\u2019s website. If it\u2019s a professional, and public project it will have a link to its collection on marketplaces. If there\u2019s no link there, you can always search it by name on Rarible . If the collection shows a lot of transactions and volume on the marketplace, it\u2019s probably legit. If you can\u2019t find it on the marketplace website by doing a name search, try to find its collection address. If you can\u2019t find that too, then there\u2019s not much you can do to verify the authenticity of that NFT. Remember that NFTs can be spread between different marketplaces, but if you see an NFT on Rarible , it doesn\u2019t mean that it\u2019s automatically on every other marketplaces out there. As you can see in the image above, there are plenty of different BAYC collections, but in most cases, you can easily distinguish the original from the fake one. In the same way, you can search for a collection by using its contract address, which will return the exact collection you\u2019re looking for. How to search for collections by a creator? This situation is identical to the previous one. Let\u2019s say that you\u2019re looking for NFTs from the user \u201cDaxio\u201d. You can identify him by his username or wallet address. On his profile, you can see his wallet address, and even on which blockchain it is. As you can see in this example, the wallet address is from the Polygon blockchain. NFT ownership \u00b6 The owner of the NFT is actually the wallet address where that NFT is located at the moment. Ownership can change, of course, simply by selling that NFT, transferring it, or burning it. How to check NFT overall ownership \u00b6 1. Using marketplaces On Rarible , you can scan through the NFT using the order book that exists for every NFT out there. You can see who was the previous owner, how much it was sold for in the past, and what are the current bids to that NFT. A lot of useful information about everything that happened to that NFT in the past. 2. Using etherscan If you\u2019re interested in knowing all of the transactions of a given NFT, you can also do it by checking it on etherscan . It\u2019s simple, but in order to accomplish that we\u2019ll need two things \u2014 the token id and contract address. We can get both from URL. Let\u2019s use this as an example: https://rarible.com/token/0xbc4ca0eda7647a8ab7c2061c2e118a18a936f13d:6416?tab=details As you can see, we have token/contract_address:tokenId. So in this case, the contract address is 0xbc4ca0eda7647a8ab7c2061c2e118a18a936f13d and token Id is 6416 . After getting those, we can then check the NFT on etherscan. You can do it by searching through transactions on given collections, but it\u2019s much easier if you just create a link by yourself which is https://etherscan.io/token/contractAddress?a=tokenId if we use it with the previous example, it would look like this: https://etherscan.io/token/0xbc4ca0eda7647a8ab7c2061c2e118a18a936f13d?a=6416 And voil\u00e1, you\u2019re now able to browse through all of the details straight from the source.","title":"NFT 101"},{"location":"getting-started/nft-101/#nft-101-what-you-need-to-know-before-buying-your-first-nft","text":"This article is a non-technical one, and its main goal is to help you feel comfortable navigating the different marketplaces and buying your first NFTs.","title":"NFT 101: What you need to know, before buying your first NFT"},{"location":"getting-started/nft-101/#wallets","text":"First things first. On the internet, everything that involves possession needs some sort of authentication. In a blockchain, we achieve this by using wallets . A wallet is a pair of private and public keys, which can be used to sign a transaction and verify your identity. The private key should always be securely stored securely, because if anyone gets it, they will be able to do anything they want with your possessions (tokens, NFTs, etc.), even take them away from you. \ud83d\ude28 Metamask is the most commonly used wallet. It\u2019s a browser extension as well as a mobile app. You can install it on google extensions.","title":"Wallets"},{"location":"getting-started/nft-101/#common-marketplaces","text":"Let\u2019s start with the question: what is an NFT marketplace after all? Every website can create its own marketplace. NFT marketplaces are nothing more than places where NFTs are accumulated and that allow users to interact and take actions towards these NFTs, e.g. buying, selling, transferring. On the marketplace, you can search for NFTs, create (or mint) them, or buy them from someone else. Some examples of big marketplaces out there would be: OpenSea OpenSea is the biggest NFT marketplace out there. It has all sorts of different assets, it\u2019s free to sign up and it generally has an easy UX. Rarible Rarible is one of the biggest players out there. It supports NFTs on a few different chains, as well as a whole lot of different digital assets. There are not only big marketplaces out there There are a ton of different marketplaces out there. As I\u2019ve said earlier, anyone can create one. Some of them are exclusive to some use cases, like the Axie Marketplace which basically revolves around the Axie Infinity game, or NiftyGateway which works exclusively with NFT drops. There are also small, private marketplaces. Metaangels or Wanderers can be two examples of those. Since they\u2019re white-labeled by Rarible it means that they can be trusted, are safe to use, and reliable. In any case, remember to follow your instincts and if something looks shady, it\u2019s better to always check it a second time. You can end up with no support and no one to contact about stolen funds. We\u2019re (currently) in the wild west, baby \ud83d\ude0e","title":"Common Marketplaces"},{"location":"getting-started/nft-101/#nfts-properties","text":"Okay, we already know some things about NFTs. We know that in order to create our account we will need a wallet, and we know where to find NFTs for sale. Technically speaking, we can create an NFT out of anything, but as I mentioned in the beginning this is not a technical article, so we\u2019re gonna focus only on what you can expect to see on a usual NFT, displayed on marketplaces. Basically, every NFT you\u2019ll see on marketplaces will have a similar information structure. Let\u2019s break them down even further. Visual asset Almost every NFT will represent some sort of a visual asset. It can be a gif, video, mp4, 3D model, or an image. Title A title is simply a name that we assign to an NFT, it doesn\u2019t have to be unique. After all, every NFT, even if it looks exactly the same as another one, is unique on its own. Collection This one is important . Basically, the collection allows us to know from which origin the NFT was created. As said earlier, nothing stops you from creating exactly the same NFT as someone else. Collections, on the other hand, are the guarantees of an origin. Often, they come as smart contracts created for this purpose. So you should always check the collections you\u2019re buying from. \u2705 Attributes Attributes are additional properties that creators can add to the NFT. If they\u2019re creating an NFT game, maybe they can add strength or agility properties that will represent some functions in the app. How can you find out if a collection is valid? The best way to do that, is to access the website of the project you want to buy. Let\u2019s say it\u2019s BAYC . You can go to their website, which you can identify thanks to the HTTPS, and you look for the marketplace\u2019s link (here\u2019s Rarible \u2019s). You then look for the collection address which is a hex address of the contract. It looks like this : \u201c 0xbc4ca0eda7647a8ab7c2061c2e118a18a936f13d \u201d. On Rarible , you can even see the verified badge, in addition to the project\u2019s website and collection address. Basically, collections allow you to check if the NFT you want to buy is a legit, original NFT from the right author, and not a \u201cfake Gucci\u201d. How can you find the collection you\u2019re looking for? If you know what you\u2019re looking for, the best way to check if the collection is legitimate, it\u2019s to start by looking into the project\u2019s website. If it\u2019s a professional, and public project it will have a link to its collection on marketplaces. If there\u2019s no link there, you can always search it by name on Rarible . If the collection shows a lot of transactions and volume on the marketplace, it\u2019s probably legit. If you can\u2019t find it on the marketplace website by doing a name search, try to find its collection address. If you can\u2019t find that too, then there\u2019s not much you can do to verify the authenticity of that NFT. Remember that NFTs can be spread between different marketplaces, but if you see an NFT on Rarible , it doesn\u2019t mean that it\u2019s automatically on every other marketplaces out there. As you can see in the image above, there are plenty of different BAYC collections, but in most cases, you can easily distinguish the original from the fake one. In the same way, you can search for a collection by using its contract address, which will return the exact collection you\u2019re looking for. How to search for collections by a creator? This situation is identical to the previous one. Let\u2019s say that you\u2019re looking for NFTs from the user \u201cDaxio\u201d. You can identify him by his username or wallet address. On his profile, you can see his wallet address, and even on which blockchain it is. As you can see in this example, the wallet address is from the Polygon blockchain.","title":"NFTs properties"},{"location":"getting-started/nft-101/#nft-ownership","text":"The owner of the NFT is actually the wallet address where that NFT is located at the moment. Ownership can change, of course, simply by selling that NFT, transferring it, or burning it.","title":"NFT ownership"},{"location":"getting-started/nft-101/#how-to-check-nft-overall-ownership","text":"1. Using marketplaces On Rarible , you can scan through the NFT using the order book that exists for every NFT out there. You can see who was the previous owner, how much it was sold for in the past, and what are the current bids to that NFT. A lot of useful information about everything that happened to that NFT in the past. 2. Using etherscan If you\u2019re interested in knowing all of the transactions of a given NFT, you can also do it by checking it on etherscan . It\u2019s simple, but in order to accomplish that we\u2019ll need two things \u2014 the token id and contract address. We can get both from URL. Let\u2019s use this as an example: https://rarible.com/token/0xbc4ca0eda7647a8ab7c2061c2e118a18a936f13d:6416?tab=details As you can see, we have token/contract_address:tokenId. So in this case, the contract address is 0xbc4ca0eda7647a8ab7c2061c2e118a18a936f13d and token Id is 6416 . After getting those, we can then check the NFT on etherscan. You can do it by searching through transactions on given collections, but it\u2019s much easier if you just create a link by yourself which is https://etherscan.io/token/contractAddress?a=tokenId if we use it with the previous example, it would look like this: https://etherscan.io/token/0xbc4ca0eda7647a8ab7c2061c2e118a18a936f13d?a=6416 And voil\u00e1, you\u2019re now able to browse through all of the details straight from the source.","title":"How to check NFT overall ownership"},{"location":"getting-started/nft-app-in-60-minutes/","text":"Create an app that allows you to list and sell NFTs, in 60 minutes \u00b6 In this tutorial, we\u2019ll use the Rarible protocol to create a simple, yet very practical application. In this app, users will be able to connect their Metamask wallet, see all the NFTs they own (on the Ethereum blockchain), AND list them for sale! Why dive deep into solidity and waste months on end developing and testing your own contract, when you can just use a complete and fully reliable solution FOR FREE? With only JS! \ud83d\ude04 Without further ado, let\u2019s dive into it! \u00b6 The app has 3 screens: 1. \u201cConnect wallet\u201d button screen Since the functionality of our app is limited (showing only NFTs that are owned by the user), there\u2019s no need to show anything on this 1st screen if the user hasn\u2019t yet connected his/her wallet. This functionality is tied to events, so anytime a wallet is connected or disconnected, the content on the screen will be refreshed. 2. \u201cSee your NFTs\u201d screen The main screen of our app. We\u2019re using a nice loading technique, which shows pictures only after they are fully loaded (bonus: we're gonna show you how to do this also). 3. \u201cList your NFT for sale\u201d screen Here, we can create a sell order which can be accepted by others. The buyer will be able to sign the transaction, exchanging ETH tokens to the NFT ownership. If you\u2019re more comfortable working with code by your side, here is the GitHub repo link for this project: https://github.com/kolberszymon/nft-marketplace-tutorial Clone it and you\u2019ll be ready to go. Application architecture \u00b6 Let\u2019s first talk a bit about why we are using what we are using. For the framework, we\u2019ve chosen NextJS. It has a clear project structure and provides routing out of the box. Every folder in the \u2018pages\u2019 folder, with an index file in it, is translated into a URL. It allows us to use the Static Site Generator which is a super cool feature , and, because NextJS is a React \u201crelative\u201d, we can also use context. We\u2019ll use it to wrap our app on EthereumContext, which tracks whether a wallet is connected or not. Regarding the Type Script, we\u2019ve mainly used it for educational purposes, so you can clearly see each type. \u201cConnect Metamask\u201d button screen \u00b6 The most useful and important thing you can learn from this screen is how to properly create context. Let\u2019s analyse it. As you can see, we\u2019ve imported two react functions, createContext & useContext , to be able to create a context. After that, we define ContextProps which we\u2019ll be using across our screens. (Don\u2019t feel intimidated by that \u2018Partial\u2019 thing, it\u2019s just a way to create an empty context object in TypeScript \ud83d\ude09). We export EthereumContext , as well as useEthContext . EthereumContext will be needed to wrap an app component in it, and useEthContext will be used to retrieve currently stored values. Let\u2019s take a look at the \\_app.tsx file, which is the main file for NextJS apps. As you can see, there are 2 useEffect here: one with an empty dependency array, and one watching web3 changes. The first one is responsible for checking if our browser supports web3 (in other words, it checks if Metamask is installed and if the window has an Ethereum global variable). If it doesn\u2019t, we create an event listener which will be triggered when Ethereum is initialised. The second one, allows us to always refresh the currently selected account when web3 changes. The procedures above represent a pretty standard way to start a crypto project. We destructure the Ethereum property out of window objects, and then check if it\u2019s defined and if it\u2019s Metamask. After that, we set an event listener on the Ethereum object to set accounts, every time we switch an account or disconnect it. And last but not least, we set the web3 object. As you can see, setCurrentlyConnectedAccount is used strictly for refreshing purposes. It gets your Metamask accounts, and if it finds any, it sets the first one in the array as the currently used one. The first item on the list, returned from the getAccounts function, is always the currently chosen one. Now comes the best part: \\_app.tsx file. All the hard work to set things up, paid off. Now, we just elegantly wrap the app on EthereumContext.Provider , pass in values previously defined, which will update automatically in case anything changes (since we\u2019ve set event listeners on those), and voil\u00e0! We don\u2019t have to worry about wallets anymore, the rest is strictly NFT related! \ud83e\udd29 \u201cSee your NFTs\u201d screen \u00b6 Now, we\u2019ll learn how we can list owned NFTs. If you are working with Rarible, you can find the API documentation here . We will use the getItemsByOwner endpoint. We first define the NftItem type. There are many more properties than these ones, as you can see on the screen of API response, but these four will suit our needs. Pay attention to how we are using EthContext here. \u2728 These are all the logic needed in order to show owned NFTs. Thanks to Rarible API, you can literally do it in only a few lines. First, we need to fetch data from the Rarible API and, afterwards, map through a returned list in order to adjust it to the NftItem type. The handleConnectWallet button is used to connect your Metamask account. Yep, that\u2019s how you do it, with only ONE line of code!!! People are often scared of Web3, but actually coding in it is pretty simple\u2026 Let\u2019s wrap up the HTML rendering! We have three states here: not connected, connected but NFTs are not fetched yet, and ready. We show only what is needed. In the last case, we map all the NFTs, and render tiles for each one. Here\u2019s the bonus ! If you want to create an image that will shimmer until it\u2019s fully loaded, this is how you do it: Create an isLoaded state, which defines the img display type. If it\u2019s not loaded yet, it is set to none, otherwise it\u2019s a block type. Images have onLoad property which allows us to do something when the image is fully loaded. In this case we\u2019re simply setting isLoaded to true, which copes with our previous logic. The CSS for this animation looks like this. You can find every source on github. Feel free to get \u201cinspired\u201d by that. And, yeah, by \u201cget inspired\u201d we've meant Ctrl + C , Ctrl + V . \ud83d\ude1b \u201cList your NFTs for sale\u201d screen \u00b6 Okay, here is the most interesting part of this tutorial: how can we list an NFT for sale using Rarible? Let\u2019s see: We\u2019re passing tokenId in the URL, so first, we need to retrieve it by using the next router. If tokenId exists, i.e. if somebody didn\u2019t pass the wrong URL, we\u2019ll fetch tokenData and tokenSellOrder . Unfortunately, these are two different endpoints, so we can\u2019t fetch token price and info in one request. Now let\u2019s move onto something very important, that can probably save you some time. On Rarible, there are different endpoints depending on what chain you\u2019re currently using. Since we mostly use a testing chain for development purposes, it will rarely be api.rarible.com. All you have to do is specify the current network by choosing one from NETWORKS enum. You also have to import the currentChainInfo variable and use it. Hang on, we are almost done!!! The button handler is pretty simple, since we have a good code structure. Here, we basically pass all the needed arguments and delegate it to the createSellOrder function. There are a few types of sell orders, but in this case we\u2019re choosing MAKE_ERC721_TAKE_ETH , which literally means: I want to receive ETH tokens in exchange for my ERC-721 NFT. In order to create a sell order, we have to provide the type of object that will match the request schema (this is based on EIP712 ). It\u2019s a basic \u2018copy and paste\u2019 mechanic, so you can\u2019t innovate too much in this part. After the object is created, we now want to sign it. I know it looks odd at first glance, but it really isn\u2019t! Let\u2019s walk through it. First, we just \u2018stringfy\u2019 our data. In a nutshell, we\u2019re sending bytes to the contract so the object has to be in the form of a string. Then, we use a provider which, in our case, is Metamask, to allow the user to sign the transaction. Sig variable is all we need from this function. We\u2019ve created a template for our data in the form of an object, stringfied it to JSON format, signed it with Metamask and\u2026 that\u2019s basically it. We just have one last thing to do: add a signature. We\u2019re adding it to order, like this: and we\u2019re ready to POST it! We\u2019ve include raribleJson as request body, set headers to applicaction/json and everything is ready. That\u2019s it! From now on, it is already saved on Rarible, so if we want to interact with that we do it through API requests. \ud83d\ude0a Summary \u00b6 It wasn\u2019t that hard, was it? In this tutorial we\u2019ve created a place to see your NFTs, as well as list them for sale. To do that, we used Rarible, which allows us to interact with smart contracts 100% through their API.","title":"NFT App in 60 minutes"},{"location":"getting-started/nft-app-in-60-minutes/#create-an-app-that-allows-you-to-list-and-sell-nfts-in-60-minutes","text":"In this tutorial, we\u2019ll use the Rarible protocol to create a simple, yet very practical application. In this app, users will be able to connect their Metamask wallet, see all the NFTs they own (on the Ethereum blockchain), AND list them for sale! Why dive deep into solidity and waste months on end developing and testing your own contract, when you can just use a complete and fully reliable solution FOR FREE? With only JS! \ud83d\ude04","title":"Create an app that allows you to list and sell NFTs, in 60 minutes"},{"location":"getting-started/nft-app-in-60-minutes/#without-further-ado-lets-dive-into-it","text":"The app has 3 screens: 1. \u201cConnect wallet\u201d button screen Since the functionality of our app is limited (showing only NFTs that are owned by the user), there\u2019s no need to show anything on this 1st screen if the user hasn\u2019t yet connected his/her wallet. This functionality is tied to events, so anytime a wallet is connected or disconnected, the content on the screen will be refreshed. 2. \u201cSee your NFTs\u201d screen The main screen of our app. We\u2019re using a nice loading technique, which shows pictures only after they are fully loaded (bonus: we're gonna show you how to do this also). 3. \u201cList your NFT for sale\u201d screen Here, we can create a sell order which can be accepted by others. The buyer will be able to sign the transaction, exchanging ETH tokens to the NFT ownership. If you\u2019re more comfortable working with code by your side, here is the GitHub repo link for this project: https://github.com/kolberszymon/nft-marketplace-tutorial Clone it and you\u2019ll be ready to go.","title":"Without further ado, let\u2019s dive into it!"},{"location":"getting-started/nft-app-in-60-minutes/#application-architecture","text":"Let\u2019s first talk a bit about why we are using what we are using. For the framework, we\u2019ve chosen NextJS. It has a clear project structure and provides routing out of the box. Every folder in the \u2018pages\u2019 folder, with an index file in it, is translated into a URL. It allows us to use the Static Site Generator which is a super cool feature , and, because NextJS is a React \u201crelative\u201d, we can also use context. We\u2019ll use it to wrap our app on EthereumContext, which tracks whether a wallet is connected or not. Regarding the Type Script, we\u2019ve mainly used it for educational purposes, so you can clearly see each type.","title":"Application architecture"},{"location":"getting-started/nft-app-in-60-minutes/#connect-metamask-button-screen","text":"The most useful and important thing you can learn from this screen is how to properly create context. Let\u2019s analyse it. As you can see, we\u2019ve imported two react functions, createContext & useContext , to be able to create a context. After that, we define ContextProps which we\u2019ll be using across our screens. (Don\u2019t feel intimidated by that \u2018Partial\u2019 thing, it\u2019s just a way to create an empty context object in TypeScript \ud83d\ude09). We export EthereumContext , as well as useEthContext . EthereumContext will be needed to wrap an app component in it, and useEthContext will be used to retrieve currently stored values. Let\u2019s take a look at the \\_app.tsx file, which is the main file for NextJS apps. As you can see, there are 2 useEffect here: one with an empty dependency array, and one watching web3 changes. The first one is responsible for checking if our browser supports web3 (in other words, it checks if Metamask is installed and if the window has an Ethereum global variable). If it doesn\u2019t, we create an event listener which will be triggered when Ethereum is initialised. The second one, allows us to always refresh the currently selected account when web3 changes. The procedures above represent a pretty standard way to start a crypto project. We destructure the Ethereum property out of window objects, and then check if it\u2019s defined and if it\u2019s Metamask. After that, we set an event listener on the Ethereum object to set accounts, every time we switch an account or disconnect it. And last but not least, we set the web3 object. As you can see, setCurrentlyConnectedAccount is used strictly for refreshing purposes. It gets your Metamask accounts, and if it finds any, it sets the first one in the array as the currently used one. The first item on the list, returned from the getAccounts function, is always the currently chosen one. Now comes the best part: \\_app.tsx file. All the hard work to set things up, paid off. Now, we just elegantly wrap the app on EthereumContext.Provider , pass in values previously defined, which will update automatically in case anything changes (since we\u2019ve set event listeners on those), and voil\u00e0! We don\u2019t have to worry about wallets anymore, the rest is strictly NFT related! \ud83e\udd29","title":"\u201cConnect Metamask\u201d button screen"},{"location":"getting-started/nft-app-in-60-minutes/#see-your-nfts-screen","text":"Now, we\u2019ll learn how we can list owned NFTs. If you are working with Rarible, you can find the API documentation here . We will use the getItemsByOwner endpoint. We first define the NftItem type. There are many more properties than these ones, as you can see on the screen of API response, but these four will suit our needs. Pay attention to how we are using EthContext here. \u2728 These are all the logic needed in order to show owned NFTs. Thanks to Rarible API, you can literally do it in only a few lines. First, we need to fetch data from the Rarible API and, afterwards, map through a returned list in order to adjust it to the NftItem type. The handleConnectWallet button is used to connect your Metamask account. Yep, that\u2019s how you do it, with only ONE line of code!!! People are often scared of Web3, but actually coding in it is pretty simple\u2026 Let\u2019s wrap up the HTML rendering! We have three states here: not connected, connected but NFTs are not fetched yet, and ready. We show only what is needed. In the last case, we map all the NFTs, and render tiles for each one. Here\u2019s the bonus ! If you want to create an image that will shimmer until it\u2019s fully loaded, this is how you do it: Create an isLoaded state, which defines the img display type. If it\u2019s not loaded yet, it is set to none, otherwise it\u2019s a block type. Images have onLoad property which allows us to do something when the image is fully loaded. In this case we\u2019re simply setting isLoaded to true, which copes with our previous logic. The CSS for this animation looks like this. You can find every source on github. Feel free to get \u201cinspired\u201d by that. And, yeah, by \u201cget inspired\u201d we've meant Ctrl + C , Ctrl + V . \ud83d\ude1b","title":"\u201cSee your NFTs\u201d screen"},{"location":"getting-started/nft-app-in-60-minutes/#list-your-nfts-for-sale-screen","text":"Okay, here is the most interesting part of this tutorial: how can we list an NFT for sale using Rarible? Let\u2019s see: We\u2019re passing tokenId in the URL, so first, we need to retrieve it by using the next router. If tokenId exists, i.e. if somebody didn\u2019t pass the wrong URL, we\u2019ll fetch tokenData and tokenSellOrder . Unfortunately, these are two different endpoints, so we can\u2019t fetch token price and info in one request. Now let\u2019s move onto something very important, that can probably save you some time. On Rarible, there are different endpoints depending on what chain you\u2019re currently using. Since we mostly use a testing chain for development purposes, it will rarely be api.rarible.com. All you have to do is specify the current network by choosing one from NETWORKS enum. You also have to import the currentChainInfo variable and use it. Hang on, we are almost done!!! The button handler is pretty simple, since we have a good code structure. Here, we basically pass all the needed arguments and delegate it to the createSellOrder function. There are a few types of sell orders, but in this case we\u2019re choosing MAKE_ERC721_TAKE_ETH , which literally means: I want to receive ETH tokens in exchange for my ERC-721 NFT. In order to create a sell order, we have to provide the type of object that will match the request schema (this is based on EIP712 ). It\u2019s a basic \u2018copy and paste\u2019 mechanic, so you can\u2019t innovate too much in this part. After the object is created, we now want to sign it. I know it looks odd at first glance, but it really isn\u2019t! Let\u2019s walk through it. First, we just \u2018stringfy\u2019 our data. In a nutshell, we\u2019re sending bytes to the contract so the object has to be in the form of a string. Then, we use a provider which, in our case, is Metamask, to allow the user to sign the transaction. Sig variable is all we need from this function. We\u2019ve created a template for our data in the form of an object, stringfied it to JSON format, signed it with Metamask and\u2026 that\u2019s basically it. We just have one last thing to do: add a signature. We\u2019re adding it to order, like this: and we\u2019re ready to POST it! We\u2019ve include raribleJson as request body, set headers to applicaction/json and everything is ready. That\u2019s it! From now on, it is already saved on Rarible, so if we want to interact with that we do it through API requests. \ud83d\ude0a","title":"\u201cList your NFTs for sale\u201d screen"},{"location":"getting-started/nft-app-in-60-minutes/#summary","text":"It wasn\u2019t that hard, was it? In this tutorial we\u2019ve created a place to see your NFTs, as well as list them for sale. To do that, we used Rarible, which allows us to interact with smart contracts 100% through their API.","title":"Summary"},{"location":"getting-started/quick-start/","text":"Quick Start \u00b6 It's a Quick Start Guide for starting using Multichain SDK. We will create ERC-721 Lazy Minting NFT and list it in the Ethereum network to start using Multichain SDK. To get more information, use the links in each section. Installation \u00b6 npm install -D @rarible/sdk npm install web3@1.5.0 npm install tslib@2.3.1 or using yarn yarn add @rarible/sdk -D yarn add web3 yarn add tslib@2.3.1 Check that the SDK is installed correctly: npm view @rarible/sdk version Using SDK \u00b6 Create a project with the JS framework of your choice (we'll be using NextJS here). To properly set up the Rarible SDK, we need to follow standard Web3 practices. Grab the Ethereum object out of the global window object. Use it to create a new instance of Web3. Create a new instance of EthereumWallet class. Create Rarible SDK with a new instance of ethereumWallet, created in the previous step. In code, it looks like that (using TypeScript): // Imports import Web3 from \"web3\" import { createRaribleSdk } from \"@rarible/sdk\" import { EthereumWallet } from \"@rarible/sdk-wallet\" import { Blockchain } from \"@rarible/api-client\" import { Web3Ethereum } from \"@rarible/web3-ethereum\" // Code const { ethereum } = window as any const web3 = new Web3 ( provider ) const web3Ethereum = new Web3Ethereum ({ web3 }) const ethWallet = new EthereumWallet ( web3Ethereum ) const raribleSdk = createRaribleSdk ( ethWallet , \"staging\" ) If using Ethers you should use @rarible/ethers-ethereum library for creating an EthereumWallet. Here is an example of creating all supported providers: // Imports import type Wallet from \"ethereumjs-wallet\" import Web3 from \"web3\" import { ethers } from \"ethers\" import { Web3Ethereum } from \"@rarible/web3-ethereum\" import { EthersEthereum , EthersWeb3ProviderEthereum } from \"@rarible/ethers-ethereum\" // Code export function createProviders ( provider : any , wallet : Wallet ) { const web3 = new Web3 ( provider ) const ethersWeb3Provider = new ethers . providers . Web3Provider ( provider ) return { web3 , providers : [ new Web3Ethereum ({ web3 }), new EthersEthereum ( new ethers . Wallet ( wallet . getPrivateKeyString (), ethersWeb3Provider )), new EthersWeb3ProviderEthereum ( ethersWeb3Provider ), ], } } const ethWallet = new EthereumWallet ( ethersEthereumProviderInstance ) const raribleSdk = createRaribleSdk ( ethWallet , \"staging\" ) In createRaribleSdk , we have several environment parameters: prod (mainnet) dev (ropsten) staging (rinkeby) The difference between them is the chain Id and the Rarible API endpoint. And if you're creating any blockchain application that will interact with users, you'll still need to implement the connect Metamask button to get their wallet connected. ERC-721 NFT Lazy Minting & Sell \u00b6 Often users want to list their NFTs on the sale right after creation. For this case, use mintAndSell function, which allows you to do exactly that. const currentWallet = wallet as EthereumWallet ; const makerAccount = await currentWallet . ethereum . getFrom (); // Price in ETH const price : number = 1 ; const mintRequest : PrepareMintRequest = { collectionId : toContractAddress ( \"ETHEREUM:CONTRACT_ADDRESS\" ), }; const ethCurrency : EthErc20AssetType = { \"@type\" : \"ERC20\" , contract : toContractAddress ( \"ETHEREUM:CONTRACT_ADDRESS\" ), }; const mintResponse = await sdk . nft . mintAndSell ( mintRequest ); const response = await mintResponse . submit ({ uri , supply : 1 , lazyMint : true , price , creators : [ { account : toUnionAddress ( `ETHEREUM: ${ makerAccount } ` ), value : 10000 , }, ], currency : ethCurrency , }); // Response: // ItemId // OrderId See Reference overview page for more information about SDK usage.","title":"Quick Start"},{"location":"getting-started/quick-start/#quick-start","text":"It's a Quick Start Guide for starting using Multichain SDK. We will create ERC-721 Lazy Minting NFT and list it in the Ethereum network to start using Multichain SDK. To get more information, use the links in each section.","title":"Quick Start"},{"location":"getting-started/quick-start/#installation","text":"npm install -D @rarible/sdk npm install web3@1.5.0 npm install tslib@2.3.1 or using yarn yarn add @rarible/sdk -D yarn add web3 yarn add tslib@2.3.1 Check that the SDK is installed correctly: npm view @rarible/sdk version","title":"Installation"},{"location":"getting-started/quick-start/#using-sdk","text":"Create a project with the JS framework of your choice (we'll be using NextJS here). To properly set up the Rarible SDK, we need to follow standard Web3 practices. Grab the Ethereum object out of the global window object. Use it to create a new instance of Web3. Create a new instance of EthereumWallet class. Create Rarible SDK with a new instance of ethereumWallet, created in the previous step. In code, it looks like that (using TypeScript): // Imports import Web3 from \"web3\" import { createRaribleSdk } from \"@rarible/sdk\" import { EthereumWallet } from \"@rarible/sdk-wallet\" import { Blockchain } from \"@rarible/api-client\" import { Web3Ethereum } from \"@rarible/web3-ethereum\" // Code const { ethereum } = window as any const web3 = new Web3 ( provider ) const web3Ethereum = new Web3Ethereum ({ web3 }) const ethWallet = new EthereumWallet ( web3Ethereum ) const raribleSdk = createRaribleSdk ( ethWallet , \"staging\" ) If using Ethers you should use @rarible/ethers-ethereum library for creating an EthereumWallet. Here is an example of creating all supported providers: // Imports import type Wallet from \"ethereumjs-wallet\" import Web3 from \"web3\" import { ethers } from \"ethers\" import { Web3Ethereum } from \"@rarible/web3-ethereum\" import { EthersEthereum , EthersWeb3ProviderEthereum } from \"@rarible/ethers-ethereum\" // Code export function createProviders ( provider : any , wallet : Wallet ) { const web3 = new Web3 ( provider ) const ethersWeb3Provider = new ethers . providers . Web3Provider ( provider ) return { web3 , providers : [ new Web3Ethereum ({ web3 }), new EthersEthereum ( new ethers . Wallet ( wallet . getPrivateKeyString (), ethersWeb3Provider )), new EthersWeb3ProviderEthereum ( ethersWeb3Provider ), ], } } const ethWallet = new EthereumWallet ( ethersEthereumProviderInstance ) const raribleSdk = createRaribleSdk ( ethWallet , \"staging\" ) In createRaribleSdk , we have several environment parameters: prod (mainnet) dev (ropsten) staging (rinkeby) The difference between them is the chain Id and the Rarible API endpoint. And if you're creating any blockchain application that will interact with users, you'll still need to implement the connect Metamask button to get their wallet connected.","title":"Using SDK"},{"location":"getting-started/quick-start/#erc-721-nft-lazy-minting-sell","text":"Often users want to list their NFTs on the sale right after creation. For this case, use mintAndSell function, which allows you to do exactly that. const currentWallet = wallet as EthereumWallet ; const makerAccount = await currentWallet . ethereum . getFrom (); // Price in ETH const price : number = 1 ; const mintRequest : PrepareMintRequest = { collectionId : toContractAddress ( \"ETHEREUM:CONTRACT_ADDRESS\" ), }; const ethCurrency : EthErc20AssetType = { \"@type\" : \"ERC20\" , contract : toContractAddress ( \"ETHEREUM:CONTRACT_ADDRESS\" ), }; const mintResponse = await sdk . nft . mintAndSell ( mintRequest ); const response = await mintResponse . submit ({ uri , supply : 1 , lazyMint : true , price , creators : [ { account : toUnionAddress ( `ETHEREUM: ${ makerAccount } ` ), value : 10000 , }, ], currency : ethCurrency , }); // Response: // ItemId // OrderId See Reference overview page for more information about SDK usage.","title":"ERC-721 NFT Lazy Minting &amp; Sell"},{"location":"getting-started/royalties-on-a-external-collection/","text":"Setting Up Royalties on an External Collection \u00b6 Open the royalties contract in a new tab: https://etherscan.io/address/0xEa90CFad1b8e030B8Fd3E63D22074E0AEb8E0DCD#writeProxyContract Active Contract tab. Make sure Write as Proxy is selected near the top. Click Connect to Web3 . Expand the setRoyaltiesByToken function to set the royalties for the entire collection. You will now need to enter the collection address in the Token (Address) field followed by the tuple for royalties. An example of a tuple is below. The first part of the tuple must be the address where you'd like to receive the royalties. The second part is the percentage as Basis Points ie: 1000 = 10% Royalties. Below is an example of a tuple which gives the user ( 0x6C1AaC9EAd0a2c0D328309fbb2cf940F49d26126 ) 1% royalties on items in the collection. The maximum royalties value is 10000 (100%). [[\"0x6C1AaC9EAd0a2c0D328309fbb2cf940F49d26126\", 100]] In the screenshot below you can see that on the collection ( 0x4008c2482357632b06526b492c143f4e73ff1b0d ) the user ( 0x6C1AaC9EAd0a2c0D328309fbb2cf940F49d26126 ) receives 2.5% (250) Royalties. Click on Write button which will bring up your connected wallet and ask you to pay gas fees to execute a transaction. Now that Royalties have been set up, royalties will be paid out on every sale in that collection. Below is an example of a purchase transaction with annotations on what each fee is for:","title":"Setting Up Royalties on an External Collection"},{"location":"getting-started/royalties-on-a-external-collection/#setting-up-royalties-on-an-external-collection","text":"Open the royalties contract in a new tab: https://etherscan.io/address/0xEa90CFad1b8e030B8Fd3E63D22074E0AEb8E0DCD#writeProxyContract Active Contract tab. Make sure Write as Proxy is selected near the top. Click Connect to Web3 . Expand the setRoyaltiesByToken function to set the royalties for the entire collection. You will now need to enter the collection address in the Token (Address) field followed by the tuple for royalties. An example of a tuple is below. The first part of the tuple must be the address where you'd like to receive the royalties. The second part is the percentage as Basis Points ie: 1000 = 10% Royalties. Below is an example of a tuple which gives the user ( 0x6C1AaC9EAd0a2c0D328309fbb2cf940F49d26126 ) 1% royalties on items in the collection. The maximum royalties value is 10000 (100%). [[\"0x6C1AaC9EAd0a2c0D328309fbb2cf940F49d26126\", 100]] In the screenshot below you can see that on the collection ( 0x4008c2482357632b06526b492c143f4e73ff1b0d ) the user ( 0x6C1AaC9EAd0a2c0D328309fbb2cf940F49d26126 ) receives 2.5% (250) Royalties. Click on Write button which will bring up your connected wallet and ask you to pay gas fees to execute a transaction. Now that Royalties have been set up, royalties will be paid out on every sale in that collection. Below is an example of a purchase transaction with annotations on what each fee is for:","title":"Setting Up Royalties on an External Collection"},{"location":"getting-started/sdk-react-example/","text":"Example application for connecting blockchain wallet \u00b6 This example will help you get started with the Rarible SDK. You will know how to: Connect and configure connection providers and wallet connectors in the Rarible SDK. Connect the available wallets via the web application. Example Application is written using React. Also, you can try our prepared Example APP with advanced functionality. Create React App \u00b6 In the beginning, you will need to have Node.js and Yarn on your machine to create a new single-page application in React. Also, we will be use Typescript template. To create a project, run: yarn create react-app my-app --template typescript Go to the project folder: cd my-app Install dependencies \u00b6 Our Example App will use some dependencies. To install them, run: yarn add @rarible/connector @rarible/connector-helper @rarible/connector-beacon @rarible/connector-fcl \\ @rarible/connector-fortmatic @rarible/connector-iframe @rarible/connector-mew \\ @rarible/connector-phantom @rarible/connector-portis @rarible/connector-solflare \\ @rarible/connector-torus @rarible/connector-walletconnect \\ @rarible/connector-walletlink @rarible/sdk @rarible/types Connectors setup \u00b6 Create the src/connector folder and connectors-setup.ts file there. It lists all the wallets that our application can connect to. connectors-setup.ts import { NetworkType as TezosNetwork } from \"@airgap/beacon-sdk\" import { RaribleSdkEnvironment } from \"@rarible/sdk/build/config/domain\" import { ConnectionProvider , Connector , IConnectorStateProvider , InjectedWeb3ConnectionProvider , } from \"@rarible/connector\" import { FclConnectionProvider } from \"@rarible/connector-fcl\" import { MEWConnectionProvider } from \"@rarible/connector-mew\" import { BeaconConnectionProvider } from \"@rarible/connector-beacon\" import { TorusConnectionProvider } from \"@rarible/connector-torus\" import { WalletLinkConnectionProvider } from \"@rarible/connector-walletlink\" import { WalletConnectConnectionProvider } from \"@rarible/connector-walletconnect\" import { PhantomConnectionProvider } from \"@rarible/connector-phantom\" import { SolflareConnectionProvider } from \"@rarible/connector-solflare\" import type { IWalletAndAddress } from \"@rarible/connector-helper\" import { mapEthereumWallet , mapFlowWallet , mapSolanaWallet , mapTezosWallet } from \"@rarible/connector-helper\" // import { FortmaticConnectionProvider } from \"@rarible/connector-fortmatic\" // import { PortisConnectionProvider } from \"@rarible/connector-portis\" const ethereumRpcMap : Record < number , string > = { 1 : \"https://node-mainnet.rarible.com\" , 3 : \"https://node-ropsten.rarible.com\" , 4 : \"https://node-rinkeby.rarible.com\" , 17 : \"https://node-e2e.rarible.com\" , 137 : \"https://polygon-rpc.com\" , 80001 : \"https://rpc-mumbai.matic.today\" } const ethereumNetworkMap : Record < number , string > = { 1 : \"mainnet\" , 3 : \"ropsten\" , 4 : \"rinkeby\" , 17 : \"e2e\" , 137 : \"polygon\" , 80001 : \"mumbai\" } function environmentToEthereumChainId ( environment : RaribleSdkEnvironment ) { switch ( environment ) { case \"prod\" : return 1 case \"dev\" : return 3 case \"e2e\" : return 17 case \"staging\" : default : return 4 } } function environmentToFlowNetwork ( environment : RaribleSdkEnvironment ) { switch ( environment ) { case \"prod\" : return { network : \"mainnet\" , accessNode : \"https://access.onflow.org\" , walletDiscovery : \"https://flow-wallet.blocto.app/authn\" , } case \"dev\" : case \"e2e\" : case \"staging\" : default : return { network : \"testnet\" , accessNode : \"https://access-testnet.onflow.org\" , walletDiscovery : \"https://flow-wallet-testnet.blocto.app/authn\" , } } } function environmentToTezosNetwork ( environment : RaribleSdkEnvironment ) { switch ( environment ) { case \"prod\" : return { accessNode : \"https://tezos-node.rarible.org\" , network : TezosNetwork.MAINNET } case \"dev\" : case \"e2e\" : case \"staging\" : default : return { accessNode : \"https://test-tezos-node.rarible.org\" , network : TezosNetwork.ITHACANET } } } const state : IConnectorStateProvider = { async getValue () : Promise < string | undefined > { const value = localStorage . getItem ( \"saved_provider\" ) return value ? value : undefined }, async setValue ( value : string | undefined ) : Promise < void > { localStorage . setItem ( \"saved_provider\" , value || \"\" ) }, } export function getConnector ( environment : RaribleSdkEnvironment ) : Connector < string , IWalletAndAddress > { const ethChainId = environmentToEthereumChainId ( environment ) const ethNetworkName = ethereumNetworkMap [ ethChainId ] const isEthNetwork = [ \"mainnet\" , \"ropsten\" , \"rinkeby\" ]. includes ( ethNetworkName ) const flowNetwork = environmentToFlowNetwork ( environment ) const tezosNetwork = environmentToTezosNetwork ( environment ) const injected = mapEthereumWallet ( new InjectedWeb3ConnectionProvider ()) const mew = mapEthereumWallet ( new MEWConnectionProvider ({ networkId : ethChainId , rpcUrl : ethereumRpcMap [ ethChainId ] })) const beacon : ConnectionProvider < \"beacon\" , IWalletAndAddress > = mapTezosWallet ( new BeaconConnectionProvider ({ appName : \"Rarible Test\" , accessNode : tezosNetwork.accessNode , network : tezosNetwork.network })) const fcl = mapFlowWallet ( new FclConnectionProvider ({ accessNode : flowNetwork.accessNode , walletDiscovery : flowNetwork.walletDiscovery , network : flowNetwork.network , applicationTitle : \"Rari Test\" , applicationIcon : \"https://rarible.com/favicon.png?2d8af2455958e7f0c812\" })) let torus = undefined if ( isEthNetwork ) { torus = mapEthereumWallet ( new TorusConnectionProvider ({ network : { host : ethNetworkName } })) } const walletLink = mapEthereumWallet ( new WalletLinkConnectionProvider ({ networkId : ethChainId , estimationUrl : ethereumRpcMap [ ethChainId ], url : ethereumRpcMap [ ethChainId ] }, { appName : \"Rarible\" , appLogoUrl : \"https://rarible.com/static/logo-500.static.png\" , darkMode : false , })) const walletConnect = mapEthereumWallet ( new WalletConnectConnectionProvider ({ rpc : ethereumRpcMap , chainId : ethChainId , })) const phantomConnect = mapSolanaWallet ( new PhantomConnectionProvider ()) const solflareConnect = mapSolanaWallet ( new SolflareConnectionProvider ({ network : environment === \"prod\" ? \"mainnet-beta\" : \"devnet\" })) // Providers required secrets // const fortmatic = mapEthereumWallet(new FortmaticConnectionProvider({ apiKey: \"ENTER\", ethNetwork: { chainId: 4, rpcUrl: \"https://node-rinkeby.rarible.com\" } })) // const portis = mapEthereumWallet(new PortisConnectionProvider({ appId: \"ENTER\", network: \"rinkeby\" })) const connector = Connector . create ( injected , state ) . add ( walletLink ) . add ( mew ) . add ( beacon ) . add ( fcl ) . add ( walletConnect ) . add ( phantomConnect ) . add ( solflareConnect ) // .add(portis) // .add(fortmatic) if ( torus ) { return connector . add ( torus ) } return connector } Connection provider \u00b6 Create the sdk-connection-provider.tsx file in src/connector folder. Connection provider needed for handling blockchain wallet connection and pass connection and SDK objects to React context for using them in any app components. sdk-connection-provider.tsx import React , { useEffect , useState } from \"react\" import { createRaribleSdk } from \"@rarible/sdk\" import type { ConnectionState } from \"@rarible/connector\" import { getStateDisconnected , IConnector } from \"@rarible/connector\" import { IRaribleSdk } from \"@rarible/sdk/build/domain\" import type { IWalletAndAddress } from \"@rarible/connector-helper\" import { RaribleSdkEnvironment } from \"@rarible/sdk/build/config/domain\" import { getConnector } from \"./connectors-setup\" export interface IConnectorContext { connector? : IConnector < string , IWalletAndAddress > state : ConnectionState < IWalletAndAddress > sdk? : IRaribleSdk walletAddress? : string } export const ConnectorContext = React . createContext < IConnectorContext > ({ connector : undefined , state : getStateDisconnected (), sdk : undefined , walletAddress : undefined }) const environment : RaribleSdkEnvironment = \"development\" export function SdkConnectionProvider ({ children } : { children : React.ReactNode }) { const [ context , setContext ] = useState < IConnectorContext > () const [ sdk , setSdk ] = useState < IRaribleSdk > () const connector = getConnector ( environment ) useEffect (() => { const subscription = connector . connection . subscribe ( s => { const sdkInstance = s . status === \"connected\" ? createRaribleSdk ( s . connection . wallet , environment ) : undefined setSdk ( sdkInstance ) const computedContext : IConnectorContext = { connector , state : s , sdk , walletAddress : s.status === \"connected\" ? s . connection . blockchain + \":\" + s.connection.address : undefined , } setContext ( computedContext ) }) return () => subscription . unsubscribe () //eslint-disable-next-line react-hooks/exhaustive-deps }, []) return < ConnectorContext . Provider value = { context ! } > { children } < /ConnectorContext.Provider> } Usage in APP \u00b6 Create the src/pages folder and main.tsx file there. This will be the main page of our application. main.tsx import React , { useContext , useEffect , useState } from \"react\" import { ConnectorContext } from \"../connector/sdk-connection-provider\" import { ProviderOption } from \"@rarible/connector\" import type { IWalletAndAddress } from \"@rarible/connector-helper\" import { toOrderId } from \"@rarible/types\" export function MainPage () { const [ options , setOptions ] = useState < ProviderOption < string , IWalletAndAddress > [] > ([]) const connection = useContext ( ConnectorContext ) useEffect (() => { connection ? . connector ? . getOptions (). then ( o => { setOptions ( o ) }) }, [ connection ]) const connect = async ( option : ProviderOption < string , IWalletAndAddress > ) => { await connection . connector ? . connect ( option ) } const disconnect = async () => { if ( connection ? . state . status === \"connected\" && connection ? . state ? . disconnect ) { await connection ? . state ? . disconnect () } } const someSdkAction = async () => { const prepare = await connection ? . sdk ? . order . buy ({ orderId : toOrderId ( \"orderid\" )}) await prepare ? . submit ({ amount : 1 }) } return < div > Connection status : { connection ? . state ? . status } < div > < button disabled = { connection ? . state ? . status !== \"connected\" } onClick = { disconnect } > Disconnect < /button> < /div> { options . map (( option , i ) => { return < div key = { option . option } > < button onClick = {() => connect ( option )} disabled = { connection ? . state ? . status !== \"disconnected\" } > Connect { option . option } < /button> < /div> })} < /div> } Now replace the contents of the App.tsx file with the following: App.tsx import './App.css' ; import { SdkConnectionProvider } from \"./connector/sdk-connection-provider\" ; import { MainPage } from \"./pages/main\" function App () { return ( < SdkConnectionProvider > < MainPage /> < /SdkConnectionProvider> ); } export default App ; Check the project structure. It will be looks like this: To start application, run in project folder: yarn start If everything is configured correctly, the app will open at the http://localhost:3000/ address: Now you can connect to any of the available wallets. For example, this is how the connection to MetaMask looks like. That's it, now you have a working sample application on React! Try also our prepared Example APP with advanced functionality. Polyfill modules in Webpack 5 \u00b6 If you are using webpack version 5 you may encounter errors with polyfill node core modules. Use the following steps to fix these errors: Install react-app-rewired and missing dependencies yarn add react-app-rewired crypto-browserify stream-browserify assert stream-http https-browserify \\ os-browserify url buffer process path-browserify Override the create-react-app webpack config file config-overrides.js /* config-overrides.js */ const webpack = require ( 'webpack' ); module . exports = function override ( config , env ) { config . resolve . fallback = { url : require . resolve ( 'url' ), assert : require . resolve ( 'assert' ), crypto : require . resolve ( 'crypto-browserify' ), http : require . resolve ( 'stream-http' ), https : require . resolve ( 'https-browserify' ), os : require . resolve ( 'os-browserify/browser' ), buffer : require . resolve ( 'buffer' ), stream : require . resolve ( 'stream-browserify' ), path : require . resolve ( \"path-browserify\" ) }; config . plugins . push ( new webpack . ProvidePlugin ({ process : 'process/browser' , Buffer : [ 'buffer' , 'Buffer' ], }), ); return config ; } Override package.json Replace react-scripts with react-app-rewired scripts for the three following scripts fields to update the webpack configuration in package.json file. It will be looks like this: \"scripts\" : { \"start\" : \"react-app-rewired start\" , \"build\" : \"react-app-rewired build\" , \"test\" : \"react-app-rewired test\" , \"eject\" : \"react-scripts eject\" }, To start application, run in project folder: yarn start See more information about fixing polyfill node core modules here .","title":"Example application for connecting blockchain wallet"},{"location":"getting-started/sdk-react-example/#example-application-for-connecting-blockchain-wallet","text":"This example will help you get started with the Rarible SDK. You will know how to: Connect and configure connection providers and wallet connectors in the Rarible SDK. Connect the available wallets via the web application. Example Application is written using React. Also, you can try our prepared Example APP with advanced functionality.","title":"Example application for connecting blockchain wallet"},{"location":"getting-started/sdk-react-example/#create-react-app","text":"In the beginning, you will need to have Node.js and Yarn on your machine to create a new single-page application in React. Also, we will be use Typescript template. To create a project, run: yarn create react-app my-app --template typescript Go to the project folder: cd my-app","title":"Create React App"},{"location":"getting-started/sdk-react-example/#install-dependencies","text":"Our Example App will use some dependencies. To install them, run: yarn add @rarible/connector @rarible/connector-helper @rarible/connector-beacon @rarible/connector-fcl \\ @rarible/connector-fortmatic @rarible/connector-iframe @rarible/connector-mew \\ @rarible/connector-phantom @rarible/connector-portis @rarible/connector-solflare \\ @rarible/connector-torus @rarible/connector-walletconnect \\ @rarible/connector-walletlink @rarible/sdk @rarible/types","title":"Install dependencies"},{"location":"getting-started/sdk-react-example/#connectors-setup","text":"Create the src/connector folder and connectors-setup.ts file there. It lists all the wallets that our application can connect to. connectors-setup.ts import { NetworkType as TezosNetwork } from \"@airgap/beacon-sdk\" import { RaribleSdkEnvironment } from \"@rarible/sdk/build/config/domain\" import { ConnectionProvider , Connector , IConnectorStateProvider , InjectedWeb3ConnectionProvider , } from \"@rarible/connector\" import { FclConnectionProvider } from \"@rarible/connector-fcl\" import { MEWConnectionProvider } from \"@rarible/connector-mew\" import { BeaconConnectionProvider } from \"@rarible/connector-beacon\" import { TorusConnectionProvider } from \"@rarible/connector-torus\" import { WalletLinkConnectionProvider } from \"@rarible/connector-walletlink\" import { WalletConnectConnectionProvider } from \"@rarible/connector-walletconnect\" import { PhantomConnectionProvider } from \"@rarible/connector-phantom\" import { SolflareConnectionProvider } from \"@rarible/connector-solflare\" import type { IWalletAndAddress } from \"@rarible/connector-helper\" import { mapEthereumWallet , mapFlowWallet , mapSolanaWallet , mapTezosWallet } from \"@rarible/connector-helper\" // import { FortmaticConnectionProvider } from \"@rarible/connector-fortmatic\" // import { PortisConnectionProvider } from \"@rarible/connector-portis\" const ethereumRpcMap : Record < number , string > = { 1 : \"https://node-mainnet.rarible.com\" , 3 : \"https://node-ropsten.rarible.com\" , 4 : \"https://node-rinkeby.rarible.com\" , 17 : \"https://node-e2e.rarible.com\" , 137 : \"https://polygon-rpc.com\" , 80001 : \"https://rpc-mumbai.matic.today\" } const ethereumNetworkMap : Record < number , string > = { 1 : \"mainnet\" , 3 : \"ropsten\" , 4 : \"rinkeby\" , 17 : \"e2e\" , 137 : \"polygon\" , 80001 : \"mumbai\" } function environmentToEthereumChainId ( environment : RaribleSdkEnvironment ) { switch ( environment ) { case \"prod\" : return 1 case \"dev\" : return 3 case \"e2e\" : return 17 case \"staging\" : default : return 4 } } function environmentToFlowNetwork ( environment : RaribleSdkEnvironment ) { switch ( environment ) { case \"prod\" : return { network : \"mainnet\" , accessNode : \"https://access.onflow.org\" , walletDiscovery : \"https://flow-wallet.blocto.app/authn\" , } case \"dev\" : case \"e2e\" : case \"staging\" : default : return { network : \"testnet\" , accessNode : \"https://access-testnet.onflow.org\" , walletDiscovery : \"https://flow-wallet-testnet.blocto.app/authn\" , } } } function environmentToTezosNetwork ( environment : RaribleSdkEnvironment ) { switch ( environment ) { case \"prod\" : return { accessNode : \"https://tezos-node.rarible.org\" , network : TezosNetwork.MAINNET } case \"dev\" : case \"e2e\" : case \"staging\" : default : return { accessNode : \"https://test-tezos-node.rarible.org\" , network : TezosNetwork.ITHACANET } } } const state : IConnectorStateProvider = { async getValue () : Promise < string | undefined > { const value = localStorage . getItem ( \"saved_provider\" ) return value ? value : undefined }, async setValue ( value : string | undefined ) : Promise < void > { localStorage . setItem ( \"saved_provider\" , value || \"\" ) }, } export function getConnector ( environment : RaribleSdkEnvironment ) : Connector < string , IWalletAndAddress > { const ethChainId = environmentToEthereumChainId ( environment ) const ethNetworkName = ethereumNetworkMap [ ethChainId ] const isEthNetwork = [ \"mainnet\" , \"ropsten\" , \"rinkeby\" ]. includes ( ethNetworkName ) const flowNetwork = environmentToFlowNetwork ( environment ) const tezosNetwork = environmentToTezosNetwork ( environment ) const injected = mapEthereumWallet ( new InjectedWeb3ConnectionProvider ()) const mew = mapEthereumWallet ( new MEWConnectionProvider ({ networkId : ethChainId , rpcUrl : ethereumRpcMap [ ethChainId ] })) const beacon : ConnectionProvider < \"beacon\" , IWalletAndAddress > = mapTezosWallet ( new BeaconConnectionProvider ({ appName : \"Rarible Test\" , accessNode : tezosNetwork.accessNode , network : tezosNetwork.network })) const fcl = mapFlowWallet ( new FclConnectionProvider ({ accessNode : flowNetwork.accessNode , walletDiscovery : flowNetwork.walletDiscovery , network : flowNetwork.network , applicationTitle : \"Rari Test\" , applicationIcon : \"https://rarible.com/favicon.png?2d8af2455958e7f0c812\" })) let torus = undefined if ( isEthNetwork ) { torus = mapEthereumWallet ( new TorusConnectionProvider ({ network : { host : ethNetworkName } })) } const walletLink = mapEthereumWallet ( new WalletLinkConnectionProvider ({ networkId : ethChainId , estimationUrl : ethereumRpcMap [ ethChainId ], url : ethereumRpcMap [ ethChainId ] }, { appName : \"Rarible\" , appLogoUrl : \"https://rarible.com/static/logo-500.static.png\" , darkMode : false , })) const walletConnect = mapEthereumWallet ( new WalletConnectConnectionProvider ({ rpc : ethereumRpcMap , chainId : ethChainId , })) const phantomConnect = mapSolanaWallet ( new PhantomConnectionProvider ()) const solflareConnect = mapSolanaWallet ( new SolflareConnectionProvider ({ network : environment === \"prod\" ? \"mainnet-beta\" : \"devnet\" })) // Providers required secrets // const fortmatic = mapEthereumWallet(new FortmaticConnectionProvider({ apiKey: \"ENTER\", ethNetwork: { chainId: 4, rpcUrl: \"https://node-rinkeby.rarible.com\" } })) // const portis = mapEthereumWallet(new PortisConnectionProvider({ appId: \"ENTER\", network: \"rinkeby\" })) const connector = Connector . create ( injected , state ) . add ( walletLink ) . add ( mew ) . add ( beacon ) . add ( fcl ) . add ( walletConnect ) . add ( phantomConnect ) . add ( solflareConnect ) // .add(portis) // .add(fortmatic) if ( torus ) { return connector . add ( torus ) } return connector }","title":"Connectors setup"},{"location":"getting-started/sdk-react-example/#connection-provider","text":"Create the sdk-connection-provider.tsx file in src/connector folder. Connection provider needed for handling blockchain wallet connection and pass connection and SDK objects to React context for using them in any app components. sdk-connection-provider.tsx import React , { useEffect , useState } from \"react\" import { createRaribleSdk } from \"@rarible/sdk\" import type { ConnectionState } from \"@rarible/connector\" import { getStateDisconnected , IConnector } from \"@rarible/connector\" import { IRaribleSdk } from \"@rarible/sdk/build/domain\" import type { IWalletAndAddress } from \"@rarible/connector-helper\" import { RaribleSdkEnvironment } from \"@rarible/sdk/build/config/domain\" import { getConnector } from \"./connectors-setup\" export interface IConnectorContext { connector? : IConnector < string , IWalletAndAddress > state : ConnectionState < IWalletAndAddress > sdk? : IRaribleSdk walletAddress? : string } export const ConnectorContext = React . createContext < IConnectorContext > ({ connector : undefined , state : getStateDisconnected (), sdk : undefined , walletAddress : undefined }) const environment : RaribleSdkEnvironment = \"development\" export function SdkConnectionProvider ({ children } : { children : React.ReactNode }) { const [ context , setContext ] = useState < IConnectorContext > () const [ sdk , setSdk ] = useState < IRaribleSdk > () const connector = getConnector ( environment ) useEffect (() => { const subscription = connector . connection . subscribe ( s => { const sdkInstance = s . status === \"connected\" ? createRaribleSdk ( s . connection . wallet , environment ) : undefined setSdk ( sdkInstance ) const computedContext : IConnectorContext = { connector , state : s , sdk , walletAddress : s.status === \"connected\" ? s . connection . blockchain + \":\" + s.connection.address : undefined , } setContext ( computedContext ) }) return () => subscription . unsubscribe () //eslint-disable-next-line react-hooks/exhaustive-deps }, []) return < ConnectorContext . Provider value = { context ! } > { children } < /ConnectorContext.Provider> }","title":"Connection provider"},{"location":"getting-started/sdk-react-example/#usage-in-app","text":"Create the src/pages folder and main.tsx file there. This will be the main page of our application. main.tsx import React , { useContext , useEffect , useState } from \"react\" import { ConnectorContext } from \"../connector/sdk-connection-provider\" import { ProviderOption } from \"@rarible/connector\" import type { IWalletAndAddress } from \"@rarible/connector-helper\" import { toOrderId } from \"@rarible/types\" export function MainPage () { const [ options , setOptions ] = useState < ProviderOption < string , IWalletAndAddress > [] > ([]) const connection = useContext ( ConnectorContext ) useEffect (() => { connection ? . connector ? . getOptions (). then ( o => { setOptions ( o ) }) }, [ connection ]) const connect = async ( option : ProviderOption < string , IWalletAndAddress > ) => { await connection . connector ? . connect ( option ) } const disconnect = async () => { if ( connection ? . state . status === \"connected\" && connection ? . state ? . disconnect ) { await connection ? . state ? . disconnect () } } const someSdkAction = async () => { const prepare = await connection ? . sdk ? . order . buy ({ orderId : toOrderId ( \"orderid\" )}) await prepare ? . submit ({ amount : 1 }) } return < div > Connection status : { connection ? . state ? . status } < div > < button disabled = { connection ? . state ? . status !== \"connected\" } onClick = { disconnect } > Disconnect < /button> < /div> { options . map (( option , i ) => { return < div key = { option . option } > < button onClick = {() => connect ( option )} disabled = { connection ? . state ? . status !== \"disconnected\" } > Connect { option . option } < /button> < /div> })} < /div> } Now replace the contents of the App.tsx file with the following: App.tsx import './App.css' ; import { SdkConnectionProvider } from \"./connector/sdk-connection-provider\" ; import { MainPage } from \"./pages/main\" function App () { return ( < SdkConnectionProvider > < MainPage /> < /SdkConnectionProvider> ); } export default App ; Check the project structure. It will be looks like this: To start application, run in project folder: yarn start If everything is configured correctly, the app will open at the http://localhost:3000/ address: Now you can connect to any of the available wallets. For example, this is how the connection to MetaMask looks like. That's it, now you have a working sample application on React! Try also our prepared Example APP with advanced functionality.","title":"Usage in APP"},{"location":"getting-started/sdk-react-example/#polyfill-modules-in-webpack-5","text":"If you are using webpack version 5 you may encounter errors with polyfill node core modules. Use the following steps to fix these errors: Install react-app-rewired and missing dependencies yarn add react-app-rewired crypto-browserify stream-browserify assert stream-http https-browserify \\ os-browserify url buffer process path-browserify Override the create-react-app webpack config file config-overrides.js /* config-overrides.js */ const webpack = require ( 'webpack' ); module . exports = function override ( config , env ) { config . resolve . fallback = { url : require . resolve ( 'url' ), assert : require . resolve ( 'assert' ), crypto : require . resolve ( 'crypto-browserify' ), http : require . resolve ( 'stream-http' ), https : require . resolve ( 'https-browserify' ), os : require . resolve ( 'os-browserify/browser' ), buffer : require . resolve ( 'buffer' ), stream : require . resolve ( 'stream-browserify' ), path : require . resolve ( \"path-browserify\" ) }; config . plugins . push ( new webpack . ProvidePlugin ({ process : 'process/browser' , Buffer : [ 'buffer' , 'Buffer' ], }), ); return config ; } Override package.json Replace react-scripts with react-app-rewired scripts for the three following scripts fields to update the webpack configuration in package.json file. It will be looks like this: \"scripts\" : { \"start\" : \"react-app-rewired start\" , \"build\" : \"react-app-rewired build\" , \"test\" : \"react-app-rewired test\" , \"eject\" : \"react-scripts eject\" }, To start application, run in project folder: yarn start See more information about fixing polyfill node core modules here .","title":"Polyfill modules in Webpack 5"},{"location":"getting-started/sellOrder_acceptBid/","text":"Create Sell Order and Accept Bid \u00b6 After reading this piece of content you should have a knowledge about creating sell orders and accepting bids using Rarible Protocol. Executing actions \u00b6 You can use SDK to create (mint), trade, transfer, burn NFTs. All actions are handled in the same manner: Invoke function from SDK (e.g.: mint ). Async function returns so-called PrepareResponse (it's different for different actions). PrepareResponse contains all needed information to show user a form (for example, response for sell contains all supported currency types). Collect input from the user (show form and let user enter the data). Pass this data to submit Action. You can find more information about Action abstraction in dedicated [repo readme]. Or you can use it as a regular async function and work with regular Promises. Multichain \u00b6 Create Sell Order \u00b6 To create a sell order for NFT the following parameters are required: Item ID \u2014 Id of an item passed in blockchain:address:id manner, e.g. FLOW:A.ebf4ae01d1284af8.RaribleNFT:2321 , Asset type - Asset which you want to receive for your NFT, e.g. FLOW_FT, ERC_20, Price - Amount of asset of your choice you want to receive, Contract Address - Address of a given asset format, e.g. for FLOW_FT, which stands for Flow Fungible Token (so just a flow token) you have to pass a contract of a flow token, which on testnet is as follows: A.7e60df042a9c0868.FlowToken . You can find all of the information about its contract addresses here: https://docs.onflow.org/core-contracts/flow-token/#gatsby-focus-wrapper Whenever you see the need for Multichain / Contract address, you can create it as follows: Blockchain Name Hex Address Example: BlockchainName:HexAddress = ETHEREUM:0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05 Get an id of the item you want to create a sell order for, e.g. by copying it from rarible URL when you're on your token, and create an orderRequest with that. The only difference between different blockchains is currency, i.e. asset which we want to receive in return for our NFT. It should look something like that: FLOW:A.ebf4ae01d1284af8.RaribleNFT:2321 , ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:47 TEZOS:KT1BMB8m1QKqbbDDZPXpmGVCaM1cGcpTQSrw:443 import { toContractAddress , toItemId } from \"@rarible/types\" ; ... const itemId = \"FLOW:A.ebf4ae01d1284af8.RaribleNFT:2321\" ; const orderRequest : PrepareOrderRequest = { itemId : toItemId ( itemId ); } Create a currency which you want to receive in return. Available ones: FlowAssetTypeNft, FlowAssetTypeFt, TezosXTZAssetType, etc. You can find all of them in node_modules/@rarible/api-client/build/models/AssetType.d.ts of you project. Additionally you're able to find all of the needed properties for them like tokenId, @type, or contract. const tezosAddress = \"TEZOS:KT18pVpRXKPY2c4U2yFEGSH3ZnhB2kL8kwXS\" ; const flowAddress = \"FLOW:A.7e60df042a9c0868.FlowToken\" ; // ETH const currency : EthEthereumAssetType = { \"@type\" : \"ERC20\" , contract : } // TEZOS const currency : TezosFTAssetType = { \"@type\" : \"TEZOS_FT\" ; contract : toContractAddress ( tezosAddress ); tokenId? : 2321 ; } // FLOW const currency : FlowAssetTypeFt = { \"@type\" : \"FLOW_FT\" , contract : toContractAddress ( flowAddress ); }; Get sell response using orderRequest from earlier const sellResponse = await sdk . order . sell ( orderRequest ); // From sellResponse object you can get informations like: // is multiple sell order allowed // baseFee // maxAmount // originFeeSupport Example of response { \"multiple\" : false , \"supportedCurrencies\" : [ { \"blockchain\" : \"FLOW\" , \"type\" : \"NATIVE\" } ], \"baseFee\" : 250 , \"originFeeSupport\" : \"FULL\" , \"payoutsSupport\" : \"NONE\" , \"maxAmount\" : \"1\" } Execute submit method on sellResponse object const sellOrderCreated = await sellResponse . submit ({ price : 1 , amount : 1 , currency : currency , }); Example of response FLOW:33966044 Voila Accept Bid \u00b6 Accepting a bid codeflow is similar to the one in creating sell order. Codeflow is identical for all of the blockchains. Create fillRequest with an orderId which you want to accept const orderId = \"FLOW:32732635\" ; const fillRequest : PrepareFillRequest = { orderId : toOrderId ( orderId ), }; Get fillResponse using fillRequest const fillResponse = await sdk . order . acceptBid ( fillRequest ); Example of response { \"multiple\" : false , \"maxAmount\" : \"1\" , \"baseFee\" : 250 , \"supportsPartialFill\" : false , \"originFeeSupport\" : \"FULL\" , \"payoutsSupport\" : \"NONE\" } Submit received response const fillSubmitResponse = await fillResponse . submit ({ amount : 1 , });","title":"Create Sell Order and Accept Bid in Rarible Protocol"},{"location":"getting-started/sellOrder_acceptBid/#create-sell-order-and-accept-bid","text":"After reading this piece of content you should have a knowledge about creating sell orders and accepting bids using Rarible Protocol.","title":"Create Sell Order and Accept Bid"},{"location":"getting-started/sellOrder_acceptBid/#executing-actions","text":"You can use SDK to create (mint), trade, transfer, burn NFTs. All actions are handled in the same manner: Invoke function from SDK (e.g.: mint ). Async function returns so-called PrepareResponse (it's different for different actions). PrepareResponse contains all needed information to show user a form (for example, response for sell contains all supported currency types). Collect input from the user (show form and let user enter the data). Pass this data to submit Action. You can find more information about Action abstraction in dedicated [repo readme]. Or you can use it as a regular async function and work with regular Promises.","title":"Executing actions"},{"location":"getting-started/sellOrder_acceptBid/#multichain","text":"","title":"Multichain"},{"location":"getting-started/sellOrder_acceptBid/#create-sell-order","text":"To create a sell order for NFT the following parameters are required: Item ID \u2014 Id of an item passed in blockchain:address:id manner, e.g. FLOW:A.ebf4ae01d1284af8.RaribleNFT:2321 , Asset type - Asset which you want to receive for your NFT, e.g. FLOW_FT, ERC_20, Price - Amount of asset of your choice you want to receive, Contract Address - Address of a given asset format, e.g. for FLOW_FT, which stands for Flow Fungible Token (so just a flow token) you have to pass a contract of a flow token, which on testnet is as follows: A.7e60df042a9c0868.FlowToken . You can find all of the information about its contract addresses here: https://docs.onflow.org/core-contracts/flow-token/#gatsby-focus-wrapper Whenever you see the need for Multichain / Contract address, you can create it as follows: Blockchain Name Hex Address Example: BlockchainName:HexAddress = ETHEREUM:0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05 Get an id of the item you want to create a sell order for, e.g. by copying it from rarible URL when you're on your token, and create an orderRequest with that. The only difference between different blockchains is currency, i.e. asset which we want to receive in return for our NFT. It should look something like that: FLOW:A.ebf4ae01d1284af8.RaribleNFT:2321 , ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:47 TEZOS:KT1BMB8m1QKqbbDDZPXpmGVCaM1cGcpTQSrw:443 import { toContractAddress , toItemId } from \"@rarible/types\" ; ... const itemId = \"FLOW:A.ebf4ae01d1284af8.RaribleNFT:2321\" ; const orderRequest : PrepareOrderRequest = { itemId : toItemId ( itemId ); } Create a currency which you want to receive in return. Available ones: FlowAssetTypeNft, FlowAssetTypeFt, TezosXTZAssetType, etc. You can find all of them in node_modules/@rarible/api-client/build/models/AssetType.d.ts of you project. Additionally you're able to find all of the needed properties for them like tokenId, @type, or contract. const tezosAddress = \"TEZOS:KT18pVpRXKPY2c4U2yFEGSH3ZnhB2kL8kwXS\" ; const flowAddress = \"FLOW:A.7e60df042a9c0868.FlowToken\" ; // ETH const currency : EthEthereumAssetType = { \"@type\" : \"ERC20\" , contract : } // TEZOS const currency : TezosFTAssetType = { \"@type\" : \"TEZOS_FT\" ; contract : toContractAddress ( tezosAddress ); tokenId? : 2321 ; } // FLOW const currency : FlowAssetTypeFt = { \"@type\" : \"FLOW_FT\" , contract : toContractAddress ( flowAddress ); }; Get sell response using orderRequest from earlier const sellResponse = await sdk . order . sell ( orderRequest ); // From sellResponse object you can get informations like: // is multiple sell order allowed // baseFee // maxAmount // originFeeSupport Example of response { \"multiple\" : false , \"supportedCurrencies\" : [ { \"blockchain\" : \"FLOW\" , \"type\" : \"NATIVE\" } ], \"baseFee\" : 250 , \"originFeeSupport\" : \"FULL\" , \"payoutsSupport\" : \"NONE\" , \"maxAmount\" : \"1\" } Execute submit method on sellResponse object const sellOrderCreated = await sellResponse . submit ({ price : 1 , amount : 1 , currency : currency , }); Example of response FLOW:33966044 Voila","title":"Create Sell Order"},{"location":"getting-started/sellOrder_acceptBid/#accept-bid","text":"Accepting a bid codeflow is similar to the one in creating sell order. Codeflow is identical for all of the blockchains. Create fillRequest with an orderId which you want to accept const orderId = \"FLOW:32732635\" ; const fillRequest : PrepareFillRequest = { orderId : toOrderId ( orderId ), }; Get fillResponse using fillRequest const fillResponse = await sdk . order . acceptBid ( fillRequest ); Example of response { \"multiple\" : false , \"maxAmount\" : \"1\" , \"baseFee\" : 250 , \"supportsPartialFill\" : false , \"originFeeSupport\" : \"FULL\" , \"payoutsSupport\" : \"NONE\" } Submit received response const fillSubmitResponse = await fillResponse . submit ({ amount : 1 , });","title":"Accept Bid"},{"location":"getting-started/solana-nft-app/","text":"Create your NFT app on Solana in 10 minutes \u00b6 What is Solana? \u00b6 While ETH was reaching new heights in terms of traffic, price, and dApps development, new blockchains have arisen to tackle some of Ethereum\u2019s main problems. One of them is Solana, currently the 6th largest blockchain in terms of market valuation. Ethereum\u2019s main problems are, of course, transaction speed and enormous transaction fees. Solana did manage to solve these perfectly, allowing up to 65,000 transactions per second and reducing transaction costs to $0.00025 per transaction. Going further, Solana has its own programming language that lets us create dApps, NFTs, and more. Overall, it\u2019s a pretty solid competitor to Ethereum. \ud83c\udfc5 Why is Solana worth trying? \u00b6 As with every blockchain, there are a few things that make Solana unique. Let\u2019s look at some of Solana\u2019s technical features, which are also called the 8 innovations of Solana . Proof-of-History In order to make communication cost and latency more efficient in conjunction with Proof-of-Stake, Solana integrates the concept known as a Proof-of-History. It\u2019s a clock before consensus is reached, i.e. before agreeing on a blockchain state. It uses a recursive verifiable delay function to hash incoming events and transactions. It massively reduces overhead, thereby allowing scalability. Sealevel \u201cA hyper parallelized transaction processing engine designed to scale horizontally across GPUs and SSD\u201d. All other blockchains are single-threaded. Solana changed this status quo and became the first blockchain that is able to support parallel transaction execution in a single shard. It means that the blockchain will only become faster with time, allowing, once again, massive scalability. Gulf Stream Solana found a way to manage a mempool size of 100,000. Other blockchains use \u201cgossip protocols\u201d to propagate their mempools, and since gossip protocol, as its name states, achieves its purpose by exchanging information between nodes, it gets overwhelmed. Gulf Stream pushes transactions caching and forwarding to the edge of the network. This makes it possible for validators to execute transactions ahead of time. 60,000 Transactions Per Second (TPS) Currently, Visa / Mastercard can process up to 65,000 TPS, which sets the bar for the cryptocurrencies pretty high (if they ever wish to replace it). In comparison, Bitcoin can process up to 7 TPS, which is super low. Solana, on the other hand, due to the technical solutions listed above can process up to 60,000 TPS! If you\u2019re curious and want a deeper explanation, you can find the perfect one here , written by Anatoly Yakovenko, a Co-Founder of Solana. Solana Faucet, aka \u201cGive me free funds!\u201d \u00b6 Moving forward into the development phase. \ud83d\udc68\u200d\ud83d\udcbb As always, the first step when creating NFTs on any blockchain is to acquire the funds needed for transaction fees. Usually, we use a faucet service in order to get test funds. Solana is no different! After typing \u201cSolana Faucet\u201d on Google, we can see the following page : Compared to Tezos, getting test funds on Solana is very simple. But first things first. Solana Wallet In order to sign and execute transactions, we need some sort of wallet. Unfortunately, since Solana is not compatible with Ethereum, we can\u2019t use Metamask, as it supports only Ethereum-based currencies. That\u2019s not a problem, though! Solana has a similar app named Phantom , which is a web browser extension as well as a mobile app wallet, so it\u2019s super convenient to use. It looks like this: If you want to change the network, you have to go to the settings page at the bottom and change the network to the desired one, which in our case is devnet. Important: in order to create NFTs, you have to be on devnet , and NOT on testnet; otherwise it won\u2019t work, since Rarible SDK doesn\u2019t support testnet. After that, click on \u201cDeposit\u201d, copy your wallet address, and paste it into the Solana Faucet. After approximately 0.002 seconds, we should have our test funds available. Ahh, the beauty of Solana. \u2600\ufe0f Creating NFTs on Solana blockchain using Rarible SDK \u00b6 In order to create NFTs on Solana, we will use the exemplary app provided by Rarible. You can get it here: Rarible Protocol SDK The exemplary app is located on the packages/example in the repo below: Rarible SDK React Example In order to kickstart the project, you have to follow instructions disclaimed on Readme, which basically limits to running: yarn && yarn bootstrap && yarn build-all command from the root folder (not the packages/example folder). Exemplary Application The coolest aspect of the exemplary application is that it showcases all the possibilities the SDK provides. It\u2019s also a fast way to validate what you can achieve with the Rarible SDK (which is a lot \ud83d\ude09). Connect Wallet In order to create NFTs, we have to connect a wallet first, which in Solana\u2019s case is either Phantom or Solflare. As I stated earlier, I\u2019m going with Phantom. What\u2019s important here is to set the environment for \u201cdevelopment\u201d , that will allow you to use your wallet. After connecting, you should see the current status as \u201cconnected\u201d. Deploying Collection In order to successfully deploy a collection, you have to pass a Metadata URI, which is a JSON with collection properties, usually stored on IPFS. It looks like this: { \"name\" : \"Konosuba Characters\" , \"symbol\" : \"KNSB\" , \"description\" : \"test collection\" , \"seller_fee_basis_points\" : 0 , \"image\" : \"https://upload.wikimedia.org/wikipedia/ru/2/23/KonoSuba_light_novel_volume_1_cover.jpg\" , \"properties\" :{ \"files\" :[ { \"type\" : \"image/png\" , \"uri\" : \"https://upload.wikimedia.org/wikipedia/ru/2/23/KonoSuba_light_novel_volume_1_cover.jpg\" } ], \"category\" : \"image\" , \"creators\" :[ { \"address\" : \"A4t9PGWWUwwRh\u2026\" , \"share\" : 100 } ] } } You can find an explanation about all the available options for Metadata URI here . All fields are mandatory \u2014 properties and image may be empty. Name , symbol , and description are used to describe your token, seller_fee_basis_points is a royalties percentage, i.e. the percent of each following sale that will go to the creator. Image and properties are used for additional assets, and creators tell how the royalties should be distributed When it comes to uploading documents to IPFS, you can do it as you want. If you\u2019re interested in doing it from the code level, check one of our previous article , but you can also use Pinata for that purpose. After getting your Metadata URI, which is a link to JSON stored on IPFS, and which looks like this: https://gateway.pinata.cloud/ipfs/QmbDt5hsCCTE45twSGz33WorHr5vtii96rGsZNL6UfkrvW Paste it to the adequate field. The Phantom window should pop up, as it\u2019s shown below. Notice the predicted amount of SOL that will be subtracted from your account as a transaction fee. If you see \u201ctransaction may fail to confirm\u201d, it means that either you don\u2019t have enough funds, or you\u2019re connected to the wrong chain. After a successful collection creation, you should see information about the created collection: The most important information here is the collection address. With that, you can always fetch any related information from the Rarible API (see an article about that ). After obtaining the collection id, we\u2019re able to create an NFT by going to the \u201cMint Token\u201d page. Minting a Token As you can see, there are two steps involved in that process. The first one is passing a collection ID, and the second one is sending a transaction. What\u2019s super cool about the exemplary app is that, on the right side of the screen, there are always code snippets included. You\u2019re able to examine how it actually happens at the code level! Below, you can see an example of token minting. After the collection ID correctness check, we\u2019re prompted to send a transaction. In order to do that, we have to pass a Metadata URI, which, again, is a JSON with properties that we\u2019ll store on IPFS. If you\u2019ve passed the correct information, you should see the following screen: This means that the NFT was successfully created \ud83c\udfdd. How to see an NFT\u2019s content After the NFT creation, we can check what it contains using the Rarible API with the getItemById endpoint. An exemplary API call looks like this: https://api-staging.rarible.org/v0.1/items/SOLANA:2oLE3AJiNGiB96ncXCMb8JsMLpX2uHfdcoMDFNEM7BVg As a response, we can see all the details of the NFT: { \"id\" : \"SOLANA:2oLE3AJiNGiB96ncXCMb8JsMLpX2uHfdcoMDFNEM7BVg\" , \"blockchain\" : \"SOLANA\" , \"collection\" : \"SOLANA:FqGt8QaZ85hVF7nHWUYyFRhJR186vie7yKuxjXX2pzQS\" , \"creators\" :[ { \"account\" : \"SOLANA:A4t9PGWWUwwRhpEh3B9AL8uphgwiNZPBmx2H5RwrXuD9\" , \"value\" : 10000 } ], \"lazySupply\" : \"0\" , \"pending\" :[ ], \"mintedAt\" : \"2022\u201305\u201309T16:17:56Z\" , \"lastUpdatedAt\" : \"2022\u201305\u201309T16:17:56Z\" , \"supply\" : \"1\" , \"meta\" :{ \"name\" : \"Konosuba Characters\" , \"description\" : \"test collection\" , \"attributes\" :[ ], \"content\" :[ { \"@type\" : \"IMAGE\" , \"url\" : \"https://upload.wikimedia.org/wikipedia/ru/2/23/KonoSuba_light_novel_volume_1_cover.jpg\" , \"representation\" : \"ORIGINAL\" , \"mimeType\" : \"image/jpeg\" , \"size\" : 69036 , \"width\" : 352 , \"height\" : 500 } ], \"restrictions\" :[ ] }, \"deleted\" : false , \"auctions\" :[ ], \"totalStock\" : \"0\" , \"sellers\" : 0 } And voila. Freshly minted NFT on Solana ready to trade, hold, or whatever you want to do with that. Summary \u00b6 In this article, we\u2019ve learned how you can take advantage of the Rarible SDK and API to create and see an NFT on Solana. The most important thing to remember while developing is to set your Phantom network to devnet, and the environment to \u201cdevelopment\u201d on Rarible SDK. If you remember that, everything else should flow as smooth as butter. \ud83e\uddc8","title":"Solana NFT App with Rarible Protocol"},{"location":"getting-started/solana-nft-app/#create-your-nft-app-on-solana-in-10-minutes","text":"","title":"Create your NFT app on Solana in 10 minutes"},{"location":"getting-started/solana-nft-app/#what-is-solana","text":"While ETH was reaching new heights in terms of traffic, price, and dApps development, new blockchains have arisen to tackle some of Ethereum\u2019s main problems. One of them is Solana, currently the 6th largest blockchain in terms of market valuation. Ethereum\u2019s main problems are, of course, transaction speed and enormous transaction fees. Solana did manage to solve these perfectly, allowing up to 65,000 transactions per second and reducing transaction costs to $0.00025 per transaction. Going further, Solana has its own programming language that lets us create dApps, NFTs, and more. Overall, it\u2019s a pretty solid competitor to Ethereum. \ud83c\udfc5","title":"What is Solana?"},{"location":"getting-started/solana-nft-app/#why-is-solana-worth-trying","text":"As with every blockchain, there are a few things that make Solana unique. Let\u2019s look at some of Solana\u2019s technical features, which are also called the 8 innovations of Solana . Proof-of-History In order to make communication cost and latency more efficient in conjunction with Proof-of-Stake, Solana integrates the concept known as a Proof-of-History. It\u2019s a clock before consensus is reached, i.e. before agreeing on a blockchain state. It uses a recursive verifiable delay function to hash incoming events and transactions. It massively reduces overhead, thereby allowing scalability. Sealevel \u201cA hyper parallelized transaction processing engine designed to scale horizontally across GPUs and SSD\u201d. All other blockchains are single-threaded. Solana changed this status quo and became the first blockchain that is able to support parallel transaction execution in a single shard. It means that the blockchain will only become faster with time, allowing, once again, massive scalability. Gulf Stream Solana found a way to manage a mempool size of 100,000. Other blockchains use \u201cgossip protocols\u201d to propagate their mempools, and since gossip protocol, as its name states, achieves its purpose by exchanging information between nodes, it gets overwhelmed. Gulf Stream pushes transactions caching and forwarding to the edge of the network. This makes it possible for validators to execute transactions ahead of time. 60,000 Transactions Per Second (TPS) Currently, Visa / Mastercard can process up to 65,000 TPS, which sets the bar for the cryptocurrencies pretty high (if they ever wish to replace it). In comparison, Bitcoin can process up to 7 TPS, which is super low. Solana, on the other hand, due to the technical solutions listed above can process up to 60,000 TPS! If you\u2019re curious and want a deeper explanation, you can find the perfect one here , written by Anatoly Yakovenko, a Co-Founder of Solana.","title":"Why is Solana worth trying?"},{"location":"getting-started/solana-nft-app/#solana-faucet-aka-give-me-free-funds","text":"Moving forward into the development phase. \ud83d\udc68\u200d\ud83d\udcbb As always, the first step when creating NFTs on any blockchain is to acquire the funds needed for transaction fees. Usually, we use a faucet service in order to get test funds. Solana is no different! After typing \u201cSolana Faucet\u201d on Google, we can see the following page : Compared to Tezos, getting test funds on Solana is very simple. But first things first. Solana Wallet In order to sign and execute transactions, we need some sort of wallet. Unfortunately, since Solana is not compatible with Ethereum, we can\u2019t use Metamask, as it supports only Ethereum-based currencies. That\u2019s not a problem, though! Solana has a similar app named Phantom , which is a web browser extension as well as a mobile app wallet, so it\u2019s super convenient to use. It looks like this: If you want to change the network, you have to go to the settings page at the bottom and change the network to the desired one, which in our case is devnet. Important: in order to create NFTs, you have to be on devnet , and NOT on testnet; otherwise it won\u2019t work, since Rarible SDK doesn\u2019t support testnet. After that, click on \u201cDeposit\u201d, copy your wallet address, and paste it into the Solana Faucet. After approximately 0.002 seconds, we should have our test funds available. Ahh, the beauty of Solana. \u2600\ufe0f","title":"Solana Faucet, aka \u201cGive me free funds!\u201d"},{"location":"getting-started/solana-nft-app/#creating-nfts-on-solana-blockchain-using-rarible-sdk","text":"In order to create NFTs on Solana, we will use the exemplary app provided by Rarible. You can get it here: Rarible Protocol SDK The exemplary app is located on the packages/example in the repo below: Rarible SDK React Example In order to kickstart the project, you have to follow instructions disclaimed on Readme, which basically limits to running: yarn && yarn bootstrap && yarn build-all command from the root folder (not the packages/example folder). Exemplary Application The coolest aspect of the exemplary application is that it showcases all the possibilities the SDK provides. It\u2019s also a fast way to validate what you can achieve with the Rarible SDK (which is a lot \ud83d\ude09). Connect Wallet In order to create NFTs, we have to connect a wallet first, which in Solana\u2019s case is either Phantom or Solflare. As I stated earlier, I\u2019m going with Phantom. What\u2019s important here is to set the environment for \u201cdevelopment\u201d , that will allow you to use your wallet. After connecting, you should see the current status as \u201cconnected\u201d. Deploying Collection In order to successfully deploy a collection, you have to pass a Metadata URI, which is a JSON with collection properties, usually stored on IPFS. It looks like this: { \"name\" : \"Konosuba Characters\" , \"symbol\" : \"KNSB\" , \"description\" : \"test collection\" , \"seller_fee_basis_points\" : 0 , \"image\" : \"https://upload.wikimedia.org/wikipedia/ru/2/23/KonoSuba_light_novel_volume_1_cover.jpg\" , \"properties\" :{ \"files\" :[ { \"type\" : \"image/png\" , \"uri\" : \"https://upload.wikimedia.org/wikipedia/ru/2/23/KonoSuba_light_novel_volume_1_cover.jpg\" } ], \"category\" : \"image\" , \"creators\" :[ { \"address\" : \"A4t9PGWWUwwRh\u2026\" , \"share\" : 100 } ] } } You can find an explanation about all the available options for Metadata URI here . All fields are mandatory \u2014 properties and image may be empty. Name , symbol , and description are used to describe your token, seller_fee_basis_points is a royalties percentage, i.e. the percent of each following sale that will go to the creator. Image and properties are used for additional assets, and creators tell how the royalties should be distributed When it comes to uploading documents to IPFS, you can do it as you want. If you\u2019re interested in doing it from the code level, check one of our previous article , but you can also use Pinata for that purpose. After getting your Metadata URI, which is a link to JSON stored on IPFS, and which looks like this: https://gateway.pinata.cloud/ipfs/QmbDt5hsCCTE45twSGz33WorHr5vtii96rGsZNL6UfkrvW Paste it to the adequate field. The Phantom window should pop up, as it\u2019s shown below. Notice the predicted amount of SOL that will be subtracted from your account as a transaction fee. If you see \u201ctransaction may fail to confirm\u201d, it means that either you don\u2019t have enough funds, or you\u2019re connected to the wrong chain. After a successful collection creation, you should see information about the created collection: The most important information here is the collection address. With that, you can always fetch any related information from the Rarible API (see an article about that ). After obtaining the collection id, we\u2019re able to create an NFT by going to the \u201cMint Token\u201d page. Minting a Token As you can see, there are two steps involved in that process. The first one is passing a collection ID, and the second one is sending a transaction. What\u2019s super cool about the exemplary app is that, on the right side of the screen, there are always code snippets included. You\u2019re able to examine how it actually happens at the code level! Below, you can see an example of token minting. After the collection ID correctness check, we\u2019re prompted to send a transaction. In order to do that, we have to pass a Metadata URI, which, again, is a JSON with properties that we\u2019ll store on IPFS. If you\u2019ve passed the correct information, you should see the following screen: This means that the NFT was successfully created \ud83c\udfdd. How to see an NFT\u2019s content After the NFT creation, we can check what it contains using the Rarible API with the getItemById endpoint. An exemplary API call looks like this: https://api-staging.rarible.org/v0.1/items/SOLANA:2oLE3AJiNGiB96ncXCMb8JsMLpX2uHfdcoMDFNEM7BVg As a response, we can see all the details of the NFT: { \"id\" : \"SOLANA:2oLE3AJiNGiB96ncXCMb8JsMLpX2uHfdcoMDFNEM7BVg\" , \"blockchain\" : \"SOLANA\" , \"collection\" : \"SOLANA:FqGt8QaZ85hVF7nHWUYyFRhJR186vie7yKuxjXX2pzQS\" , \"creators\" :[ { \"account\" : \"SOLANA:A4t9PGWWUwwRhpEh3B9AL8uphgwiNZPBmx2H5RwrXuD9\" , \"value\" : 10000 } ], \"lazySupply\" : \"0\" , \"pending\" :[ ], \"mintedAt\" : \"2022\u201305\u201309T16:17:56Z\" , \"lastUpdatedAt\" : \"2022\u201305\u201309T16:17:56Z\" , \"supply\" : \"1\" , \"meta\" :{ \"name\" : \"Konosuba Characters\" , \"description\" : \"test collection\" , \"attributes\" :[ ], \"content\" :[ { \"@type\" : \"IMAGE\" , \"url\" : \"https://upload.wikimedia.org/wikipedia/ru/2/23/KonoSuba_light_novel_volume_1_cover.jpg\" , \"representation\" : \"ORIGINAL\" , \"mimeType\" : \"image/jpeg\" , \"size\" : 69036 , \"width\" : 352 , \"height\" : 500 } ], \"restrictions\" :[ ] }, \"deleted\" : false , \"auctions\" :[ ], \"totalStock\" : \"0\" , \"sellers\" : 0 } And voila. Freshly minted NFT on Solana ready to trade, hold, or whatever you want to do with that.","title":"Creating NFTs on Solana blockchain using Rarible SDK"},{"location":"getting-started/solana-nft-app/#summary","text":"In this article, we\u2019ve learned how you can take advantage of the Rarible SDK and API to create and see an NFT on Solana. The most important thing to remember while developing is to set your Phantom network to devnet, and the environment to \u201cdevelopment\u201d on Rarible SDK. If you remember that, everything else should flow as smooth as butter. \ud83e\uddc8","title":"Summary"},{"location":"getting-started/tezos-blockchain-tutorial/","text":"How to create NFTs on Tezos Blockchain using Rarible Protocol? \u00b6 What is Tezos blockchain, and how can you create NFTs on it? Main properties of Tezos are: Self-Amendment In pursuit of a strong, united community, without the need for hard forks, they\u2019ve created a self-amendment algorithm that basically adapts proposed changes step by step (of course, only the ones accepted by the community). The algorithm is very strong, error-resistant and what there are currently a lot of different proposals for improvements. Proof Of Stake It is always nice to have a proof of stake mechanism: faster transactions, insanely low fees compared to PoW chains like Ethereum. Smart Contracts Tezos native smart contract\u2019s language is Michelson, which facilitates formal verification. As you can see, Tezos is a pretty stable option. How to get funds in Tezos test wallet \u00b6 Before we can mint an NFT, we actually need to have some sort of asset to spend. We use \u201cfaucets\u201d for that. A Faucet is basically a software that can pour some crypto into your test account. You can find detailed instructions on how to do it here . Creating NFTs on Tezos, programmatically \u00b6 To make everything done as quickly and efficiently as possible, we will use the Rarible Protocol . It allows you to create NFTs on a few blockchains right now, and one of them is Tezos (it also makes it very simple to do so). You can change your codebase from creating NFTs on Ethereum to Tezos in basically two lines. On Rarible, we\u2019ve created a ready-to-code template , with Next JS, Tailwind CSS, and already configured Rarible SDK, which you can just clone from GitHub and follow along. Since the code of the Union SDK (the one which is already set for you) is pretty complicated, we won\u2019t dive into it in this article. App file \u00b6 We start by wrapping the whole app in SdkWalletConnecter and SdkContextProvider . Additionally, we pick the desired wallet that we want to use in our project. Beacon is a provider that allows us to use Temple Wallet, which supports Tezos. \ud83d\udca1 If you want to change the appearance of the \u201cconnect wallet\u201d button, you can do it in sdk-wallet-connector.tsx , specifically using the Options function. Index File \u00b6 The Index File is responsible for creating the view shown above. Pass Collection ID \u00b6 Collection ID is in a format called the \u201cUnion Address\u201d. The Union Address is nothing more than the blockchain name in uppercase letters, followed by colon, followed by contract address. On most blockchain smart contracts there are accounts, just like any other, but with a few differences. They contain executable code. \ud83d\udc68\u200d\ud83d\udcbb Examples of correct Union Addresses: ETHEREUM: 0x6ede7f3c26975aad32a475e1021d8f6f39c89d82 TEZOS: KT18vSGouhJcJZDDgrbBKkdCBjSXJWSbui3i When it comes to Rarible\u2019s smart contract addresses, you can find most of them here . Unfortunately, some of them (e.g. Flow, Tezos) can change due to continuous development, so the best place to find the right one is on discord (Rarible Protocol). Just ping us there. \ud83d\ude09 For Tezos, the address of the smart contract on Hangzhounet\u2019s test network is: KT18vSGouhJcJZDDgrbBKkdCBjSXJWSbui3i And you can see your test Tezos token by going to https://rinkeby.rarible.com/ and selecting the Tezos blockchain on the explore dropdown. Pass Additional Parameters \u00b6 We use collection ID in order to determine a few things: If Union Address is correct If Lazy Mint is supported If Multiple Supply is allowed You can look through the response object to see all the properties. Submitting Response Object to the Blockchain \u00b6 After filling in all the wanted properties, it\u2019s time to submit the transaction. Summary \u00b6 And that\u2019s it! It\u2019s really simple, to be honest. Now let\u2019s take a look at what we have learned: What Tezos is and what is special about it. Where to find the ready-to-code GitHub template. How to create an NFT on Tezos blockchain.","title":"How to create NFTs on Tezos Blockchain using Rarible Protocol"},{"location":"getting-started/tezos-blockchain-tutorial/#how-to-create-nfts-on-tezos-blockchain-using-rarible-protocol","text":"What is Tezos blockchain, and how can you create NFTs on it? Main properties of Tezos are: Self-Amendment In pursuit of a strong, united community, without the need for hard forks, they\u2019ve created a self-amendment algorithm that basically adapts proposed changes step by step (of course, only the ones accepted by the community). The algorithm is very strong, error-resistant and what there are currently a lot of different proposals for improvements. Proof Of Stake It is always nice to have a proof of stake mechanism: faster transactions, insanely low fees compared to PoW chains like Ethereum. Smart Contracts Tezos native smart contract\u2019s language is Michelson, which facilitates formal verification. As you can see, Tezos is a pretty stable option.","title":"How to create NFTs on Tezos Blockchain using Rarible Protocol?"},{"location":"getting-started/tezos-blockchain-tutorial/#how-to-get-funds-in-tezos-test-wallet","text":"Before we can mint an NFT, we actually need to have some sort of asset to spend. We use \u201cfaucets\u201d for that. A Faucet is basically a software that can pour some crypto into your test account. You can find detailed instructions on how to do it here .","title":"How to get funds in Tezos test wallet"},{"location":"getting-started/tezos-blockchain-tutorial/#creating-nfts-on-tezos-programmatically","text":"To make everything done as quickly and efficiently as possible, we will use the Rarible Protocol . It allows you to create NFTs on a few blockchains right now, and one of them is Tezos (it also makes it very simple to do so). You can change your codebase from creating NFTs on Ethereum to Tezos in basically two lines. On Rarible, we\u2019ve created a ready-to-code template , with Next JS, Tailwind CSS, and already configured Rarible SDK, which you can just clone from GitHub and follow along. Since the code of the Union SDK (the one which is already set for you) is pretty complicated, we won\u2019t dive into it in this article.","title":"Creating NFTs on Tezos, programmatically"},{"location":"getting-started/tezos-blockchain-tutorial/#app-file","text":"We start by wrapping the whole app in SdkWalletConnecter and SdkContextProvider . Additionally, we pick the desired wallet that we want to use in our project. Beacon is a provider that allows us to use Temple Wallet, which supports Tezos. \ud83d\udca1 If you want to change the appearance of the \u201cconnect wallet\u201d button, you can do it in sdk-wallet-connector.tsx , specifically using the Options function.","title":"App file"},{"location":"getting-started/tezos-blockchain-tutorial/#index-file","text":"The Index File is responsible for creating the view shown above.","title":"Index File"},{"location":"getting-started/tezos-blockchain-tutorial/#pass-collection-id","text":"Collection ID is in a format called the \u201cUnion Address\u201d. The Union Address is nothing more than the blockchain name in uppercase letters, followed by colon, followed by contract address. On most blockchain smart contracts there are accounts, just like any other, but with a few differences. They contain executable code. \ud83d\udc68\u200d\ud83d\udcbb Examples of correct Union Addresses: ETHEREUM: 0x6ede7f3c26975aad32a475e1021d8f6f39c89d82 TEZOS: KT18vSGouhJcJZDDgrbBKkdCBjSXJWSbui3i When it comes to Rarible\u2019s smart contract addresses, you can find most of them here . Unfortunately, some of them (e.g. Flow, Tezos) can change due to continuous development, so the best place to find the right one is on discord (Rarible Protocol). Just ping us there. \ud83d\ude09 For Tezos, the address of the smart contract on Hangzhounet\u2019s test network is: KT18vSGouhJcJZDDgrbBKkdCBjSXJWSbui3i And you can see your test Tezos token by going to https://rinkeby.rarible.com/ and selecting the Tezos blockchain on the explore dropdown.","title":"Pass Collection ID"},{"location":"getting-started/tezos-blockchain-tutorial/#pass-additional-parameters","text":"We use collection ID in order to determine a few things: If Union Address is correct If Lazy Mint is supported If Multiple Supply is allowed You can look through the response object to see all the properties.","title":"Pass Additional Parameters"},{"location":"getting-started/tezos-blockchain-tutorial/#submitting-response-object-to-the-blockchain","text":"After filling in all the wanted properties, it\u2019s time to submit the transaction.","title":"Submitting Response Object to the Blockchain"},{"location":"getting-started/tezos-blockchain-tutorial/#summary","text":"And that\u2019s it! It\u2019s really simple, to be honest. Now let\u2019s take a look at what we have learned: What Tezos is and what is special about it. Where to find the ready-to-code GitHub template. How to create an NFT on Tezos blockchain.","title":"Summary"},{"location":"getting-started/unifiedTransfer/","text":"Transfering token between two addresses \u00b6 Process of transfering tokens between two addresses is straightforward. In order for the transfer to be successful it has to be created from an address to which an NFT belongs to. Signing of the transaction by the owner will also be required. Basically what we need is two things: itemId: which allows to uniquely identify any NFT on any blockchain, recipientAddress: which tells us where the token should be transfered. Create an ItemId & PrepareTransferRequest \u00b6 Item Id, as a lot of addresses in Rarible Protocol, consist of a few parts, separated by colon sign - ':'. We can create Item Id by merging: Blockchain name - ETHEREUM, TEZOS, FLOW, etc., Contract address - address of a smart contract responsible for NFT creation (you can find a smart contract address for specific blockchain here ), Token Id - id of minted / lazy minted token. So the ItemId, in theory, will look like that: {BLOCKCHAIN_NAME}:{CONTRACT_ADDRESS}:{TOKEN_ID} while in practice it can look like that: ETHEREUM : 0x6ede7f3c26975aad32a475e1021d8f6f39c89d82 : 55143609719300586327244080327388661151936544170854464635146779205246455382070 ; On the other hand we have a PrepareTransferRequest which is a simple object of PrepareTransferRequest type with an itemId property. In code you can do it like that: // Imports // unionAddress will be used and explained further in the article import { toItemId , toUnionAddress } from \"@rarible/types\" ; const itemId = \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:55143609719300586327244080327388661151936544170854464635146779205246455382070\" ; const transferRequest : PrepareTransferRequest = { itemId : toItemId ( itemId ), }; Call sdk.nft.transfer method with transferRequest as an argument \u00b6 In the next step we take PrepareTransferRequest that we've created in previous step and use it to call sdk.nft.transfer method. It will return us a submit function as well as available options for that operation. const transferResponse = await sdk . nft . transfer ( transferRequest ); // Example of a response // { // \"multiple\": false, // \"maxAmount\": \"1\", // \"submit\": f() // } Call a submit function \u00b6 Now, there is one thing left and it is to call a submit function we previously fetched. This is the step which will trigger a Metamask window and a payment, since we're doing write operation on a blockchain (changing an owner is a write operation). Submit object consist of two parameters: to (required) - which is of type of UnifiedAddress {BLOCKCHAIN_NAME}:{ADDRESS}, amount - if the multiple flag from the previous step was true, it's possible to transfer more than one NFT, default to one. const response = await transferResponse . submit ({ to : toUnionAddress ( \"ETHEREUM:0x18c37f21D3C29f9a53A96CA678026DC660180065\" ), amount : 1 , }); // Example of a response // { // \"transaction\": { // \"receipt\": {}, // \"hash\": \"0xe78cb6963ac4c960c5c623d08d1407a\", // \"data\": \"0x832fbb2...\", // \"nonce\": 24, // \"from\": \"0x79ea2d536b5b7144a3eabdc6a7e43130199291c0\", // \"to\": \"0x6ede7f3c26975aad32a475e1021d8f6f39c89d82\" // }, // \"network\": \"rinkeby\", // \"blockchain\": \"ETHEREUM\" // } That's all in this section.","title":"Transfer tokens between addresses"},{"location":"getting-started/unifiedTransfer/#transfering-token-between-two-addresses","text":"Process of transfering tokens between two addresses is straightforward. In order for the transfer to be successful it has to be created from an address to which an NFT belongs to. Signing of the transaction by the owner will also be required. Basically what we need is two things: itemId: which allows to uniquely identify any NFT on any blockchain, recipientAddress: which tells us where the token should be transfered.","title":"Transfering token between two addresses"},{"location":"getting-started/unifiedTransfer/#create-an-itemid-preparetransferrequest","text":"Item Id, as a lot of addresses in Rarible Protocol, consist of a few parts, separated by colon sign - ':'. We can create Item Id by merging: Blockchain name - ETHEREUM, TEZOS, FLOW, etc., Contract address - address of a smart contract responsible for NFT creation (you can find a smart contract address for specific blockchain here ), Token Id - id of minted / lazy minted token. So the ItemId, in theory, will look like that: {BLOCKCHAIN_NAME}:{CONTRACT_ADDRESS}:{TOKEN_ID} while in practice it can look like that: ETHEREUM : 0x6ede7f3c26975aad32a475e1021d8f6f39c89d82 : 55143609719300586327244080327388661151936544170854464635146779205246455382070 ; On the other hand we have a PrepareTransferRequest which is a simple object of PrepareTransferRequest type with an itemId property. In code you can do it like that: // Imports // unionAddress will be used and explained further in the article import { toItemId , toUnionAddress } from \"@rarible/types\" ; const itemId = \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:55143609719300586327244080327388661151936544170854464635146779205246455382070\" ; const transferRequest : PrepareTransferRequest = { itemId : toItemId ( itemId ), };","title":"Create an ItemId &amp; PrepareTransferRequest"},{"location":"getting-started/unifiedTransfer/#call-sdknfttransfer-method-with-transferrequest-as-an-argument","text":"In the next step we take PrepareTransferRequest that we've created in previous step and use it to call sdk.nft.transfer method. It will return us a submit function as well as available options for that operation. const transferResponse = await sdk . nft . transfer ( transferRequest ); // Example of a response // { // \"multiple\": false, // \"maxAmount\": \"1\", // \"submit\": f() // }","title":"Call sdk.nft.transfer method with transferRequest as an argument"},{"location":"getting-started/unifiedTransfer/#call-a-submit-function","text":"Now, there is one thing left and it is to call a submit function we previously fetched. This is the step which will trigger a Metamask window and a payment, since we're doing write operation on a blockchain (changing an owner is a write operation). Submit object consist of two parameters: to (required) - which is of type of UnifiedAddress {BLOCKCHAIN_NAME}:{ADDRESS}, amount - if the multiple flag from the previous step was true, it's possible to transfer more than one NFT, default to one. const response = await transferResponse . submit ({ to : toUnionAddress ( \"ETHEREUM:0x18c37f21D3C29f9a53A96CA678026DC660180065\" ), amount : 1 , }); // Example of a response // { // \"transaction\": { // \"receipt\": {}, // \"hash\": \"0xe78cb6963ac4c960c5c623d08d1407a\", // \"data\": \"0x832fbb2...\", // \"nonce\": 24, // \"from\": \"0x79ea2d536b5b7144a3eabdc6a7e43130199291c0\", // \"to\": \"0x6ede7f3c26975aad32a475e1021d8f6f39c89d82\" // }, // \"network\": \"rinkeby\", // \"blockchain\": \"ETHEREUM\" // } That's all in this section.","title":"Call a submit function"},{"location":"overview/architecture/","text":"Architecture \u00b6 Rarible Multichain protocol is built on 3-layer architecture: Blockchain Indexing Layer \u2013 a set of listeners to retrieve blockchain events process them and store in Rarible Database in a form of business objects Smart-Contracts \u2013 provide common logic to operate NFT-assets, e.g., minting, selling, transferring, auctions, etc. Multichain API \u2013 SDK for developers to use protocol capabilities in a simple blockchain-agnostic manner Protocol architecture The Protocol is primarily targeted to NFTs, but it's not limited to NFTs only. Any asset on EVM blockchain can be traded on Rarible. Rarible doing indexing per each blockchain integrated into protocol. Following events are listened: Block events Log events Rarible Multichain Protocol is fast performing and able to retrieve blocks with up to 2 seconds delay from blockchain. Blockchain restructuring is supported \u2013 changed blocks are indexed again to resolve discrepancies if any. Likewise, blockchain indexing Rarible protocol listens for most popular NFT-marketplaces to retrieve their order books, this helps to store in Rarible database both on-chain and off-chain information. Smart-contracts are constructed in the way to be upgradeable, orders have versioning information, so new fields can be added if needed in the future. All smart-contracts in Rarible before publishing pass mandatory security audit, so only verified reliable versions are provided with protocol. Multichain API provides blockchain agnostic SDK to: Search and retrieve business objects from Rarible Database (NFTs, orders, collections and detailed information about these objects) Perform on-chain actions \u2013 mint, sell, transfer NFTs Perform off-chain activities like lazy-minting Apply royalties and organize auctions In addition, Rarible Multichain Protocol provides information for dedicated customers to retrieve information about business objects changed immediately in publish-subscribe manner using Apache Kafka feed. Indexed events are sent to Apache Kafka in the same time they are stored in the database.","title":"Architecture"},{"location":"overview/architecture/#architecture","text":"Rarible Multichain protocol is built on 3-layer architecture: Blockchain Indexing Layer \u2013 a set of listeners to retrieve blockchain events process them and store in Rarible Database in a form of business objects Smart-Contracts \u2013 provide common logic to operate NFT-assets, e.g., minting, selling, transferring, auctions, etc. Multichain API \u2013 SDK for developers to use protocol capabilities in a simple blockchain-agnostic manner Protocol architecture The Protocol is primarily targeted to NFTs, but it's not limited to NFTs only. Any asset on EVM blockchain can be traded on Rarible. Rarible doing indexing per each blockchain integrated into protocol. Following events are listened: Block events Log events Rarible Multichain Protocol is fast performing and able to retrieve blocks with up to 2 seconds delay from blockchain. Blockchain restructuring is supported \u2013 changed blocks are indexed again to resolve discrepancies if any. Likewise, blockchain indexing Rarible protocol listens for most popular NFT-marketplaces to retrieve their order books, this helps to store in Rarible database both on-chain and off-chain information. Smart-contracts are constructed in the way to be upgradeable, orders have versioning information, so new fields can be added if needed in the future. All smart-contracts in Rarible before publishing pass mandatory security audit, so only verified reliable versions are provided with protocol. Multichain API provides blockchain agnostic SDK to: Search and retrieve business objects from Rarible Database (NFTs, orders, collections and detailed information about these objects) Perform on-chain actions \u2013 mint, sell, transfer NFTs Perform off-chain activities like lazy-minting Apply royalties and organize auctions In addition, Rarible Multichain Protocol provides information for dedicated customers to retrieve information about business objects changed immediately in publish-subscribe manner using Apache Kafka feed. Indexed events are sent to Apache Kafka in the same time they are stored in the database.","title":"Architecture"},{"location":"overview/auctions/","text":"Auctions \u00b6 Auctions types \u00b6 In Rarible Protocol implements English auction with fixed step. We have two AuctionHouse contracts for different type of sell asset. At that moment, we support English auction only for Ethereum and Polygon blockchains. AuctionHouse contracts types: AuctionHouse721 sell asset = ERC-721 buy asset = ETH or ERC-20 supports party bid AuctionHouse1155 sell asset = ERC-1155 buy asset = ETH or ERC-20 Features \u00b6 There are two parameters of AuctionHouse that are the same for all auctions and can be changed by AuctionHouse owner: minimalDuration \u2014 defines the minimal duration of auctions minimalStepBasePoint \u2014 is the minimal percentage increase between bids (in base points). For example, minimalStepBasePoint = 300 = 3%, first bid is 100 ETH, the second one should be not less than (100 + 100*3% =) 103 Auction time frame is decided by 2 parameters: duration mandatory parameter, that defines the duration of auction in seconds it must be between minimalDuration (default value is 15 days) and 1000 days (constant) startTime optional parameter that defines the start time an auction unix timestamp, can't be less than the time of creation of the auction So there are two cases of how the auction time frame can work: if startTime is 0, then the auction starts at the first bid that satisfies minimalPrice . Then the endTime is calculated at the moment of the first bid as well ( now + duration ) if startTime is set, then the endTime is calculated at the creation of an auction ( startTime + duration ) If a new bid is put when auction has less than minimalDuration left till endTime , then endTime = now + minimalDuration Data model \u00b6 Auction ERC721 \u00b6 address sellToken \u2014 sell asset contract address uint sellTokenId \u2014 sell asset tokenId address buyAsset \u2014 buy asset contract address if ERC20 (address(0) if buy asset = ETH) uint96 endTime \u2014 auction end time in unix timestamp Bid lastBid \u2014 last successful Bid address payable seller \u2014 seller address uint96 minimalPrice \u2014 minimal amount of the first bid address payable buyer \u2014 last successful bidder uint64 protocolFee \u2014 protocolFee at the time of auction creation bytes4 dataType \u2014 version of data field bytes data \u2014 encoded additional data, V1 fields uint originFee \u2014 auction origin fee in one uint slot (first 12 bytes store value, last 20 bytes store recipient) uint duration \u2014 auction duration uint startTime \u2014 auction start time uint buyOutPrice \u2014 auction buyOut price (if bid amout > buyout price, then auction finishes and all transfers are done) AuctionERC1155 \u00b6 The main difference from struct Auction ERC721 is the additional field uint96 sellTokenValue address sellToken \u2014 sell asset contract address uint96 sellTokenValue \u2014 sell asset value uint sellTokenId \u2014 sell asset tokenId address buyAsset \u2014 buy asset contract address if ERC20 (address(0) if buy asset = ETH) uint96 endTime \u2014 auction end time in unix timestamp Bid lastBid \u2014 last successful Bid address payable seller \u2014 seller address uint96 minimalPrice \u2014 minimal amount of the first bid address payable buyer \u2014 last successful bidder uint64 protocolFee \u2014 protocolFee at the time of auction creation bytes4 dataType \u2014 version of data field bytes data \u2014 encoded additional data, V1 fields uint originFee \u2014 auction origin fee in one uint slot (first 12 bytes store value, last 20 bytes store recipient) uint duration \u2014 auction duration uint startTime \u2014 auction start time uint buyOutPrice \u2014 auction buyOut price (if bid amout >= buyout price, then auction finishes and all transfers are done) Bid \u00b6 amount \u2014 bid amount dataType \u2014 version of data field data \u2014 encoded additional data, V1 fields uint originFee \u2014 bid origin fee in one uint slot (first 12 bytes store value, last 20 bytes store recipient) Main functions \u00b6 startAuction start new auction emits event AuctionCreated(uint indexed auctionId, address seller, uint128 endTime) can be called from anyone arguments for ERC721 Auction address _sellToken \u2014 sell token address uint _sellTokenId \u2014 sell token Id address _buyAsset \u2014 buy asset address (0 if ETH) uint96 minimalPrice \u2014 minimal first bid price bytes4 dataType \u2014 data field type bytes memory data \u2014 additional Data arguments for ERC1155 Auction (1 additional field uint96 _sellTokenValue) address _sellToken \u2014 sell token address uint96 _sellTokenValue \u2014 sell token value uint _sellTokenId \u2014 sell token Id address _buyAsset \u2014 buy asset address (0 if ETH) uint96 minimalPrice \u2014 minimal first bid price bytes4 dataType \u2014 data field type bytes memory data \u2014 additional Data putBid puts bid on specific auction emits event BidPlaced(uint indexed auctionId, address seller, uint128 endTime) can be called from anyone arguments: _auctionId \u2014 auction Id bid \u2014 bid struct finishAuction finishes auction if it's ended(now > endTime) and has at least 1 bid emits event AuctionFinished(_auctionId) can be called from anyone arguments: _auctionId \u2014 auction Id buyOut buy out the sell item and finishes the auction emits event AuctionBuyOut(uint indexed auctionId, address buyer) emits event AuctionFinished(_auctionId) can be called from anyone arguments: _auctionId \u2014 auction Id bid \u2014 bid struct cancel finishes auction if it's not started and has no bids emits event AuctionCancelled(uint indexed auctionId) emits event AuctionFinished(_auctionId) can be called from auction creator arguments: _auctionId \u2014 auction Id","title":"Rarible Protocol Auctions"},{"location":"overview/auctions/#auctions","text":"","title":"Auctions"},{"location":"overview/auctions/#auctions-types","text":"In Rarible Protocol implements English auction with fixed step. We have two AuctionHouse contracts for different type of sell asset. At that moment, we support English auction only for Ethereum and Polygon blockchains. AuctionHouse contracts types: AuctionHouse721 sell asset = ERC-721 buy asset = ETH or ERC-20 supports party bid AuctionHouse1155 sell asset = ERC-1155 buy asset = ETH or ERC-20","title":"Auctions types"},{"location":"overview/auctions/#features","text":"There are two parameters of AuctionHouse that are the same for all auctions and can be changed by AuctionHouse owner: minimalDuration \u2014 defines the minimal duration of auctions minimalStepBasePoint \u2014 is the minimal percentage increase between bids (in base points). For example, minimalStepBasePoint = 300 = 3%, first bid is 100 ETH, the second one should be not less than (100 + 100*3% =) 103 Auction time frame is decided by 2 parameters: duration mandatory parameter, that defines the duration of auction in seconds it must be between minimalDuration (default value is 15 days) and 1000 days (constant) startTime optional parameter that defines the start time an auction unix timestamp, can't be less than the time of creation of the auction So there are two cases of how the auction time frame can work: if startTime is 0, then the auction starts at the first bid that satisfies minimalPrice . Then the endTime is calculated at the moment of the first bid as well ( now + duration ) if startTime is set, then the endTime is calculated at the creation of an auction ( startTime + duration ) If a new bid is put when auction has less than minimalDuration left till endTime , then endTime = now + minimalDuration","title":"Features"},{"location":"overview/auctions/#data-model","text":"","title":"Data model"},{"location":"overview/auctions/#auction-erc721","text":"address sellToken \u2014 sell asset contract address uint sellTokenId \u2014 sell asset tokenId address buyAsset \u2014 buy asset contract address if ERC20 (address(0) if buy asset = ETH) uint96 endTime \u2014 auction end time in unix timestamp Bid lastBid \u2014 last successful Bid address payable seller \u2014 seller address uint96 minimalPrice \u2014 minimal amount of the first bid address payable buyer \u2014 last successful bidder uint64 protocolFee \u2014 protocolFee at the time of auction creation bytes4 dataType \u2014 version of data field bytes data \u2014 encoded additional data, V1 fields uint originFee \u2014 auction origin fee in one uint slot (first 12 bytes store value, last 20 bytes store recipient) uint duration \u2014 auction duration uint startTime \u2014 auction start time uint buyOutPrice \u2014 auction buyOut price (if bid amout > buyout price, then auction finishes and all transfers are done)","title":"Auction ERC721"},{"location":"overview/auctions/#auctionerc1155","text":"The main difference from struct Auction ERC721 is the additional field uint96 sellTokenValue address sellToken \u2014 sell asset contract address uint96 sellTokenValue \u2014 sell asset value uint sellTokenId \u2014 sell asset tokenId address buyAsset \u2014 buy asset contract address if ERC20 (address(0) if buy asset = ETH) uint96 endTime \u2014 auction end time in unix timestamp Bid lastBid \u2014 last successful Bid address payable seller \u2014 seller address uint96 minimalPrice \u2014 minimal amount of the first bid address payable buyer \u2014 last successful bidder uint64 protocolFee \u2014 protocolFee at the time of auction creation bytes4 dataType \u2014 version of data field bytes data \u2014 encoded additional data, V1 fields uint originFee \u2014 auction origin fee in one uint slot (first 12 bytes store value, last 20 bytes store recipient) uint duration \u2014 auction duration uint startTime \u2014 auction start time uint buyOutPrice \u2014 auction buyOut price (if bid amout >= buyout price, then auction finishes and all transfers are done)","title":"AuctionERC1155"},{"location":"overview/auctions/#bid","text":"amount \u2014 bid amount dataType \u2014 version of data field data \u2014 encoded additional data, V1 fields uint originFee \u2014 bid origin fee in one uint slot (first 12 bytes store value, last 20 bytes store recipient)","title":"Bid"},{"location":"overview/auctions/#main-functions","text":"startAuction start new auction emits event AuctionCreated(uint indexed auctionId, address seller, uint128 endTime) can be called from anyone arguments for ERC721 Auction address _sellToken \u2014 sell token address uint _sellTokenId \u2014 sell token Id address _buyAsset \u2014 buy asset address (0 if ETH) uint96 minimalPrice \u2014 minimal first bid price bytes4 dataType \u2014 data field type bytes memory data \u2014 additional Data arguments for ERC1155 Auction (1 additional field uint96 _sellTokenValue) address _sellToken \u2014 sell token address uint96 _sellTokenValue \u2014 sell token value uint _sellTokenId \u2014 sell token Id address _buyAsset \u2014 buy asset address (0 if ETH) uint96 minimalPrice \u2014 minimal first bid price bytes4 dataType \u2014 data field type bytes memory data \u2014 additional Data putBid puts bid on specific auction emits event BidPlaced(uint indexed auctionId, address seller, uint128 endTime) can be called from anyone arguments: _auctionId \u2014 auction Id bid \u2014 bid struct finishAuction finishes auction if it's ended(now > endTime) and has at least 1 bid emits event AuctionFinished(_auctionId) can be called from anyone arguments: _auctionId \u2014 auction Id buyOut buy out the sell item and finishes the auction emits event AuctionBuyOut(uint indexed auctionId, address buyer) emits event AuctionFinished(_auctionId) can be called from anyone arguments: _auctionId \u2014 auction Id bid \u2014 bid struct cancel finishes auction if it's not started and has no bids emits event AuctionCancelled(uint indexed auctionId) emits event AuctionFinished(_auctionId) can be called from auction creator arguments: _auctionId \u2014 auction Id","title":"Main functions"},{"location":"overview/data-model/","text":"Protocol Data Model \u00b6 Rarible Protocol uses the following basic concepts to form the Data Model: item \u2014 NFT (Non-Fungible Token) collection \u2014 collection of NFT items blockchain \u2014 name of the blockchain network order \u2014 intent to sell an NFT activity \u2014 events with items like \"MINT\", \"SELL\" etc. Collections and items have their own id , that contain the blockchain and different types of tokens . Item \u00b6 The item has an array of required and optional parameters. It depends on several parameters and contains the name of the blockchain , address or token of the item collection . Collection \u00b6 The collection has an array of required and optional parameters too. It depends on several parameters and contains the name of the blockchain and tokens of the collection . Order \u00b6 Order means intent to sell an NFT for a given price. To complete the Order, accept the Bid from the potential buyer. The order has an array of required and optional parameters. It depends on several parameters and contains the name of the blockchain too. You can find more information and examples on Search Capabilities page.","title":"Data model"},{"location":"overview/data-model/#protocol-data-model","text":"Rarible Protocol uses the following basic concepts to form the Data Model: item \u2014 NFT (Non-Fungible Token) collection \u2014 collection of NFT items blockchain \u2014 name of the blockchain network order \u2014 intent to sell an NFT activity \u2014 events with items like \"MINT\", \"SELL\" etc. Collections and items have their own id , that contain the blockchain and different types of tokens .","title":"Protocol Data Model"},{"location":"overview/data-model/#item","text":"The item has an array of required and optional parameters. It depends on several parameters and contains the name of the blockchain , address or token of the item collection .","title":"Item"},{"location":"overview/data-model/#collection","text":"The collection has an array of required and optional parameters too. It depends on several parameters and contains the name of the blockchain and tokens of the collection .","title":"Collection"},{"location":"overview/data-model/#order","text":"Order means intent to sell an NFT for a given price. To complete the Order, accept the Bid from the potential buyer. The order has an array of required and optional parameters. It depends on several parameters and contains the name of the blockchain too. You can find more information and examples on Search Capabilities page.","title":"Order"},{"location":"overview/indexer/","text":"Indexer \u00b6 It's nice to think that every service in the crypto space is fully decentralized. Of course, it isn't. Just imagine looking through the Ethereum blockchain for specific information. Right now, i.e. 23.03.2022 the Ethereum blockchain size is almost 1 TB. It would be impossible to traverse that big chunk of a data in UX-friendly timeframe. That's why indexers originated. At the end of the day, what does indexing mean? It means to write data somewhere for later usage. In its essence, indexer take the data which we're interested in from blockchain (most of the time, we're not interested in every specific transaction, just the ones connected to our dApp), and saves it in some sort of database. It can be SQL or NoSQL \u2014 it doesn't really matter. What matters is that now, we have some sort of structure, which we can travel fast and efficiently. Rarible Multichain Indexer \u00b6 Now, when we're conscious about indexer responsibilities and duty, we can lean over what types of indexers are used in Rarible. On Rarible, we have three different types of indexers: NFT Indexer Token/Balance-Indexer Order Indexer Additionally, in order for the services to work, we have a MongoDB instance, where all the indexed data from different blockchains sits, and a Multichain SDK API which allows for data traversing. NFT Indexer \u00b6 NFT Indexer is used to index all history of NFTs related actions, i.e. mint, transfer and burn. Indexer gets logs from an Ethereum network, and accordingly creates NFT items in a NoSQL database. Especially, it listens to a change of a state of an NFT item ownership. Token/Balance-Indexer \u00b6 Token/Balance-Indexer is responsible for tracking user balances. If we mapped it to the Rarible usage, it checks if a user has enough of a given currency to make a bid. It handles all the information about a user's wallet status. Order Indexer \u00b6 In order to properly display order information (order means intent, e.g. intent to sell, or in simpler words, intent to sell an NFT for a given price), we need an order price in addition to other properties. That's where Order Indexer comes in. Listener catches logs which say e.g. if an order was executed, and what is the status of an order. It fetches order data from a few different places like OpenSea, Rarible OrderBook, or Cryptopunks. How does the indexer gather the data? \u00b6 It listens for specific events on a blockchain. Since every transaction and movement on a blockchain is emitted in a form of logs, and every log has its unique topic id, it can be explicitly identified. Moreover, the indexer is also listening for block creation events. Listening from two sources simultaneously gives us the certainty that we will manage to catch all events we're interested in. What events do the indexer listen to? \u00b6 Indexer listens mainly for transfer-type events. That's because almost all the NFT-related actions, including Minting, involve a transfer method, which creates an NFT (in that scenario we transfer the NFT from 0x0 address to the address of a creator). From fetched logs, the indexer creates item and ownership objects that it stores in a database. It also tracks events for a specific collection (Rarible collection, etc.) from which it creates a token entity, and stores it in a database as well. Multichain abstraction \u00b6 In order to be able to connect differently, not EVM based blockchains together, Rarible had to create a few different blockchain indexers. They all work based on the same principle, but since different blockchains like Tezos, Solana, Flow, have different architecture, they couldn't be simply merge. But the merge could be abstracted, and that's what Rarible has done. It created a service called Union, and it works as a \"really smart proxy\" which allows you to use one API for all the blockchains. It takes all the Kafka proxy topics, from all the blockchains, and merges it into one topic. That's how you're able to get info from all the blockchains by using one Multichain API.","title":"Indexer"},{"location":"overview/indexer/#indexer","text":"It's nice to think that every service in the crypto space is fully decentralized. Of course, it isn't. Just imagine looking through the Ethereum blockchain for specific information. Right now, i.e. 23.03.2022 the Ethereum blockchain size is almost 1 TB. It would be impossible to traverse that big chunk of a data in UX-friendly timeframe. That's why indexers originated. At the end of the day, what does indexing mean? It means to write data somewhere for later usage. In its essence, indexer take the data which we're interested in from blockchain (most of the time, we're not interested in every specific transaction, just the ones connected to our dApp), and saves it in some sort of database. It can be SQL or NoSQL \u2014 it doesn't really matter. What matters is that now, we have some sort of structure, which we can travel fast and efficiently.","title":"Indexer"},{"location":"overview/indexer/#rarible-multichain-indexer","text":"Now, when we're conscious about indexer responsibilities and duty, we can lean over what types of indexers are used in Rarible. On Rarible, we have three different types of indexers: NFT Indexer Token/Balance-Indexer Order Indexer Additionally, in order for the services to work, we have a MongoDB instance, where all the indexed data from different blockchains sits, and a Multichain SDK API which allows for data traversing.","title":"Rarible Multichain Indexer"},{"location":"overview/indexer/#nft-indexer","text":"NFT Indexer is used to index all history of NFTs related actions, i.e. mint, transfer and burn. Indexer gets logs from an Ethereum network, and accordingly creates NFT items in a NoSQL database. Especially, it listens to a change of a state of an NFT item ownership.","title":"NFT Indexer"},{"location":"overview/indexer/#tokenbalance-indexer","text":"Token/Balance-Indexer is responsible for tracking user balances. If we mapped it to the Rarible usage, it checks if a user has enough of a given currency to make a bid. It handles all the information about a user's wallet status.","title":"Token/Balance-Indexer"},{"location":"overview/indexer/#order-indexer","text":"In order to properly display order information (order means intent, e.g. intent to sell, or in simpler words, intent to sell an NFT for a given price), we need an order price in addition to other properties. That's where Order Indexer comes in. Listener catches logs which say e.g. if an order was executed, and what is the status of an order. It fetches order data from a few different places like OpenSea, Rarible OrderBook, or Cryptopunks.","title":"Order Indexer"},{"location":"overview/indexer/#how-does-the-indexer-gather-the-data","text":"It listens for specific events on a blockchain. Since every transaction and movement on a blockchain is emitted in a form of logs, and every log has its unique topic id, it can be explicitly identified. Moreover, the indexer is also listening for block creation events. Listening from two sources simultaneously gives us the certainty that we will manage to catch all events we're interested in.","title":"How does the indexer gather the data?"},{"location":"overview/indexer/#what-events-do-the-indexer-listen-to","text":"Indexer listens mainly for transfer-type events. That's because almost all the NFT-related actions, including Minting, involve a transfer method, which creates an NFT (in that scenario we transfer the NFT from 0x0 address to the address of a creator). From fetched logs, the indexer creates item and ownership objects that it stores in a database. It also tracks events for a specific collection (Rarible collection, etc.) from which it creates a token entity, and stores it in a database as well.","title":"What events do the indexer listen to?"},{"location":"overview/indexer/#multichain-abstraction","text":"In order to be able to connect differently, not EVM based blockchains together, Rarible had to create a few different blockchain indexers. They all work based on the same principle, but since different blockchains like Tezos, Solana, Flow, have different architecture, they couldn't be simply merge. But the merge could be abstracted, and that's what Rarible has done. It created a service called Union, and it works as a \"really smart proxy\" which allows you to use one API for all the blockchains. It takes all the Kafka proxy topics, from all the blockchains, and merges it into one topic. That's how you're able to get info from all the blockchains by using one Multichain API.","title":"Multichain abstraction"},{"location":"overview/lazy-minting/","text":"Lazy Minting \u00b6 In order to be able to fully understand what lazy minting is, and the benefits of doing so, we have to scratch the other aspects of blockchain and NFTs first. This document will touch three main aspects, which are crucial in a lazy minting process understanding: Technical description of NFT Minting Lazy Minting Technical description of NFT \u00b6 If you're familiar with the concept of NFTs creation, feel free to skip this section. NFT in its essence is just a variable in a Smart Contract code. The most common approach is as follows: Upload metadata (image, description, attributes, etc.) to IPFS, which is a decentralized JSON-like database. If you ever used a NoSQL database like MongoDB or Firebase, that's basically that, only decentralized. Based on all the properties you've uploaded, a hash is calculated, by which you can now access your asset. Professionally, it's called URI, which stands for Unique Resource Identifier. Moreover, since storing image data on the blockchain would be expensive, instead of image data itself, you store an image URL in your NFT. The image itself can be stored on IPFS. Just not in the JSON you use for the NFT creation. Invoke a Smart Contract function responsible for minting, and assign the URI created in the earlier step to your account address. That's it. Since the code on the blockchain is immutable, and we have a tokenId variable that tracks every unique NFT creation on a given smart contract, even if the same URI would be used twice, it will still be a different NFT. Minting \u00b6 If you've read the first point, you've already had a quite good explanation of how the minting process works. Minting can be described as a process of a write operation (it's an important fact, because if you're writing on the blockchain, you're paying a gas fee), which has one goal \u2014 associate an address of a creator with a tokenId, which points to token metadata URI on IPFS. Pardon those who thought that it is more complicated. Of course, there are some language-specific restrictions and security steps that we have to take care of, but it's enough to use OpenZeppelin implementation of ERC721/ERC1155 to safely elevate core functionality, which in this case is NFT creation. Lazy Minting \u00b6 The most important difference to point out between minting and lazy minting is writing to the blockchain action. As it was said before when writing to a blockchain occurs, the money from your wallet disappears i.e. you pay a gas fee. In a normal minting, this process takes place immediately. In a lazy mint, it can be postponed to the first transfer action (mostly it will be a buy action). How does that work under hood? There is some sort of off-chain database involved there. Basically, instead of immediately minting an NFT, the service stores its details in the off-chain database. In this way, it is able to properly display all the information like image, creator, etc. When the first buy occurs, it is then minted straight to the buyer, but keeps all the information about an author or royalties. The benefits of that are obvious \u2014 you as the creator don't pay a gas limit. You get the same functionality without any cost. You can then either lower the price of an NFT since the duty of gas payment lies on the buyer's side, or you can just get more money. The choice is yours.","title":"Lazy Minting"},{"location":"overview/lazy-minting/#lazy-minting","text":"In order to be able to fully understand what lazy minting is, and the benefits of doing so, we have to scratch the other aspects of blockchain and NFTs first. This document will touch three main aspects, which are crucial in a lazy minting process understanding: Technical description of NFT Minting Lazy Minting","title":"Lazy Minting"},{"location":"overview/lazy-minting/#technical-description-of-nft","text":"If you're familiar with the concept of NFTs creation, feel free to skip this section. NFT in its essence is just a variable in a Smart Contract code. The most common approach is as follows: Upload metadata (image, description, attributes, etc.) to IPFS, which is a decentralized JSON-like database. If you ever used a NoSQL database like MongoDB or Firebase, that's basically that, only decentralized. Based on all the properties you've uploaded, a hash is calculated, by which you can now access your asset. Professionally, it's called URI, which stands for Unique Resource Identifier. Moreover, since storing image data on the blockchain would be expensive, instead of image data itself, you store an image URL in your NFT. The image itself can be stored on IPFS. Just not in the JSON you use for the NFT creation. Invoke a Smart Contract function responsible for minting, and assign the URI created in the earlier step to your account address. That's it. Since the code on the blockchain is immutable, and we have a tokenId variable that tracks every unique NFT creation on a given smart contract, even if the same URI would be used twice, it will still be a different NFT.","title":"Technical description of NFT"},{"location":"overview/lazy-minting/#minting","text":"If you've read the first point, you've already had a quite good explanation of how the minting process works. Minting can be described as a process of a write operation (it's an important fact, because if you're writing on the blockchain, you're paying a gas fee), which has one goal \u2014 associate an address of a creator with a tokenId, which points to token metadata URI on IPFS. Pardon those who thought that it is more complicated. Of course, there are some language-specific restrictions and security steps that we have to take care of, but it's enough to use OpenZeppelin implementation of ERC721/ERC1155 to safely elevate core functionality, which in this case is NFT creation.","title":"Minting"},{"location":"overview/lazy-minting/#lazy-minting_1","text":"The most important difference to point out between minting and lazy minting is writing to the blockchain action. As it was said before when writing to a blockchain occurs, the money from your wallet disappears i.e. you pay a gas fee. In a normal minting, this process takes place immediately. In a lazy mint, it can be postponed to the first transfer action (mostly it will be a buy action). How does that work under hood? There is some sort of off-chain database involved there. Basically, instead of immediately minting an NFT, the service stores its details in the off-chain database. In this way, it is able to properly display all the information like image, creator, etc. When the first buy occurs, it is then minted straight to the buyer, but keeps all the information about an author or royalties. The benefits of that are obvious \u2014 you as the creator don't pay a gas limit. You get the same functionality without any cost. You can then either lower the price of an NFT since the duty of gas payment lies on the buyer's side, or you can just get more money. The choice is yours.","title":"Lazy Minting"},{"location":"overview/next-steps/","text":"Next Steps \u00b6 The main information about starting using Rarible Protocol Multichain SDK Quick Start Guide Reference Overview Contract Addresses Install and configurate SDK Wallets initialization Use Cases","title":"Next Steps"},{"location":"overview/next-steps/#next-steps","text":"The main information about starting using Rarible Protocol Multichain SDK Quick Start Guide Reference Overview Contract Addresses Install and configurate SDK Wallets initialization Use Cases","title":"Next Steps"},{"location":"overview/protocol-overview/","text":"Protocol Overview \u00b6 Rarible Multichain Protocol is a decentralized toolset that simplifies the way developers can work with NFTs. Protocol builds an abstraction layer for several blockchains and isolates the developer from their specifics with Multichain SDK. Rarible Multichain SDK is fully blockchain-agnostic. You can find a list of supported blockchains on our Features page. We use different environments for blockchain networks. See actual information on API Reference page. Rarible Multichain SDK enables applications to easily interact with Rarible Protocol: query, issue and trade NFTs on any blockchain supported. See more information on Reference section. Know about NFTs Rarible Multichain Protocol indexes and provides via API wide information about NFTs. The following data is accessible for developer using protocol near real time it is put into blockchain: Basic NFT information Owner Creator Metadata NFT transactions In addition to on-chain information, Rarible Multichain Protocol collects of-chain information like: Orders put for selling Bids put on NFTs Auctions information Multiple blockchains support Rarible Multichain Protocol is completely blockchain agnostic. Developers do not have to know details about a specific blockchain and can easily start with any of blockchains currently supported (see full list on Features page). Decrease entrance level for developer Rarible Multichain protocol provides easy-to-use API that can be used with: Frontend application Backend server application Mobile app on IOS/Android/Huawei platform No specific knowledge needed to start working with Rarible Multichain Protocol. Reliability and Performance Rarible Multichain Protocol provides high performance and reliable tools for developers. Smart-contracts for Rarible Multichain Protocol pass security audit before publishing. We are indexing data with small delay between it appear on a blockchain and moment when it is accessible with Protocol API, for most performant blockchains we sync data with up to 2 seconds delay from origin. Low Gas Consumption Rarible Multichain Protocol focused on optimizing usage costs for the users. For blockchains like Ethereum, where gas price is sufficient, we are doing a lot to minimize gas usage: Storing a considerable amount of up-to-date data off-chain - developers using our API to fetch NFT information do not pay the gas fee Providing Lazy-mint functionality that does not cost gas for minter Continuous smart contracts review and update, including on-chain auctions Advanced and robust tech done for you Creating the tech from scratch is complicated and time-consuming. Rarible provides access to the tools that the team has been developing for the past 1,5 years, with wide functionality and data on all the NFTs created. Monetization Rarible protocol enables arbitrary front-end fees: you can additionally monetize your creations.","title":"Overview"},{"location":"overview/protocol-overview/#protocol-overview","text":"Rarible Multichain Protocol is a decentralized toolset that simplifies the way developers can work with NFTs. Protocol builds an abstraction layer for several blockchains and isolates the developer from their specifics with Multichain SDK. Rarible Multichain SDK is fully blockchain-agnostic. You can find a list of supported blockchains on our Features page. We use different environments for blockchain networks. See actual information on API Reference page. Rarible Multichain SDK enables applications to easily interact with Rarible Protocol: query, issue and trade NFTs on any blockchain supported. See more information on Reference section. Know about NFTs Rarible Multichain Protocol indexes and provides via API wide information about NFTs. The following data is accessible for developer using protocol near real time it is put into blockchain: Basic NFT information Owner Creator Metadata NFT transactions In addition to on-chain information, Rarible Multichain Protocol collects of-chain information like: Orders put for selling Bids put on NFTs Auctions information Multiple blockchains support Rarible Multichain Protocol is completely blockchain agnostic. Developers do not have to know details about a specific blockchain and can easily start with any of blockchains currently supported (see full list on Features page). Decrease entrance level for developer Rarible Multichain protocol provides easy-to-use API that can be used with: Frontend application Backend server application Mobile app on IOS/Android/Huawei platform No specific knowledge needed to start working with Rarible Multichain Protocol. Reliability and Performance Rarible Multichain Protocol provides high performance and reliable tools for developers. Smart-contracts for Rarible Multichain Protocol pass security audit before publishing. We are indexing data with small delay between it appear on a blockchain and moment when it is accessible with Protocol API, for most performant blockchains we sync data with up to 2 seconds delay from origin. Low Gas Consumption Rarible Multichain Protocol focused on optimizing usage costs for the users. For blockchains like Ethereum, where gas price is sufficient, we are doing a lot to minimize gas usage: Storing a considerable amount of up-to-date data off-chain - developers using our API to fetch NFT information do not pay the gas fee Providing Lazy-mint functionality that does not cost gas for minter Continuous smart contracts review and update, including on-chain auctions Advanced and robust tech done for you Creating the tech from scratch is complicated and time-consuming. Rarible provides access to the tools that the team has been developing for the past 1,5 years, with wide functionality and data on all the NFTs created. Monetization Rarible protocol enables arbitrary front-end fees: you can additionally monetize your creations.","title":"Protocol Overview"},{"location":"overview/protocol-status/","text":"Protocol Status Page \u00b6 Available in Q2 2022","title":"Status"},{"location":"overview/protocol-status/#protocol-status-page","text":"Available in Q2 2022","title":"Protocol Status Page"},{"location":"overview/tokens-fees-royalties/","text":"Tokens, Fees, and Royalties \u00b6 What is NFT \u00b6 NFT means Non-Fungible Token. \u201cNon-fungible\u201d more or less means that it\u2019s unique and can\u2019t be replaced with something else. For example, a bitcoin is fungible \u2014 trade one for another bitcoin, and you\u2019ll have exactly the same thing. NFTs on the other hand are one-of-a-kind tokens that represent a unique good or asset which are non-fungible. If you traded it for a different NFT, you\u2019d have something completely different. NFTs can really be anything digital (such as drawings, music, videos, etc.), but a lot of the current excitement is around using the tech to sell digital art. Tokens \u00b6 Rarible Multichain Protocol various token types applicable for certain blockchain: Ethereum/Polygon: ERC-721 ERC-1155 Rarible user-owned contracts (ERC-721 and ERC-1155) \u2014 users deploy these contracts, only owners can mint in these Flow standard tokens FA2 (TZIP-012) for Tezos Cryptopunks A full list of supported token types could be found on Features page. All these contracts support these features: lazy mint Rarible on-chain royalties multiple creators upgradeable supports operators (who can transfer tokens on behalf of users) for the whole smart contract User-owned contracts use beacon proxies, and these contracts can be updated by Rarible DAO. Rarible common contracts can be upgraded too. Fees \u00b6 Rarible Multichain Protocol supports the following types of fees that are applicable to token operations: Protocol fees \u2014 are charged on both sides of the transaction Origin fees \u2014 set for each order. It may differ for two orders Royalties \u2014 the author of the work will receive a part of each sale Here is an example, how do we calculate fees for Ethereum for each side of the transaction: If there is ETH on any side of the transaction, it is used If there is no ETH, we check if there is an ERC-20 and use it If there is no ERC-20, check if there is an ERC-1155 and use it Otherwise, no fee will be charged. (e.g., if two ERC-721 are involved in the transaction) When computing the total amount of the asset: The protocol fee is added on top of the filled amount The fee for sending the buyer's order is also added on top If the buyer uses the ERC-20 token for payment, he must approve the calculated number of tokens. If the buyer uses ETH, they must send the calculated amount to ETH along with the transaction. Royalties \u00b6 Rarible Multichain Protocol supports two types of royalties: RoyaltiesV1 \u2014 defines an interface to query royalties from a contract. This is implemented on the standard Rarible token contracts. RoyaltiesV2 \u2014 the exchange contract interacts with the Rarible royalties implementation indirectly through a Royalty Registry. The registry checks if the NFT contract supports the expected interface, and if so, queries for the Rarible royalties array. EIP-2981 \u2014 allows contracts, such as NFTs that support ERC-721 and ERC-1155 interfaces, to signal a royalty amount to be paid to the NFT creator or rights holder every time the NFT is sold or re-sold. This is intended for NFT marketplaces that want to support the ongoing funding of artists and other NFT creators. For RoyaltiesV1, contract exposes getRoyalties method, which expects an ID as input (usually tokenId) and returns an array of accounts & basis points. RoyaltiesV2 allows for Rarible to support different royalty standards for different collections. Rarible Multichain Protocol Supports on-chain royalties. These are handled in the ExchangeV1 contract by the royalties array, which is needed to execute the mint function. This tuple is made up of two variables, fees.recipient and fees.value : fees.recipient \u2014 refers to either the item owner (by default) or an address where the royalties will be received. fees.value \u2014 the royalties percentage. By default, this value is 1000 on Rarible, which is a 10% royalties fee. This is done using basis points. More information regarding basis point can be found here.","title":"Tokens, Fees and Royalties"},{"location":"overview/tokens-fees-royalties/#tokens-fees-and-royalties","text":"","title":"Tokens, Fees, and Royalties"},{"location":"overview/tokens-fees-royalties/#what-is-nft","text":"NFT means Non-Fungible Token. \u201cNon-fungible\u201d more or less means that it\u2019s unique and can\u2019t be replaced with something else. For example, a bitcoin is fungible \u2014 trade one for another bitcoin, and you\u2019ll have exactly the same thing. NFTs on the other hand are one-of-a-kind tokens that represent a unique good or asset which are non-fungible. If you traded it for a different NFT, you\u2019d have something completely different. NFTs can really be anything digital (such as drawings, music, videos, etc.), but a lot of the current excitement is around using the tech to sell digital art.","title":"What is NFT"},{"location":"overview/tokens-fees-royalties/#tokens","text":"Rarible Multichain Protocol various token types applicable for certain blockchain: Ethereum/Polygon: ERC-721 ERC-1155 Rarible user-owned contracts (ERC-721 and ERC-1155) \u2014 users deploy these contracts, only owners can mint in these Flow standard tokens FA2 (TZIP-012) for Tezos Cryptopunks A full list of supported token types could be found on Features page. All these contracts support these features: lazy mint Rarible on-chain royalties multiple creators upgradeable supports operators (who can transfer tokens on behalf of users) for the whole smart contract User-owned contracts use beacon proxies, and these contracts can be updated by Rarible DAO. Rarible common contracts can be upgraded too.","title":"Tokens"},{"location":"overview/tokens-fees-royalties/#fees","text":"Rarible Multichain Protocol supports the following types of fees that are applicable to token operations: Protocol fees \u2014 are charged on both sides of the transaction Origin fees \u2014 set for each order. It may differ for two orders Royalties \u2014 the author of the work will receive a part of each sale Here is an example, how do we calculate fees for Ethereum for each side of the transaction: If there is ETH on any side of the transaction, it is used If there is no ETH, we check if there is an ERC-20 and use it If there is no ERC-20, check if there is an ERC-1155 and use it Otherwise, no fee will be charged. (e.g., if two ERC-721 are involved in the transaction) When computing the total amount of the asset: The protocol fee is added on top of the filled amount The fee for sending the buyer's order is also added on top If the buyer uses the ERC-20 token for payment, he must approve the calculated number of tokens. If the buyer uses ETH, they must send the calculated amount to ETH along with the transaction.","title":"Fees"},{"location":"overview/tokens-fees-royalties/#royalties","text":"Rarible Multichain Protocol supports two types of royalties: RoyaltiesV1 \u2014 defines an interface to query royalties from a contract. This is implemented on the standard Rarible token contracts. RoyaltiesV2 \u2014 the exchange contract interacts with the Rarible royalties implementation indirectly through a Royalty Registry. The registry checks if the NFT contract supports the expected interface, and if so, queries for the Rarible royalties array. EIP-2981 \u2014 allows contracts, such as NFTs that support ERC-721 and ERC-1155 interfaces, to signal a royalty amount to be paid to the NFT creator or rights holder every time the NFT is sold or re-sold. This is intended for NFT marketplaces that want to support the ongoing funding of artists and other NFT creators. For RoyaltiesV1, contract exposes getRoyalties method, which expects an ID as input (usually tokenId) and returns an array of accounts & basis points. RoyaltiesV2 allows for Rarible to support different royalty standards for different collections. Rarible Multichain Protocol Supports on-chain royalties. These are handled in the ExchangeV1 contract by the royalties array, which is needed to execute the mint function. This tuple is made up of two variables, fees.recipient and fees.value : fees.recipient \u2014 refers to either the item owner (by default) or an address where the royalties will be received. fees.value \u2014 the royalties percentage. By default, this value is 1000 on Rarible, which is a 10% royalties fee. This is done using basis points. More information regarding basis point can be found here.","title":"Royalties"},{"location":"reference/bid/","text":"Create and Accept Bid \u00b6 You can Create and Accept Bids with Rarible Multichain Protocol in different blockchains. Before start, install and configure Rarible SDK and required wallets . Create a bid \u00b6 You can place your bid for any given NFT, even if there isn't any sell offer associated with it. It's up to the owner if they accept it or not. Use bid function: import { createRaribleSdk } from \"@rarible/sdk\" import { toItemId } from \"@rarible/types\" import type { BlockchainWallet } from \"@rarible/sdk-wallet/src\" import type { RequestCurrency } from \"@rarible/sdk/build/common/domain\" async function bid ( wallet : BlockchainWallet , assetType : RequestCurrency ) { const sdk = createRaribleSdk ( wallet , \"dev\" ) const bidAction = await sdk . order . bid ({ itemId : toItemId ( \"<ITEM_ID>\" ), }) const bidOrderId = await bidAction . submit ({ amount : 1 , price : \"0.000002\" , currency : assetType , }) return bidOrderId } itemId \u2014 Id of your NFT, has format ${blockchain}:${token}:${tokenId} . For example, ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:12345 amount \u2014 amount of NFT tokens price \u2014 price per 1 NFT in ETH currency \u2014 currency (ETH or specific ERC20 or Tez, Flow, etc.) Bid on collection \u00b6 For create bid on collection, use bidOnCollection function: import { createRaribleSdk } from \"@rarible/sdk\" import { toContractAddress , toItemId } from \"@rarible/types\" import type { BlockchainWallet } from \"@rarible/sdk-wallet/src\" import type { RequestCurrency } from \"@rarible/sdk/build/common/domain\" //Available only for ethereum async function bidOnCollection ( wallet : BlockchainWallet , assetType : RequestCurrency ) { const sdk = createRaribleSdk ( wallet , \"dev\" ) const bidAction = await sdk . order . bid ({ collectionId : toContractAddress ( \"<COLLECTION_ADDRESS>\" ), }) const bidOrderId = await bidAction . submit ({ amount : 1 , price : \"0.000002\" , currency : assetType , //+1 hour (optional) expirationDate : new Date ( Date . now () + 60 * 60 * 1000 ), }) return bidOrderId } collectionId \u2014 your collection address, that can be already deployed . Also, can be the address of Rarible Smart Contracts instance. You can find them on Contract Addresses page ContractAddress \u2014 BlockchainName:HexAddress = ETHEREUM:0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05 BlockchainName \u2014 ETHEREUM , FLOW , TEZOS or POLYGON Update bid \u00b6 Similarly to updating a sell order, there is also a possibility to update a bid. It can be only higher than the original bid order price. Use bid function with updateAction : import { createRaribleSdk } from \"@rarible/sdk\" import { toItemId } from \"@rarible/types\" import type { BlockchainWallet } from \"@rarible/sdk-wallet/src\" import type { RequestCurrency } from \"@rarible/sdk/build/common/domain\" async function bid ( wallet : BlockchainWallet , assetType : RequestCurrency ) { const sdk = createRaribleSdk ( wallet , \"dev\" ) const bidAction = await sdk . order . bid ({ itemId : toItemId ( \"<ITEM_ID>\" ), }) const bidOrderId = await bidAction . submit ({ amount : 1 , price : \"0.000002\" , currency : assetType , }) const updateAction = await sdk . order . bidUpdate ({ orderId : bidOrderId , }) //You can only increase price of bid order for security reasons //If you want to force change bid price you should cancel order await updateAction . submit ({ price : \"0.000003\" }) } Accept bid \u00b6 To accept bid, use acceptBid function: import { createRaribleSdk } from \"@rarible/sdk\" import { toOrderId , toUnionAddress } from \"@rarible/types\" import type { BlockchainWallet } from \"@rarible/sdk-wallet/src\" async function acceptBid ( wallet : BlockchainWallet ) { const sdk = createRaribleSdk ( wallet , \"dev\" ) const acceptBidResponse = await sdk . order . acceptBid ({ orderId : toOrderId ( \"<BIDDER_ORDER_ID>\" ), }) const acceptBidResult = await acceptBidResponse . submit ({ amount : 1 , //optional originFees : [{ account : toUnionAddress ( \"<COMISSION_ADDRESS>\" ), //2,5% value : 250 , }], //optional payouts : [{ account : toUnionAddress ( \"<PAYOUT_ADDRESS>\" ), //5% value : 500 , }], //Set true if you want to convert received WETH/wTEZ tokens to ETH/TEZ unwrap : false , }) await acceptBidResult . wait () } originFees \u2014 value and address of the origin fees for the order account \u2014 address in Union format ${blockchainGroup}:${token} . For example, TEZOS:tz1dKxdpV1hgErMTTKBorb8R5tSz8hFzPhKh value \u2014 value of the fees. For example, 2,5% value is 250 payouts \u2014 value and address of the payouts for the order account \u2014 address in Union format ${blockchainGroup}:${token} . For example, TEZOS:tz1dKxdpV1hgErMTTKBorb8R5tSz8hFzPhKh value \u2014 value of the payouts. For example, 5% value is 500 unwrap \u2014 convert (true) received WETH/wTEZ tokens to ETH/TEZ or not (false) Accept bid on collection \u00b6 To accept bid on collection, use acceptBidOnCollection function: import { createRaribleSdk } from \"@rarible/sdk\" import { toItemId , toOrderId } from \"@rarible/types\" import type { BlockchainWallet } from \"@rarible/sdk-wallet/src\" //Available only for ethereum async function acceptBidOnCollection ( wallet : BlockchainWallet ) { const sdk = createRaribleSdk ( wallet , \"dev\" ) const acceptBidAction = await sdk . order . acceptBid ({ orderId : toOrderId ( \"<COLLECTION_ORDER_ID>\" ), }) //If you have one or more items from collection you should accept one item at the time const acceptBidTx = await acceptBidAction . submit ({ amount : 1 , itemId : toItemId ( \"<ACCEPTED_ITEM_ID>\" ), //Set true if you want to convert received WETH/wTEZ tokens to ETH/TEZ unwrap : false , }) await acceptBidTx . wait () } Cancel a bid \u00b6 To cancel a bid, use cancelOrder function: import { createRaribleSdk } from \"@rarible/sdk\" import { toOrderId } from \"@rarible/types\" import type { BlockchainWallet } from \"@rarible/sdk-wallet/src\" async function cancelOrder ( wallet : BlockchainWallet ) { const sdk = createRaribleSdk ( wallet , \"dev\" ) const cancelTx = await sdk . order . cancel ({ orderId : toOrderId ( \"<YOUR_ORDER_ID>\" ), }) await cancelTx . wait () } orderId \u2014 Id of your order, has format ${blockchain}:${id} . For example, ETHEREUM:1234567890 Checking created bid \u00b6 To check the created bid use the getAuctionBidsById API method getAuctionBidsById Returns Bids by ID. https://api.rarible.org/v0.1/auctions/{id}/bids Example request (staging) curl --request GET 'https://api-staging.rarible.org/v0.1/orders/bids/byItem?itemId=ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:18821466700545955594683918922933102928122274620066857937800231922729025011855&status=ACTIVE' Request parameters: itemId \u2014 ItemID of your NFT, has format ${blockchain}:${token}:${tokenId} For example, ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:12345 Example response (status 200) { \"orders\" : [ { \"id\" : \"ETHEREUM:0xce5a4beadeddeefdd91dad3092315fbba176dd5325e032dd10194a9bc60bf28c\" , \"fill\" : \"0\" , \"platform\" : \"RARIBLE\" , \"status\" : \"ACTIVE\" , \"makeStock\" : \"0.12345\" , \"cancelled\" : false , \"createdAt\" : \"2022-03-07T06:46:06.275Z\" , \"lastUpdatedAt\" : \"2022-03-07T06:46:06.275Z\" , \"takePrice\" : \"0.12345\" , \"takePriceUsd\" : \"0.12342413889756425082\" , \"priceHistory\" : [], \"maker\" : \"ETHEREUM:0x45d5ef37dfa2a3cc91d5909fd493f1a480bba6b0\" , \"make\" : { \"type\" : { \"@type\" : \"ERC20\" , \"contract\" : \"ETHEREUM:0x5592ec0cfb4dbc12d3ab100b257153436a1f0fea\" }, \"value\" : \"0.12345\" }, \"take\" : { \"type\" : { \"@type\" : \"ERC721_Lazy\" , \"contract\" : \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82\" , \"tokenId\" : \"18821466700545955594683918922933102928122274620066857937800231922729025011855\" , \"uri\" : \"/ipfs/QmcTxYXrcoHzi5EyoypK6PvCQxy8piZiYpFKjr75MRKp89\" , \"creators\" : [ { \"account\" : \"ETHEREUM:0x299c92988198a5965111537797cc1789a5d7e336\" , \"value\" : 10000 } ], \"royalties\" : [ { \"account\" : \"ETHEREUM:0x299c92988198a5965111537797cc1789a5d7e336\" , \"value\" : 1000 } ], \"signatures\" : [ \"0xee5416f619e2efefbcf4a3cc8645ff61c298ada42a5c9c07e5ce3ed66444a937010daab240392eabad2b8e4bc95f527178c377937c25a655991532a3b2ffa9361c\" ] }, \"value\" : \"1\" }, \"salt\" : \"0x24d4f84a848a4c49df39d73961b887958598046384639c09f61d4dd85f6c5f1e\" , \"signature\" : \"0x928e0d53da390ea7e58f2d5715d0492ad4dd4cae7a7126759682b642c32e3caf7395edeb8342ebf5fc57d959c996b41079e391565cc00b5966aac7f1788bc2d11c\" , \"data\" : { \"@type\" : \"ETH_RARIBLE_V2\" , \"payouts\" : [], \"originFees\" : [ { \"account\" : \"ETHEREUM:0x76c5855e93bd498b6331652854c4549d34bc3a30\" , \"value\" : 250 } ] } } ] } See more information about usage Protocol SDK on https://github.com/rarible/sdk","title":"Create and Accept Bid"},{"location":"reference/bid/#create-and-accept-bid","text":"You can Create and Accept Bids with Rarible Multichain Protocol in different blockchains. Before start, install and configure Rarible SDK and required wallets .","title":"Create and Accept Bid"},{"location":"reference/bid/#create-a-bid","text":"You can place your bid for any given NFT, even if there isn't any sell offer associated with it. It's up to the owner if they accept it or not. Use bid function: import { createRaribleSdk } from \"@rarible/sdk\" import { toItemId } from \"@rarible/types\" import type { BlockchainWallet } from \"@rarible/sdk-wallet/src\" import type { RequestCurrency } from \"@rarible/sdk/build/common/domain\" async function bid ( wallet : BlockchainWallet , assetType : RequestCurrency ) { const sdk = createRaribleSdk ( wallet , \"dev\" ) const bidAction = await sdk . order . bid ({ itemId : toItemId ( \"<ITEM_ID>\" ), }) const bidOrderId = await bidAction . submit ({ amount : 1 , price : \"0.000002\" , currency : assetType , }) return bidOrderId } itemId \u2014 Id of your NFT, has format ${blockchain}:${token}:${tokenId} . For example, ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:12345 amount \u2014 amount of NFT tokens price \u2014 price per 1 NFT in ETH currency \u2014 currency (ETH or specific ERC20 or Tez, Flow, etc.)","title":"Create a bid"},{"location":"reference/bid/#bid-on-collection","text":"For create bid on collection, use bidOnCollection function: import { createRaribleSdk } from \"@rarible/sdk\" import { toContractAddress , toItemId } from \"@rarible/types\" import type { BlockchainWallet } from \"@rarible/sdk-wallet/src\" import type { RequestCurrency } from \"@rarible/sdk/build/common/domain\" //Available only for ethereum async function bidOnCollection ( wallet : BlockchainWallet , assetType : RequestCurrency ) { const sdk = createRaribleSdk ( wallet , \"dev\" ) const bidAction = await sdk . order . bid ({ collectionId : toContractAddress ( \"<COLLECTION_ADDRESS>\" ), }) const bidOrderId = await bidAction . submit ({ amount : 1 , price : \"0.000002\" , currency : assetType , //+1 hour (optional) expirationDate : new Date ( Date . now () + 60 * 60 * 1000 ), }) return bidOrderId } collectionId \u2014 your collection address, that can be already deployed . Also, can be the address of Rarible Smart Contracts instance. You can find them on Contract Addresses page ContractAddress \u2014 BlockchainName:HexAddress = ETHEREUM:0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05 BlockchainName \u2014 ETHEREUM , FLOW , TEZOS or POLYGON","title":"Bid on collection"},{"location":"reference/bid/#update-bid","text":"Similarly to updating a sell order, there is also a possibility to update a bid. It can be only higher than the original bid order price. Use bid function with updateAction : import { createRaribleSdk } from \"@rarible/sdk\" import { toItemId } from \"@rarible/types\" import type { BlockchainWallet } from \"@rarible/sdk-wallet/src\" import type { RequestCurrency } from \"@rarible/sdk/build/common/domain\" async function bid ( wallet : BlockchainWallet , assetType : RequestCurrency ) { const sdk = createRaribleSdk ( wallet , \"dev\" ) const bidAction = await sdk . order . bid ({ itemId : toItemId ( \"<ITEM_ID>\" ), }) const bidOrderId = await bidAction . submit ({ amount : 1 , price : \"0.000002\" , currency : assetType , }) const updateAction = await sdk . order . bidUpdate ({ orderId : bidOrderId , }) //You can only increase price of bid order for security reasons //If you want to force change bid price you should cancel order await updateAction . submit ({ price : \"0.000003\" }) }","title":"Update bid"},{"location":"reference/bid/#accept-bid","text":"To accept bid, use acceptBid function: import { createRaribleSdk } from \"@rarible/sdk\" import { toOrderId , toUnionAddress } from \"@rarible/types\" import type { BlockchainWallet } from \"@rarible/sdk-wallet/src\" async function acceptBid ( wallet : BlockchainWallet ) { const sdk = createRaribleSdk ( wallet , \"dev\" ) const acceptBidResponse = await sdk . order . acceptBid ({ orderId : toOrderId ( \"<BIDDER_ORDER_ID>\" ), }) const acceptBidResult = await acceptBidResponse . submit ({ amount : 1 , //optional originFees : [{ account : toUnionAddress ( \"<COMISSION_ADDRESS>\" ), //2,5% value : 250 , }], //optional payouts : [{ account : toUnionAddress ( \"<PAYOUT_ADDRESS>\" ), //5% value : 500 , }], //Set true if you want to convert received WETH/wTEZ tokens to ETH/TEZ unwrap : false , }) await acceptBidResult . wait () } originFees \u2014 value and address of the origin fees for the order account \u2014 address in Union format ${blockchainGroup}:${token} . For example, TEZOS:tz1dKxdpV1hgErMTTKBorb8R5tSz8hFzPhKh value \u2014 value of the fees. For example, 2,5% value is 250 payouts \u2014 value and address of the payouts for the order account \u2014 address in Union format ${blockchainGroup}:${token} . For example, TEZOS:tz1dKxdpV1hgErMTTKBorb8R5tSz8hFzPhKh value \u2014 value of the payouts. For example, 5% value is 500 unwrap \u2014 convert (true) received WETH/wTEZ tokens to ETH/TEZ or not (false)","title":"Accept bid"},{"location":"reference/bid/#accept-bid-on-collection","text":"To accept bid on collection, use acceptBidOnCollection function: import { createRaribleSdk } from \"@rarible/sdk\" import { toItemId , toOrderId } from \"@rarible/types\" import type { BlockchainWallet } from \"@rarible/sdk-wallet/src\" //Available only for ethereum async function acceptBidOnCollection ( wallet : BlockchainWallet ) { const sdk = createRaribleSdk ( wallet , \"dev\" ) const acceptBidAction = await sdk . order . acceptBid ({ orderId : toOrderId ( \"<COLLECTION_ORDER_ID>\" ), }) //If you have one or more items from collection you should accept one item at the time const acceptBidTx = await acceptBidAction . submit ({ amount : 1 , itemId : toItemId ( \"<ACCEPTED_ITEM_ID>\" ), //Set true if you want to convert received WETH/wTEZ tokens to ETH/TEZ unwrap : false , }) await acceptBidTx . wait () }","title":"Accept bid on collection"},{"location":"reference/bid/#cancel-a-bid","text":"To cancel a bid, use cancelOrder function: import { createRaribleSdk } from \"@rarible/sdk\" import { toOrderId } from \"@rarible/types\" import type { BlockchainWallet } from \"@rarible/sdk-wallet/src\" async function cancelOrder ( wallet : BlockchainWallet ) { const sdk = createRaribleSdk ( wallet , \"dev\" ) const cancelTx = await sdk . order . cancel ({ orderId : toOrderId ( \"<YOUR_ORDER_ID>\" ), }) await cancelTx . wait () } orderId \u2014 Id of your order, has format ${blockchain}:${id} . For example, ETHEREUM:1234567890","title":"Cancel a bid"},{"location":"reference/bid/#checking-created-bid","text":"To check the created bid use the getAuctionBidsById API method getAuctionBidsById Returns Bids by ID. https://api.rarible.org/v0.1/auctions/{id}/bids Example request (staging) curl --request GET 'https://api-staging.rarible.org/v0.1/orders/bids/byItem?itemId=ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:18821466700545955594683918922933102928122274620066857937800231922729025011855&status=ACTIVE' Request parameters: itemId \u2014 ItemID of your NFT, has format ${blockchain}:${token}:${tokenId} For example, ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:12345 Example response (status 200) { \"orders\" : [ { \"id\" : \"ETHEREUM:0xce5a4beadeddeefdd91dad3092315fbba176dd5325e032dd10194a9bc60bf28c\" , \"fill\" : \"0\" , \"platform\" : \"RARIBLE\" , \"status\" : \"ACTIVE\" , \"makeStock\" : \"0.12345\" , \"cancelled\" : false , \"createdAt\" : \"2022-03-07T06:46:06.275Z\" , \"lastUpdatedAt\" : \"2022-03-07T06:46:06.275Z\" , \"takePrice\" : \"0.12345\" , \"takePriceUsd\" : \"0.12342413889756425082\" , \"priceHistory\" : [], \"maker\" : \"ETHEREUM:0x45d5ef37dfa2a3cc91d5909fd493f1a480bba6b0\" , \"make\" : { \"type\" : { \"@type\" : \"ERC20\" , \"contract\" : \"ETHEREUM:0x5592ec0cfb4dbc12d3ab100b257153436a1f0fea\" }, \"value\" : \"0.12345\" }, \"take\" : { \"type\" : { \"@type\" : \"ERC721_Lazy\" , \"contract\" : \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82\" , \"tokenId\" : \"18821466700545955594683918922933102928122274620066857937800231922729025011855\" , \"uri\" : \"/ipfs/QmcTxYXrcoHzi5EyoypK6PvCQxy8piZiYpFKjr75MRKp89\" , \"creators\" : [ { \"account\" : \"ETHEREUM:0x299c92988198a5965111537797cc1789a5d7e336\" , \"value\" : 10000 } ], \"royalties\" : [ { \"account\" : \"ETHEREUM:0x299c92988198a5965111537797cc1789a5d7e336\" , \"value\" : 1000 } ], \"signatures\" : [ \"0xee5416f619e2efefbcf4a3cc8645ff61c298ada42a5c9c07e5ce3ed66444a937010daab240392eabad2b8e4bc95f527178c377937c25a655991532a3b2ffa9361c\" ] }, \"value\" : \"1\" }, \"salt\" : \"0x24d4f84a848a4c49df39d73961b887958598046384639c09f61d4dd85f6c5f1e\" , \"signature\" : \"0x928e0d53da390ea7e58f2d5715d0492ad4dd4cae7a7126759682b642c32e3caf7395edeb8342ebf5fc57d959c996b41079e391565cc00b5966aac7f1788bc2d11c\" , \"data\" : { \"@type\" : \"ETH_RARIBLE_V2\" , \"payouts\" : [], \"originFees\" : [ { \"account\" : \"ETHEREUM:0x76c5855e93bd498b6331652854c4549d34bc3a30\" , \"value\" : 250 } ] } } ] } See more information about usage Protocol SDK on https://github.com/rarible/sdk","title":"Checking created bid"},{"location":"reference/burn/","text":"Burn \u00b6 You can burn NFTs with Rarible Multichain Protocol in different blockchains. Before start, install and configure Rarible SDK and required wallets . Burn NFTs \u00b6 Burning tokens is equivalent to sending them to address 0x0 because nobody has a private key for that. Use burn function: import { createRaribleSdk } from \"@rarible/sdk\" import { toItemId , toUnionAddress } from \"@rarible/types\" import type { BlockchainWallet } from \"@rarible/sdk-wallet/src\" async function burn ( wallet : BlockchainWallet ) { const sdk = createRaribleSdk ( wallet , \"dev\" ) const burnAction = await sdk . nft . burn ({ itemId : toItemId ( \"<ITEM_ID>\" ), }) const burnTx = await burnAction . submit ({ amount : 1 , //optional creators : [{ account : toUnionAddress ( \"<CREATOR_ADDRESS>\" ), value : 10000 , }], }) //transaction returned if item is on-chain if ( burnTx ) { await burnTx . wait () } } itemId \u2014 Id of your NFT, has format ${blockchain}:${token}:${tokenId} . For example, ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:12345 amount \u2014 amount of NFT tokens creators \u2014 value and address of the creator account \u2014 address in Union format ${blockchainGroup}:${token} . For example, TEZOS:tz1dKxdpV1hgErMTTKBorb8R5tSz8hFzPhKh value \u2014 value of the part in the ownership of the item. For example, 100% value is 10000 . If there are several owners, the total cost cannot be more than 10000 Checking burned NFT \u00b6 To check the burned item: Use the getItemById API method getItemById Returns Item by ID. https://api.rarible.org/v0.1/items/{itemId} Example request (staging) curl --request GET 'https://api-staging.rarible.org/v0.1/items/ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:19661880631107248865491477079747186145992059189823053172927066273904580362243' Request parameters: itemId \u2014 ItemID of your NFT, has format ${blockchain}:${token}:${tokenId} For example, ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:12345 Example response (status 200) { \"id\" : \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:19661880631107248865491477079747186145992059189823053172927066273904580362243\" , \"blockchain\" : \"ETHEREUM\" , \"collection\" : \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82\" , \"contract\" : \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82\" , \"tokenId\" : \"19661880631107248865491477079747186145992059189823053172927066273904580362243\" , \"creators\" : [ { \"account\" : \"ETHEREUM:0x2b783ae5b5b8a7a822449c7d8b6f35f9abc827f5\" , \"value\" : 10000 } ], \"owners\" : [], \"royalties\" : [], \"lazySupply\" : \"0\" , \"pending\" : [], \"mintedAt\" : \"2022-03-09T22:48:33Z\" , \"lastUpdatedAt\" : \"2022-03-09T22:50:03.530Z\" , \"supply\" : \"1\" , \"meta\" : { \"name\" : \"gbgbgbgbgbgb\" , \"description\" : \"\" , \"attributes\" : [], \"content\" : [ { \"@type\" : \"IMAGE\" , \"url\" : \"https://rarible.mypinata.cloud/ipfs/QmQCp8bhbaPwGEuHeeR8pme2q3zuSjam2JEuFgAvp4DZsU/image.jpeg\" , \"representation\" : \"ORIGINAL\" , \"mimeType\" : \"image/jpeg\" , \"size\" : 13311 , \"width\" : 640 , \"height\" : 640 } ], \"restrictions\" : [] }, \"deleted\" : false , \"auctions\" : [], \"totalStock\" : \"0\" , \"sellers\" : 0 } Or check Etherscan for Ethereum and Polygon, Flowscan for Flow, or tezblock for Tezos. See more information about usage Protocol SDK on https://github.com/rarible/sdk","title":"Burn"},{"location":"reference/burn/#burn","text":"You can burn NFTs with Rarible Multichain Protocol in different blockchains. Before start, install and configure Rarible SDK and required wallets .","title":"Burn"},{"location":"reference/burn/#burn-nfts","text":"Burning tokens is equivalent to sending them to address 0x0 because nobody has a private key for that. Use burn function: import { createRaribleSdk } from \"@rarible/sdk\" import { toItemId , toUnionAddress } from \"@rarible/types\" import type { BlockchainWallet } from \"@rarible/sdk-wallet/src\" async function burn ( wallet : BlockchainWallet ) { const sdk = createRaribleSdk ( wallet , \"dev\" ) const burnAction = await sdk . nft . burn ({ itemId : toItemId ( \"<ITEM_ID>\" ), }) const burnTx = await burnAction . submit ({ amount : 1 , //optional creators : [{ account : toUnionAddress ( \"<CREATOR_ADDRESS>\" ), value : 10000 , }], }) //transaction returned if item is on-chain if ( burnTx ) { await burnTx . wait () } } itemId \u2014 Id of your NFT, has format ${blockchain}:${token}:${tokenId} . For example, ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:12345 amount \u2014 amount of NFT tokens creators \u2014 value and address of the creator account \u2014 address in Union format ${blockchainGroup}:${token} . For example, TEZOS:tz1dKxdpV1hgErMTTKBorb8R5tSz8hFzPhKh value \u2014 value of the part in the ownership of the item. For example, 100% value is 10000 . If there are several owners, the total cost cannot be more than 10000","title":"Burn NFTs"},{"location":"reference/burn/#checking-burned-nft","text":"To check the burned item: Use the getItemById API method getItemById Returns Item by ID. https://api.rarible.org/v0.1/items/{itemId} Example request (staging) curl --request GET 'https://api-staging.rarible.org/v0.1/items/ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:19661880631107248865491477079747186145992059189823053172927066273904580362243' Request parameters: itemId \u2014 ItemID of your NFT, has format ${blockchain}:${token}:${tokenId} For example, ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:12345 Example response (status 200) { \"id\" : \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:19661880631107248865491477079747186145992059189823053172927066273904580362243\" , \"blockchain\" : \"ETHEREUM\" , \"collection\" : \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82\" , \"contract\" : \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82\" , \"tokenId\" : \"19661880631107248865491477079747186145992059189823053172927066273904580362243\" , \"creators\" : [ { \"account\" : \"ETHEREUM:0x2b783ae5b5b8a7a822449c7d8b6f35f9abc827f5\" , \"value\" : 10000 } ], \"owners\" : [], \"royalties\" : [], \"lazySupply\" : \"0\" , \"pending\" : [], \"mintedAt\" : \"2022-03-09T22:48:33Z\" , \"lastUpdatedAt\" : \"2022-03-09T22:50:03.530Z\" , \"supply\" : \"1\" , \"meta\" : { \"name\" : \"gbgbgbgbgbgb\" , \"description\" : \"\" , \"attributes\" : [], \"content\" : [ { \"@type\" : \"IMAGE\" , \"url\" : \"https://rarible.mypinata.cloud/ipfs/QmQCp8bhbaPwGEuHeeR8pme2q3zuSjam2JEuFgAvp4DZsU/image.jpeg\" , \"representation\" : \"ORIGINAL\" , \"mimeType\" : \"image/jpeg\" , \"size\" : 13311 , \"width\" : 640 , \"height\" : 640 } ], \"restrictions\" : [] }, \"deleted\" : false , \"auctions\" : [], \"totalStock\" : \"0\" , \"sellers\" : 0 } Or check Etherscan for Ethereum and Polygon, Flowscan for Flow, or tezblock for Tezos. See more information about usage Protocol SDK on https://github.com/rarible/sdk","title":"Checking burned NFT"},{"location":"reference/contract-addresses/","text":"Contract Addresses \u00b6 Here you can find Rarible Smart Contracts deployed instances across Mainnet, Testnet and Development. Mainnet \u00b6 Contract Addresses Mainnet Ethereum Asset Contract ERC-721 0xF6793dA657495ffeFF9Ee6350824910Abc21356C Asset Contract ERC-1155 0xB66a603f4cFe17e3D27B87a8BfCaD319856518B8 Exchange Contract 0x9757F2d2b135150BBeb65308D4a91804107cd8D6 External Royalties 0xEa90CFad1b8e030B8Fd3E63D22074E0AEb8E0DCD NFT Transfer Proxy (for Approvals) 0x4fee7b061c97c9c496b01dbce9cdb10c02f0a0be ERC-721 Token Factory 0x6E42262978de5233C8d5B05B128C121fBa110DA4 ERC-1155 Token Factory 0xDA5BFe0bD4443d63833C8f4E3284357299eaE6BC Flow RaribleNFT A.01ab36aaf654a13e.RaribleNFT RaribleOrder A.01ab36aaf654a13e.RaribleOrder RaribleFee A.336405ad2f289b87.RaribleFee LicensedNFT A.01ab36aaf654a13e.LicensedNFT Tezos Rarible public collection KT18pVpRXKPY2c4U2yFEGSH3ZnhB2kL8kwXS royalties KT1HNNrmCk1fpqveRDz8Fvww2GM4gPzmA7fo transfer_proxy KT1N2oby9tYmv5tjkGD1KyVzkDRCmgDkXgSD transfer_manager KT1HTmwHGvxYgACDr1oJhMNZGzxHCAnNHaHi fill KT1D2fZiUNo6RPj3zKofH8DqDDgoV7KoyEbb exchange KT198mqFKkiWerXLmMCw69YB1i6yzYtmGVrC Polygon Exchange 0x835131b455778559CFdDd358eA3Fc762728F4E3e Transfer Proxies 0xd47e14DD9b98411754f722B4c4074e14752Ada7C ERC-721 Token Factory 0x16911a36a56f828f17632cD4915614Dd5c7a45e0 ERC-1155 Token Factory 0xF46e8e6fA0F048DdD76F8c6982eBD059796298B8 Testnet \u00b6 Contract Addresses Testnet (Rinkeby, Mumbai) Ethereum Asset Contract ERC-721 0x6ede7f3c26975aad32a475e1021d8f6f39c89d82 Asset Contract ERC-1155 0x1AF7A7555263F275433c6Bb0b8FdCD231F89B1D7 Exchange Contract 0xd4a57a3bD3657D0d46B4C5bAC12b3F156B9B886b External Royalties 0xdA8e7D4cF7BA4D5912a68c1e40d3D89828fA6EE8 NFT Transfer Proxy (for Approvals) 0x7d47126a2600E22eab9eD6CF0e515678727779A6 ERC-721 Token Factory 0x62e0BDC23435321adFf249d6f41e11AEee6486Cf ERC-1155 Token Factory 0xB1Bcf905495AFf06e854904d7b2d6647ab00Cd1d Flow RaribleNFT A.ebf4ae01d1284af8.RaribleNFT RaribleOrder A.ebf4ae01d1284af8.RaribleOrder RaribleFee A.ebf4ae01d1284af8.RaribleFee LicensedNFT A.ebf4ae01d1284af8.LicensedNFT Polygon Exchange 0x4F05968D804902dd827Dd0F4fB37Ccc3071C4Bb5 Transfer Proxies 0x02e21199D043dab90248f79d6A8d0c36832734B0 ERC-721 Token Factory 0xa85180a21786bA65b0778bE1cb5CBA5E5c6cD21d ERC-1155 Token Factory 0xAa9CD5834E0009902EeAA3FEfAc6A160e9A096b4 Development \u00b6 Contract Addresses Development (Ropsten, Mumbai, Ithaca) Ethereum Asset Contract ERC-721 0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05 Asset Contract ERC-1155 0x6a94aC200342AC823F909F142a65232E2f052183 Exchange Contract 0x33Aef288C093Bf7b36fBe15c3190e616a993b0AD External Royalties 0x1747757768Ff4AA61390B1ed3AA019141605717B NFT Transfer Proxy (for Approvals) 0xf8e4ecac18b65fd04569ff1f0d561f74effaa206 ERC-721 Token Factory 0x939d0308CE4274C287E7305D381B336B77dBfcd3 ERC-1155 Token Factory 0xccf0cB91Fe5cCb697781427C141ed0662aE4FE2e Flow RaribleNFT A.ebf4ae01d1284af8.RaribleNFT RaribleOrder A.ebf4ae01d1284af8.RaribleOrder RaribleFee A.ebf4ae01d1284af8.RaribleFee LicensedNFT A.ebf4ae01d1284af8.LicensedNFT Tezos royalties KT1AZfqFGFLMUrscNFyawDYAyqXYydz714ya transfer_proxy KT1WbVjXdmBpzzVoYSSUiNt6QFnSC3W768d1 transfer_manager KT1L1WfmvjQRTRqT8Zv4qey4vdZbyML43UT4 fill KT1JtTi6qP5jxks3S12Uq28etuhgJCQ4tXtP exchange KT1S6H2FWxrpaD7aPRSW1cTTE1xPucXBSTL5 nft KT1ANmrMfq6SfPe2b59JGVu2CDacoaoL6hW8 Polygon Exchange 0x4F05968D804902dd827Dd0F4fB37Ccc3071C4Bb5 Transfer Proxies 0x02e21199D043dab90248f79d6A8d0c36832734B0 ERC-721 Token Factory 0xa85180a21786bA65b0778bE1cb5CBA5E5c6cD21d ERC-1155 Token Factory 0xAa9CD5834E0009902EeAA3FEfAc6A160e9A096b4 Solana \u00b6 Contract Addresses All networks SPL_TOKEN_PROGRAM TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA TOKEN_METADATA_PROGRAM metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s AUCTION_HOUSE_PROGRAM hausS13jsjafwWwGqZTUQRmWyvyxn9EQpqMwV1PBBmk","title":"Contract Addresses"},{"location":"reference/contract-addresses/#contract-addresses","text":"Here you can find Rarible Smart Contracts deployed instances across Mainnet, Testnet and Development.","title":"Contract Addresses"},{"location":"reference/contract-addresses/#mainnet","text":"Contract Addresses Mainnet Ethereum Asset Contract ERC-721 0xF6793dA657495ffeFF9Ee6350824910Abc21356C Asset Contract ERC-1155 0xB66a603f4cFe17e3D27B87a8BfCaD319856518B8 Exchange Contract 0x9757F2d2b135150BBeb65308D4a91804107cd8D6 External Royalties 0xEa90CFad1b8e030B8Fd3E63D22074E0AEb8E0DCD NFT Transfer Proxy (for Approvals) 0x4fee7b061c97c9c496b01dbce9cdb10c02f0a0be ERC-721 Token Factory 0x6E42262978de5233C8d5B05B128C121fBa110DA4 ERC-1155 Token Factory 0xDA5BFe0bD4443d63833C8f4E3284357299eaE6BC Flow RaribleNFT A.01ab36aaf654a13e.RaribleNFT RaribleOrder A.01ab36aaf654a13e.RaribleOrder RaribleFee A.336405ad2f289b87.RaribleFee LicensedNFT A.01ab36aaf654a13e.LicensedNFT Tezos Rarible public collection KT18pVpRXKPY2c4U2yFEGSH3ZnhB2kL8kwXS royalties KT1HNNrmCk1fpqveRDz8Fvww2GM4gPzmA7fo transfer_proxy KT1N2oby9tYmv5tjkGD1KyVzkDRCmgDkXgSD transfer_manager KT1HTmwHGvxYgACDr1oJhMNZGzxHCAnNHaHi fill KT1D2fZiUNo6RPj3zKofH8DqDDgoV7KoyEbb exchange KT198mqFKkiWerXLmMCw69YB1i6yzYtmGVrC Polygon Exchange 0x835131b455778559CFdDd358eA3Fc762728F4E3e Transfer Proxies 0xd47e14DD9b98411754f722B4c4074e14752Ada7C ERC-721 Token Factory 0x16911a36a56f828f17632cD4915614Dd5c7a45e0 ERC-1155 Token Factory 0xF46e8e6fA0F048DdD76F8c6982eBD059796298B8","title":"Mainnet"},{"location":"reference/contract-addresses/#testnet","text":"Contract Addresses Testnet (Rinkeby, Mumbai) Ethereum Asset Contract ERC-721 0x6ede7f3c26975aad32a475e1021d8f6f39c89d82 Asset Contract ERC-1155 0x1AF7A7555263F275433c6Bb0b8FdCD231F89B1D7 Exchange Contract 0xd4a57a3bD3657D0d46B4C5bAC12b3F156B9B886b External Royalties 0xdA8e7D4cF7BA4D5912a68c1e40d3D89828fA6EE8 NFT Transfer Proxy (for Approvals) 0x7d47126a2600E22eab9eD6CF0e515678727779A6 ERC-721 Token Factory 0x62e0BDC23435321adFf249d6f41e11AEee6486Cf ERC-1155 Token Factory 0xB1Bcf905495AFf06e854904d7b2d6647ab00Cd1d Flow RaribleNFT A.ebf4ae01d1284af8.RaribleNFT RaribleOrder A.ebf4ae01d1284af8.RaribleOrder RaribleFee A.ebf4ae01d1284af8.RaribleFee LicensedNFT A.ebf4ae01d1284af8.LicensedNFT Polygon Exchange 0x4F05968D804902dd827Dd0F4fB37Ccc3071C4Bb5 Transfer Proxies 0x02e21199D043dab90248f79d6A8d0c36832734B0 ERC-721 Token Factory 0xa85180a21786bA65b0778bE1cb5CBA5E5c6cD21d ERC-1155 Token Factory 0xAa9CD5834E0009902EeAA3FEfAc6A160e9A096b4","title":"Testnet"},{"location":"reference/contract-addresses/#development","text":"Contract Addresses Development (Ropsten, Mumbai, Ithaca) Ethereum Asset Contract ERC-721 0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05 Asset Contract ERC-1155 0x6a94aC200342AC823F909F142a65232E2f052183 Exchange Contract 0x33Aef288C093Bf7b36fBe15c3190e616a993b0AD External Royalties 0x1747757768Ff4AA61390B1ed3AA019141605717B NFT Transfer Proxy (for Approvals) 0xf8e4ecac18b65fd04569ff1f0d561f74effaa206 ERC-721 Token Factory 0x939d0308CE4274C287E7305D381B336B77dBfcd3 ERC-1155 Token Factory 0xccf0cB91Fe5cCb697781427C141ed0662aE4FE2e Flow RaribleNFT A.ebf4ae01d1284af8.RaribleNFT RaribleOrder A.ebf4ae01d1284af8.RaribleOrder RaribleFee A.ebf4ae01d1284af8.RaribleFee LicensedNFT A.ebf4ae01d1284af8.LicensedNFT Tezos royalties KT1AZfqFGFLMUrscNFyawDYAyqXYydz714ya transfer_proxy KT1WbVjXdmBpzzVoYSSUiNt6QFnSC3W768d1 transfer_manager KT1L1WfmvjQRTRqT8Zv4qey4vdZbyML43UT4 fill KT1JtTi6qP5jxks3S12Uq28etuhgJCQ4tXtP exchange KT1S6H2FWxrpaD7aPRSW1cTTE1xPucXBSTL5 nft KT1ANmrMfq6SfPe2b59JGVu2CDacoaoL6hW8 Polygon Exchange 0x4F05968D804902dd827Dd0F4fB37Ccc3071C4Bb5 Transfer Proxies 0x02e21199D043dab90248f79d6A8d0c36832734B0 ERC-721 Token Factory 0xa85180a21786bA65b0778bE1cb5CBA5E5c6cD21d ERC-1155 Token Factory 0xAa9CD5834E0009902EeAA3FEfAc6A160e9A096b4","title":"Development"},{"location":"reference/contract-addresses/#solana","text":"Contract Addresses All networks SPL_TOKEN_PROGRAM TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA TOKEN_METADATA_PROGRAM metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s AUCTION_HOUSE_PROGRAM hausS13jsjafwWwGqZTUQRmWyvyxn9EQpqMwV1PBBmk","title":"Solana"},{"location":"reference/conversion/","text":"Convert to/from wrapped fungible tokens \u00b6 To convert to/from wrapped fungible tokens, for example, ETH to WETH, use sdk.balances.convert function: import { Blockchain } from \"@rarible/api-client\" //Convert 0.1 ETH to 0.1 wETH (Wrapped Ether) const tx = await sdk . balances . convert ( Blockchain . ETHEREUM , true , \"0.1\" ) await tx . wait () //Or unwrap 0.1 wETH to 0.1 ETH const tx = await sdk . balances . convert ( Blockchain . ETHEREUM , false , \"0.1\" ) await tx . wait ()","title":"Conversion"},{"location":"reference/conversion/#convert-tofrom-wrapped-fungible-tokens","text":"To convert to/from wrapped fungible tokens, for example, ETH to WETH, use sdk.balances.convert function: import { Blockchain } from \"@rarible/api-client\" //Convert 0.1 ETH to 0.1 wETH (Wrapped Ether) const tx = await sdk . balances . convert ( Blockchain . ETHEREUM , true , \"0.1\" ) await tx . wait () //Or unwrap 0.1 wETH to 0.1 ETH const tx = await sdk . balances . convert ( Blockchain . ETHEREUM , false , \"0.1\" ) await tx . wait ()","title":"Convert to/from wrapped fungible tokens"},{"location":"reference/create-collection/","text":"Collection \u00b6 You can Create NFT Collection with Rarible Multichain Protocol in different blockchains. Before start, install and configure Rarible SDK and required wallets . Create collection \u00b6 Use createCollection function: import { createRaribleSdk } from \"@rarible/sdk\" import type { BlockchainWallet } from \"@rarible/sdk-wallet/src\" import type { CreateCollectionRequest } from \"@rarible/sdk/src/types/nft/deploy/domain\" async function createCollection ( wallet : BlockchainWallet , collectionRequest : CreateCollectionRequest ) { const sdk = createRaribleSdk ( wallet , \"dev\" ) const result = await sdk . nft . createCollection ( collectionRequest ) await result . tx . wait () return result . address } Depending on blockchain type, in collectionRequest should pass the following parameters: Ethereum const ethereumRequest : CreateCollectionRequest = { blockchain : Blockchain.ETHEREUM , asset : { assetType : \"ERC721\" , arguments : { name : \"name\" , symbol : \"RARI\" , baseURI : \"https://ipfs.rarible.com\" , contractURI : \"https://ipfs.rarible.com\" , isUserToken : false , }, }, } Tezos const tezosRequest : CreateCollectionRequest = { blockchain : Blockchain.TEZOS , asset : { assetType : \"NFT\" , arguments : { name : \"My NFT collection\" , symbol : \"MYNFT\" , contractURI : \"https://ipfs.io/ipfs/QmTKxwnqqxTxH4HE3UVM9yoJFZgbsZ8CuqqRFZCSWBF53m\" , isUserToken : false , }, }, } blockchain \u2014 blockchain type: ETHEREUM or TEZOS assetType \u2014 NFT collection type: ERC721 or ERC1155 for ETHEREUM , NFT or MT for TEZOS name \u2014 name of the collection symbol \u2014 symbol of the collection baseURI \u2014 prefix of the result of the tokenURI call contractURI \u2014 URI meta of the entire collection isUserToken \u2014 privat (true) or public (false) collection Checking created collection \u00b6 To check the created collection: Use the getCollectionById API method getCollectionById Returns collection by address. https://api.rarible.org/v0.1/collections/{collection} Example request (staging) curl --request GET 'https://api-staging.rarible.org/v0.1/collections/all?blockchains=ETHEREUM&size=3' Example response (status 200) { \"total\" : 3 , \"continuation\" : \"ETHEREUM:0x6ea0adbc173c7e8ca64c1ce881c1cfc161927876\" , \"collections\" : [ { \"id\" : \"ETHEREUM:0x6ea0adbc173c7e8ca64c1ce881c1cfc161927876\" , \"blockchain\" : \"ETHEREUM\" , \"type\" : \"ERC721\" , \"name\" : \"CryptoKitties\" , \"symbol\" : \"CK\" , \"features\" : [], \"minters\" : [] }, { \"id\" : \"ETHEREUM:0xaf2584a8b198f5d0b360b95d92aec852f7902e52\" , \"blockchain\" : \"ETHEREUM\" , \"type\" : \"CRYPTO_PUNKS\" , \"name\" : \"CRYPTOPUNKS\" , \"symbol\" : \"(\u03fe)\" , \"owner\" : \"ETHEREUM:0xfb571f9da71d1ac33e069571bf5c67fadcff18e4\" , \"features\" : [], \"minters\" : [] }, { \"id\" : \"ETHEREUM:0xd0200fa0a9c94484c7152813313b122e31bed99d\" , \"blockchain\" : \"ETHEREUM\" , \"type\" : \"ERC721\" , \"name\" : \"CryptoKitties\" , \"symbol\" : \"CK\" , \"features\" : [], \"minters\" : [] } ] } Or check Etherscan for Ethereum and Polygon, Flowscan for Flow, or tezblock for Tezos. See more information about usage Protocol SDK on https://github.com/rarible/sdk","title":"Create collection"},{"location":"reference/create-collection/#collection","text":"You can Create NFT Collection with Rarible Multichain Protocol in different blockchains. Before start, install and configure Rarible SDK and required wallets .","title":"Collection"},{"location":"reference/create-collection/#create-collection","text":"Use createCollection function: import { createRaribleSdk } from \"@rarible/sdk\" import type { BlockchainWallet } from \"@rarible/sdk-wallet/src\" import type { CreateCollectionRequest } from \"@rarible/sdk/src/types/nft/deploy/domain\" async function createCollection ( wallet : BlockchainWallet , collectionRequest : CreateCollectionRequest ) { const sdk = createRaribleSdk ( wallet , \"dev\" ) const result = await sdk . nft . createCollection ( collectionRequest ) await result . tx . wait () return result . address } Depending on blockchain type, in collectionRequest should pass the following parameters: Ethereum const ethereumRequest : CreateCollectionRequest = { blockchain : Blockchain.ETHEREUM , asset : { assetType : \"ERC721\" , arguments : { name : \"name\" , symbol : \"RARI\" , baseURI : \"https://ipfs.rarible.com\" , contractURI : \"https://ipfs.rarible.com\" , isUserToken : false , }, }, } Tezos const tezosRequest : CreateCollectionRequest = { blockchain : Blockchain.TEZOS , asset : { assetType : \"NFT\" , arguments : { name : \"My NFT collection\" , symbol : \"MYNFT\" , contractURI : \"https://ipfs.io/ipfs/QmTKxwnqqxTxH4HE3UVM9yoJFZgbsZ8CuqqRFZCSWBF53m\" , isUserToken : false , }, }, } blockchain \u2014 blockchain type: ETHEREUM or TEZOS assetType \u2014 NFT collection type: ERC721 or ERC1155 for ETHEREUM , NFT or MT for TEZOS name \u2014 name of the collection symbol \u2014 symbol of the collection baseURI \u2014 prefix of the result of the tokenURI call contractURI \u2014 URI meta of the entire collection isUserToken \u2014 privat (true) or public (false) collection","title":"Create collection"},{"location":"reference/create-collection/#checking-created-collection","text":"To check the created collection: Use the getCollectionById API method getCollectionById Returns collection by address. https://api.rarible.org/v0.1/collections/{collection} Example request (staging) curl --request GET 'https://api-staging.rarible.org/v0.1/collections/all?blockchains=ETHEREUM&size=3' Example response (status 200) { \"total\" : 3 , \"continuation\" : \"ETHEREUM:0x6ea0adbc173c7e8ca64c1ce881c1cfc161927876\" , \"collections\" : [ { \"id\" : \"ETHEREUM:0x6ea0adbc173c7e8ca64c1ce881c1cfc161927876\" , \"blockchain\" : \"ETHEREUM\" , \"type\" : \"ERC721\" , \"name\" : \"CryptoKitties\" , \"symbol\" : \"CK\" , \"features\" : [], \"minters\" : [] }, { \"id\" : \"ETHEREUM:0xaf2584a8b198f5d0b360b95d92aec852f7902e52\" , \"blockchain\" : \"ETHEREUM\" , \"type\" : \"CRYPTO_PUNKS\" , \"name\" : \"CRYPTOPUNKS\" , \"symbol\" : \"(\u03fe)\" , \"owner\" : \"ETHEREUM:0xfb571f9da71d1ac33e069571bf5c67fadcff18e4\" , \"features\" : [], \"minters\" : [] }, { \"id\" : \"ETHEREUM:0xd0200fa0a9c94484c7152813313b122e31bed99d\" , \"blockchain\" : \"ETHEREUM\" , \"type\" : \"ERC721\" , \"name\" : \"CryptoKitties\" , \"symbol\" : \"CK\" , \"features\" : [], \"minters\" : [] } ] } Or check Etherscan for Ethereum and Polygon, Flowscan for Flow, or tezblock for Tezos. See more information about usage Protocol SDK on https://github.com/rarible/sdk","title":"Checking created collection"},{"location":"reference/get-balance/","text":"Get balance \u00b6 You can transfer NFTs with Rarible Multichain Protocol in different blockchains. Before start, install and configure Rarible SDK and required wallets . To get balance of your wallet, use getBalance function: import { createRaribleSdk } from \"@rarible/sdk\" import { toUnionAddress } from \"@rarible/types\" import type { BlockchainWallet } from \"@rarible/sdk-wallet/src\" import type { AssetType } from \"@rarible/api-client\" async function getBalance ( wallet : BlockchainWallet , assetType : AssetType ) { const sdk = createRaribleSdk ( wallet , \"dev\" ) const balance = await sdk . balances . getBalance ( toUnionAddress ( \"<YOUR_WALLET_ADDRESS>\" ), assetType ) return balance } For getting balance from Polygon: Matic const balance = await sdk . balances . getBalance ( toUnionAddress ( \"ETHEREUM:0xc8f35463Ea36aEE234fe7EFB86373A78BF37e2A1\" ), { \"@type\" : \"ETH\" , blockchain : Blockchain.POLYGON , }) ERC20 const balance = await sdk . balances . getBalance ( toUnionAddress ( \"ETHEREUM:0xc8f35463Ea36aEE234fe7EFB86373A78BF37e2A1\" ), { \"@type\" : \"ERC20\" , contract : toCollectionId ( \"POLYGON:0xa6fa4fb5f76172d178d61b04b0ecd319c5d1c0aa\" ), })","title":"Get balance"},{"location":"reference/get-balance/#get-balance","text":"You can transfer NFTs with Rarible Multichain Protocol in different blockchains. Before start, install and configure Rarible SDK and required wallets . To get balance of your wallet, use getBalance function: import { createRaribleSdk } from \"@rarible/sdk\" import { toUnionAddress } from \"@rarible/types\" import type { BlockchainWallet } from \"@rarible/sdk-wallet/src\" import type { AssetType } from \"@rarible/api-client\" async function getBalance ( wallet : BlockchainWallet , assetType : AssetType ) { const sdk = createRaribleSdk ( wallet , \"dev\" ) const balance = await sdk . balances . getBalance ( toUnionAddress ( \"<YOUR_WALLET_ADDRESS>\" ), assetType ) return balance } For getting balance from Polygon: Matic const balance = await sdk . balances . getBalance ( toUnionAddress ( \"ETHEREUM:0xc8f35463Ea36aEE234fe7EFB86373A78BF37e2A1\" ), { \"@type\" : \"ETH\" , blockchain : Blockchain.POLYGON , }) ERC20 const balance = await sdk . balances . getBalance ( toUnionAddress ( \"ETHEREUM:0xc8f35463Ea36aEE234fe7EFB86373A78BF37e2A1\" ), { \"@type\" : \"ERC20\" , contract : toCollectionId ( \"POLYGON:0xa6fa4fb5f76172d178d61b04b0ecd319c5d1c0aa\" ), })","title":"Get balance"},{"location":"reference/install-sdk/","text":"Install Rarible SDK \u00b6 yarn add @rarible/sdk -D yarn add web3@1.5.0 yarn add tslib@2.3.1 If you need to initialize the wallets with ethers, you can install it like this: yarn add ethers To make sure the SDK is installed correctly, check version: npm view @rarible/sdk version Initialize wallets \u00b6 To use SDK, you have to create a Wallet \u2014 abstraction to communicate with real blockchain wallets. Read more about initializing wallets on Wallets page. Using SDK on client application \u00b6 SDK is written in TypeScript. You can use typings to explore SDK possibilities. import { createRaribleSdk } from \"@rarible/sdk\" Using SDK on server application \u00b6 The SDK was designed for use on the frontend side. To use the SDK on the server side (backend): Install packages: yarn add tslib@2.3.1 yarn add form-data yarn add node-fetch Add dependencies: global . FormData = require ( \"form-data\" ) global . window = { fetch : require ( \"node-fetch\" ), dispatchEvent : () => { }, } global . CustomEvent = function CustomEvent () { return } Try our example to buy Ethereum NFT item on Rinkeby network. Pass private key, node RPC URL, network ID, item ID for buyout and start: ETH_PRIVATE_KEY = \"0x...\" \\ ETHEREUM_RPC_URL = \"https://rinkeby.infura.io/...\" \\ ETHEREUM_NETWORK_ID = \"4\" \\ BUYOUT_ITEM_ID = \"0x1AF7A7555263F275433c6Bb0b8FdCD231F89B1D7:102581254137174039089845694331937600507918590364933200920056519678660477714440\" \\ ts-node packages/sdk/example/backend/buy.ts","title":"Installation"},{"location":"reference/install-sdk/#install-rarible-sdk","text":"yarn add @rarible/sdk -D yarn add web3@1.5.0 yarn add tslib@2.3.1 If you need to initialize the wallets with ethers, you can install it like this: yarn add ethers To make sure the SDK is installed correctly, check version: npm view @rarible/sdk version","title":"Install Rarible SDK"},{"location":"reference/install-sdk/#initialize-wallets","text":"To use SDK, you have to create a Wallet \u2014 abstraction to communicate with real blockchain wallets. Read more about initializing wallets on Wallets page.","title":"Initialize wallets"},{"location":"reference/install-sdk/#using-sdk-on-client-application","text":"SDK is written in TypeScript. You can use typings to explore SDK possibilities. import { createRaribleSdk } from \"@rarible/sdk\"","title":"Using SDK on client application"},{"location":"reference/install-sdk/#using-sdk-on-server-application","text":"The SDK was designed for use on the frontend side. To use the SDK on the server side (backend): Install packages: yarn add tslib@2.3.1 yarn add form-data yarn add node-fetch Add dependencies: global . FormData = require ( \"form-data\" ) global . window = { fetch : require ( \"node-fetch\" ), dispatchEvent : () => { }, } global . CustomEvent = function CustomEvent () { return } Try our example to buy Ethereum NFT item on Rinkeby network. Pass private key, node RPC URL, network ID, item ID for buyout and start: ETH_PRIVATE_KEY = \"0x...\" \\ ETHEREUM_RPC_URL = \"https://rinkeby.infura.io/...\" \\ ETHEREUM_NETWORK_ID = \"4\" \\ BUYOUT_ITEM_ID = \"0x1AF7A7555263F275433c6Bb0b8FdCD231F89B1D7:102581254137174039089845694331937600507918590364933200920056519678660477714440\" \\ ts-node packages/sdk/example/backend/buy.ts","title":"Using SDK on server application"},{"location":"reference/mint-and-sell/","text":"Mint and Sell \u00b6 You can prepare Mint and put up on Sale NFTs with Rarible Multichain Protocol in different blockchains. Before start, install and configure Rarible SDK and required wallets . Mint and List NFT for sale \u00b6 Often required to put your NFT on the sale right after creation. If it's the case for you, you can also use the mintOnChain function with sellAction : import { createRaribleSdk } from \"@rarible/sdk\" import { toCollectionId , toUnionAddress } from \"@rarible/types\" import type { BlockchainWallet } from \"@rarible/sdk-wallet/src\" import { MintType } from \"@rarible/sdk/build/types/nft/mint/domain\" import type { RequestCurrency } from \"@rarible/sdk/build/common/domain\" async function mintAndSell ( wallet : BlockchainWallet , currency : RequestCurrency ) { const sdk = createRaribleSdk ( wallet , \"dev\" ) const mintAction = await sdk . nft . mintAndSell ({ collectionId : toCollectionId ( \"<NFT_CONTRACT_ADDRESS>\" ), }) /* You should upload json file with item metadata in the following format: { name: string description: string | undefined image: string | undefined \"animation_url\": string | undefined \"external_url\": string | undefined attributes: TokenMetadataAttribute[] } and insert link to json file to \"uri\" field. To format your json data use \"sdk.nft.preprocessMeta()\" method */ const mintResult = await mintAction . submit ({ uri : \"<YOUR_LINK_TO_JSON>\" , royalties : [{ account : toUnionAddress ( \"<ROYLATY_ADDRESS>\" ), value : 1000 , }], creators : [{ account : toUnionAddress ( \"<CREATOR_ADDRESS>\" ), value : 10000 , }], lazyMint : true , supply : 1 , price : \"0.000000000000000001\" , currency , }) if ( mintResult . type === MintType . OFF_CHAIN ) { return mintResult . itemId } } collectionId \u2014 your collection address, that can be already deployed . Also, can be the address of Rarible Smart Contracts instance. You can find them on Contract Addresses page ContractAddress \u2014 BlockchainName:HexAddress = ETHEREUM:0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05 BlockchainName \u2014 ETHEREUM , FLOW , TEZOS or POLYGON uri \u2014 address of JSON file with \"image\", \"name\" and other NFT attributes. For example, on IPFS: https://ipfs.io/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp royalties \u2014 value and address for receiving royalties account \u2014 address in Union format ${blockchainGroup}:${token} . For example, TEZOS:tz1dKxdpV1hgErMTTKBorb8R5tSz8hFzPhKh value \u2014 value of the royalties. For example, 2,5% value is 250 creators \u2014 value and address of the creator account \u2014 address in Union format ${blockchainGroup}:${token} . For example, TEZOS:tz1dKxdpV1hgErMTTKBorb8R5tSz8hFzPhKh value \u2014 value of the royalties. For example, 2,5% value is 250 lazyMint \u2014 boolean, false if you want to mint item on the blockchain, true allow to you mint off-chain item without spending the gas supply \u2014 number of NFTs to create (not in every case it is supported, you can check it by reading sdk.nft.mint response under multiple parameters) price \u2014 price per 1 NFT in ETH currency \u2014 currency (ETH or specific ERC20 or Tez, Flow, etc.) Update listed token price \u00b6 Due to security circumstances, you can't update the token price to higher than the one created in the original sell order. If you want to boost the price, you need to cancel the sell order and create a new one. For update listed NFT price use the sellAndUpdate function: import { createRaribleSdk } from \"@rarible/sdk\" import { toItemId } from \"@rarible/types\" import type { BlockchainWallet } from \"@rarible/sdk-wallet/src\" import type { RequestCurrency } from \"@rarible/sdk/build/common/domain\" async function sellAndUpdate ( wallet : BlockchainWallet , assetType : RequestCurrency ) { const sdk = createRaribleSdk ( wallet , \"dev\" ) const sellAction = await sdk . order . sell ({ itemId : toItemId ( \"<YOUR_ITEM_ID>\" ), }) const sellOrderId = await sellAction . submit ({ amount : 1 , price : \"0.000002\" , currency : assetType , }) const updateAction = await sdk . order . sellUpdate ({ orderId : sellOrderId }) //You can only decrease price of sell order for security reasons //If you want to force change sell price you should cancel sell order await updateAction . submit ({ price : \"0.000001\" }) } Checking created order \u00b6 To check the created order use the getOrderById API method getOrderById Returns Order by ID. https://api.rarible.org/v0.1/orders/{id} Example request (staging) curl --request GET 'https://api-staging.rarible.org/v0.1/orders/ETHEREUM:0x0293c5918e9f7fb5eec101a656e5ba73fcfd61072ad211a9e80972cc487232ed' Request parameters: id \u2014 ID of your order, has format ${blockchain}:${id} For example, ETHEREUM:0x0293c5918e9f7fb5eec101a656e5ba73fcfd61072ad211a9e80972cc487232ed Example response (status 200) { \"id\" : \"ETHEREUM:0x0293c5918e9f7fb5eec101a656e5ba73fcfd61072ad211a9e80972cc487232ed\" , \"fill\" : \"0.00001\" , \"platform\" : \"RARIBLE\" , \"status\" : \"FILLED\" , \"makeStock\" : \"0\" , \"cancelled\" : false , \"createdAt\" : \"2022-03-11T12:09:14.904Z\" , \"lastUpdatedAt\" : \"2022-03-11T12:17:21Z\" , \"makePrice\" : \"0.00001\" , \"makePriceUsd\" : \"0.026062773565248403\" , \"priceHistory\" : [ { \"date\" : \"2022-03-11T12:09:14.904Z\" , \"makeValue\" : \"1\" , \"takeValue\" : \"0.00001\" } ], \"maker\" : \"ETHEREUM:0x2c02f0563eaf96dc3ddcb514f4d1832e7cbc801f\" , \"make\" : { \"type\" : { \"@type\" : \"ERC1155_Lazy\" , \"contract\" : \"ETHEREUM:0x4ff5fedb430f7393c8c5675e753782b595feb471\" , \"tokenId\" : \"19906957776073516298368660511705840565672843874722253325423575352615771308035\" , \"uri\" : \"https://shopdefi.gq/api/metadata/c13249c9-e99b-43cd-8a2f-9da5cd26881c\" , \"supply\" : \"1\" , \"creators\" : [ { \"account\" : \"ETHEREUM:0x2c02f0563eaf96dc3ddcb514f4d1832e7cbc801f\" , \"value\" : 10000 } ], \"royalties\" : [ { \"account\" : \"ETHEREUM:0x2c02f0563eaf96dc3ddcb514f4d1832e7cbc801f\" , \"value\" : 1000 } ], \"signatures\" : [ \"0xee347802d66c1231e3b799dd35768d52df1cd0b8fac88675836c0b8c9394077302d45f29a1e1be7afcf7bd2a9e54cd235a8b632772228fb4cbd0ce013ac3cef71b\" ] }, \"value\" : \"1\" }, \"take\" : { \"type\" : { \"@type\" : \"ETH\" , \"blockchain\" : \"ETHEREUM\" }, \"value\" : \"0.00001\" }, \"salt\" : \"0xaea6697bb08038f1ee23254fef19181bab3694464b612fb6e527ecf85f4cb830\" , \"signature\" : \"0xa80eb9c4cbea283976ba4b0db925dae0aefb2d5d4dfedbaa4214ae99a2e5832552e41634ff998b558c258f8b8bd803681534c340029cd1478292ea3838d069791c\" , \"pending\" : [], \"data\" : { \"@type\" : \"ETH_RARIBLE_V2\" , \"payouts\" : [], \"originFees\" : [] } } See more information about usage Protocol SDK on https://github.com/rarible/sdk","title":"Mint and Sell"},{"location":"reference/mint-and-sell/#mint-and-sell","text":"You can prepare Mint and put up on Sale NFTs with Rarible Multichain Protocol in different blockchains. Before start, install and configure Rarible SDK and required wallets .","title":"Mint and Sell"},{"location":"reference/mint-and-sell/#mint-and-list-nft-for-sale","text":"Often required to put your NFT on the sale right after creation. If it's the case for you, you can also use the mintOnChain function with sellAction : import { createRaribleSdk } from \"@rarible/sdk\" import { toCollectionId , toUnionAddress } from \"@rarible/types\" import type { BlockchainWallet } from \"@rarible/sdk-wallet/src\" import { MintType } from \"@rarible/sdk/build/types/nft/mint/domain\" import type { RequestCurrency } from \"@rarible/sdk/build/common/domain\" async function mintAndSell ( wallet : BlockchainWallet , currency : RequestCurrency ) { const sdk = createRaribleSdk ( wallet , \"dev\" ) const mintAction = await sdk . nft . mintAndSell ({ collectionId : toCollectionId ( \"<NFT_CONTRACT_ADDRESS>\" ), }) /* You should upload json file with item metadata in the following format: { name: string description: string | undefined image: string | undefined \"animation_url\": string | undefined \"external_url\": string | undefined attributes: TokenMetadataAttribute[] } and insert link to json file to \"uri\" field. To format your json data use \"sdk.nft.preprocessMeta()\" method */ const mintResult = await mintAction . submit ({ uri : \"<YOUR_LINK_TO_JSON>\" , royalties : [{ account : toUnionAddress ( \"<ROYLATY_ADDRESS>\" ), value : 1000 , }], creators : [{ account : toUnionAddress ( \"<CREATOR_ADDRESS>\" ), value : 10000 , }], lazyMint : true , supply : 1 , price : \"0.000000000000000001\" , currency , }) if ( mintResult . type === MintType . OFF_CHAIN ) { return mintResult . itemId } } collectionId \u2014 your collection address, that can be already deployed . Also, can be the address of Rarible Smart Contracts instance. You can find them on Contract Addresses page ContractAddress \u2014 BlockchainName:HexAddress = ETHEREUM:0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05 BlockchainName \u2014 ETHEREUM , FLOW , TEZOS or POLYGON uri \u2014 address of JSON file with \"image\", \"name\" and other NFT attributes. For example, on IPFS: https://ipfs.io/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp royalties \u2014 value and address for receiving royalties account \u2014 address in Union format ${blockchainGroup}:${token} . For example, TEZOS:tz1dKxdpV1hgErMTTKBorb8R5tSz8hFzPhKh value \u2014 value of the royalties. For example, 2,5% value is 250 creators \u2014 value and address of the creator account \u2014 address in Union format ${blockchainGroup}:${token} . For example, TEZOS:tz1dKxdpV1hgErMTTKBorb8R5tSz8hFzPhKh value \u2014 value of the royalties. For example, 2,5% value is 250 lazyMint \u2014 boolean, false if you want to mint item on the blockchain, true allow to you mint off-chain item without spending the gas supply \u2014 number of NFTs to create (not in every case it is supported, you can check it by reading sdk.nft.mint response under multiple parameters) price \u2014 price per 1 NFT in ETH currency \u2014 currency (ETH or specific ERC20 or Tez, Flow, etc.)","title":"Mint and List NFT for sale"},{"location":"reference/mint-and-sell/#update-listed-token-price","text":"Due to security circumstances, you can't update the token price to higher than the one created in the original sell order. If you want to boost the price, you need to cancel the sell order and create a new one. For update listed NFT price use the sellAndUpdate function: import { createRaribleSdk } from \"@rarible/sdk\" import { toItemId } from \"@rarible/types\" import type { BlockchainWallet } from \"@rarible/sdk-wallet/src\" import type { RequestCurrency } from \"@rarible/sdk/build/common/domain\" async function sellAndUpdate ( wallet : BlockchainWallet , assetType : RequestCurrency ) { const sdk = createRaribleSdk ( wallet , \"dev\" ) const sellAction = await sdk . order . sell ({ itemId : toItemId ( \"<YOUR_ITEM_ID>\" ), }) const sellOrderId = await sellAction . submit ({ amount : 1 , price : \"0.000002\" , currency : assetType , }) const updateAction = await sdk . order . sellUpdate ({ orderId : sellOrderId }) //You can only decrease price of sell order for security reasons //If you want to force change sell price you should cancel sell order await updateAction . submit ({ price : \"0.000001\" }) }","title":"Update listed token price"},{"location":"reference/mint-and-sell/#checking-created-order","text":"To check the created order use the getOrderById API method getOrderById Returns Order by ID. https://api.rarible.org/v0.1/orders/{id} Example request (staging) curl --request GET 'https://api-staging.rarible.org/v0.1/orders/ETHEREUM:0x0293c5918e9f7fb5eec101a656e5ba73fcfd61072ad211a9e80972cc487232ed' Request parameters: id \u2014 ID of your order, has format ${blockchain}:${id} For example, ETHEREUM:0x0293c5918e9f7fb5eec101a656e5ba73fcfd61072ad211a9e80972cc487232ed Example response (status 200) { \"id\" : \"ETHEREUM:0x0293c5918e9f7fb5eec101a656e5ba73fcfd61072ad211a9e80972cc487232ed\" , \"fill\" : \"0.00001\" , \"platform\" : \"RARIBLE\" , \"status\" : \"FILLED\" , \"makeStock\" : \"0\" , \"cancelled\" : false , \"createdAt\" : \"2022-03-11T12:09:14.904Z\" , \"lastUpdatedAt\" : \"2022-03-11T12:17:21Z\" , \"makePrice\" : \"0.00001\" , \"makePriceUsd\" : \"0.026062773565248403\" , \"priceHistory\" : [ { \"date\" : \"2022-03-11T12:09:14.904Z\" , \"makeValue\" : \"1\" , \"takeValue\" : \"0.00001\" } ], \"maker\" : \"ETHEREUM:0x2c02f0563eaf96dc3ddcb514f4d1832e7cbc801f\" , \"make\" : { \"type\" : { \"@type\" : \"ERC1155_Lazy\" , \"contract\" : \"ETHEREUM:0x4ff5fedb430f7393c8c5675e753782b595feb471\" , \"tokenId\" : \"19906957776073516298368660511705840565672843874722253325423575352615771308035\" , \"uri\" : \"https://shopdefi.gq/api/metadata/c13249c9-e99b-43cd-8a2f-9da5cd26881c\" , \"supply\" : \"1\" , \"creators\" : [ { \"account\" : \"ETHEREUM:0x2c02f0563eaf96dc3ddcb514f4d1832e7cbc801f\" , \"value\" : 10000 } ], \"royalties\" : [ { \"account\" : \"ETHEREUM:0x2c02f0563eaf96dc3ddcb514f4d1832e7cbc801f\" , \"value\" : 1000 } ], \"signatures\" : [ \"0xee347802d66c1231e3b799dd35768d52df1cd0b8fac88675836c0b8c9394077302d45f29a1e1be7afcf7bd2a9e54cd235a8b632772228fb4cbd0ce013ac3cef71b\" ] }, \"value\" : \"1\" }, \"take\" : { \"type\" : { \"@type\" : \"ETH\" , \"blockchain\" : \"ETHEREUM\" }, \"value\" : \"0.00001\" }, \"salt\" : \"0xaea6697bb08038f1ee23254fef19181bab3694464b612fb6e527ecf85f4cb830\" , \"signature\" : \"0xa80eb9c4cbea283976ba4b0db925dae0aefb2d5d4dfedbaa4214ae99a2e5832552e41634ff998b558c258f8b8bd803681534c340029cd1478292ea3838d069791c\" , \"pending\" : [], \"data\" : { \"@type\" : \"ETH_RARIBLE_V2\" , \"payouts\" : [], \"originFees\" : [] } } See more information about usage Protocol SDK on https://github.com/rarible/sdk","title":"Checking created order"},{"location":"reference/mint/","text":"Mint \u00b6 You can Mint NFTs with Rarible Multichain Protocol in different blockchains. Before start, install and configure Rarible SDK and required wallets . Minting Multichain \u00b6 Lazy Minting (off-chain) \u00b6 Use mintOffChain function: import { createRaribleSdk } from \"@rarible/sdk\" import { toCollectionId , toUnionAddress } from \"@rarible/types\" import type { BlockchainWallet } from \"@rarible/sdk-wallet/src\" import { MintType } from \"@rarible/sdk/build/types/nft/mint/domain\" async function mintOffChain ( wallet : BlockchainWallet , contractAddress : string ) { const sdk = createRaribleSdk ( wallet , \"dev\" ) const mintAction = await sdk . nft . mint ({ collectionId : toCollectionId ( contractAddress ), }) /* You should upload json file with item metadata in the following format: { name: string description: string | undefined image: string | undefined \"animation_url\": string | undefined \"external_url\": string | undefined attributes: TokenMetadataAttribute[] } and insert link to json file to \"uri\" field. To format your json data use \"sdk.nft.preprocessMeta()\" method */ const mintResult = await mintAction . submit ({ uri : \"<YOUR_LINK_TO_JSON>\" , royalties : [{ account : toUnionAddress ( \"<ROYLATY_ADDRESS>\" ), value : 1000 , }], creators : [{ account : toUnionAddress ( \"<CREATOR_ADDRESS>\" ), value : 10000 , }], lazyMint : true , supply : 1 , }) if ( mintResult . type === MintType . OFF_CHAIN ) { return mintResult . itemId } } collectionId \u2014 your collection address, that can be already deployed . Also, can be the address of Rarible Smart Contracts instance. You can find them on Contract Addresses page ContractAddress \u2014 BlockchainName:HexAddress = ETHEREUM:0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05 BlockchainName \u2014 ETHEREUM , FLOW , TEZOS or POLYGON uri \u2014 address of JSON file with \"image\", \"name\" and other NFT attributes. For example, on IPFS: https://ipfs.io/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp royalties \u2014 value and address for receiving royalties account \u2014 address in Union format ${blockchainGroup}:${token} . For example, TEZOS:tz1dKxdpV1hgErMTTKBorb8R5tSz8hFzPhKh value \u2014 value of the royalties. For example, 10% value is 1000 creators \u2014 value and address of the creator account \u2014 address in Union format ${blockchainGroup}:${token} . For example, TEZOS:tz1dKxdpV1hgErMTTKBorb8R5tSz8hFzPhKh value \u2014 value of the part in the ownership of the item. For example, 100% value is 10000 . If there are several owners, the total cost cannot be more than 10000 lazyMint \u2014 boolean, false if you want to mint item on the blockchain, true allow to you mint off-chain item without spending the gas supply \u2014 number of NFTs to create (not in every case it is supported, you can check it by reading sdk.nft.mint response under multiple parameters) Example of a successful response: itemId : \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:55143609719300586327244080327388661151936544170854464635146779205246455382047\" ; type : \"off-chain\" itemId \u2014 Id of your NFT, has format ${blockchain}:${token}:${tokenId} . For example, ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:12345 Minting (on-chain) \u00b6 Use mintOnChain function: import { createRaribleSdk } from \"@rarible/sdk\" import { toCollectionId , toUnionAddress } from \"@rarible/types\" import type { BlockchainWallet } from \"@rarible/sdk-wallet/src\" import { MintType } from \"@rarible/sdk/build/types/nft/mint/domain\" async function mintOnChain ( wallet : BlockchainWallet , contractAddress : string ) { const sdk = createRaribleSdk ( wallet , \"dev\" ) const mintAction = await sdk . nft . mint ({ collectionId : toCollectionId ( contractAddress ), }) /* You should upload json file with item metadata in the following format: { name: string description: string | undefined image: string | undefined \"animation_url\": string | undefined \"external_url\": string | undefined attributes: TokenMetadataAttribute[] } and insert link to json file to \"uri\" field. To format your json data use \"sdk.nft.preprocessMeta()\" method */ const mintResult = await mintAction . submit ({ uri : \"<YOUR_LINK_TO_JSON>\" , //optional royalties : [{ account : toUnionAddress ( \"<ROYLATY_ADDRESS>\" ), value : 1000 , }], //optional creators : [{ account : toUnionAddress ( \"<CREATOR_ADDRESS>\" ), value : 10000 , }], lazyMint : false , supply : 1 , }) if ( mintResult . type === MintType . ON_CHAIN ) { await mintResult . transaction . wait () return mintResult . itemId } } Minting with tokenId \u00b6 Usually the tokenId is generated automatically. If you need to get a tokenId before, for example, you want to upload data to the IPFS, use mintOnChainWithTokenId function: import { createRaribleSdk } from \"@rarible/sdk\" import { toCollectionId , toUnionAddress } from \"@rarible/types\" import type { BlockchainWallet } from \"@rarible/sdk-wallet/src\" import { MintType } from \"@rarible/sdk/build/types/nft/mint/domain\" async function mintOnChainWithTokenId ( wallet : BlockchainWallet , contractAddress : string ) { const sdk = createRaribleSdk ( wallet , \"dev\" ) const collectionId = toCollectionId ( contractAddress ) //Get tokenId for collection and mint const tokenId = await sdk . nft . generateTokenId ({ collection : collectionId , minter : toUnionAddress ( \"<CREATOR_ADDRESS>\" ), }) const mintAction = await sdk . nft . mint ({ collectionId , tokenId , }) /* You should upload json file with item metadata with the following format: { name: string description: string | undefined image: string | undefined \"animation_url\": string | undefined \"external_url\": string | undefined attributes: TokenMetadataAttribute[] } and insert link to json file to \"uri\" field. To format your json data use \"sdk.nft.preprocessMeta()\" method */ const mintResult = await mintAction . submit ({ uri : \"<YOUR_LINK_TO_JSON>\" , //optional royalties : [{ account : toUnionAddress ( \"<ROYLATY_ADDRESS>\" ), value : 1000 , }], //optional, by default creator=minter creators : [{ account : toUnionAddress ( \"<CREATOR_ADDRESS>\" ), value : 10000 , }], lazyMint : false , supply : 1 , }) if ( mintResult . type === MintType . ON_CHAIN ) { await mintResult . transaction . wait () return mintResult . itemId } } Checking created NFT \u00b6 To check the created item: Use the getItemById API method getItemById Returns Item by ID. https://api.rarible.org/v0.1/items/{itemId} Example request (staging) curl --request GET 'https://api-staging.rarible.org/v0.1/items/ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:19661880631107248865491477079747186145992059189823053172927066273904580362243' Request parameters: itemId \u2014 ItemID of your NFT, has format ${blockchain}:${token}:${tokenId} For example, ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:12345 Example response (status 200) { \"id\" : \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:19661880631107248865491477079747186145992059189823053172927066273904580362243\" , \"blockchain\" : \"ETHEREUM\" , \"collection\" : \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82\" , \"contract\" : \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82\" , \"tokenId\" : \"19661880631107248865491477079747186145992059189823053172927066273904580362243\" , \"creators\" : [ { \"account\" : \"ETHEREUM:0x2b783ae5b5b8a7a822449c7d8b6f35f9abc827f5\" , \"value\" : 10000 } ], \"owners\" : [], \"royalties\" : [], \"lazySupply\" : \"0\" , \"pending\" : [], \"mintedAt\" : \"2022-03-09T22:48:33Z\" , \"lastUpdatedAt\" : \"2022-03-09T22:50:03.530Z\" , \"supply\" : \"1\" , \"meta\" : { \"name\" : \"gbgbgbgbgbgb\" , \"description\" : \"\" , \"attributes\" : [], \"content\" : [ { \"@type\" : \"IMAGE\" , \"url\" : \"https://rarible.mypinata.cloud/ipfs/QmQCp8bhbaPwGEuHeeR8pme2q3zuSjam2JEuFgAvp4DZsU/image.jpeg\" , \"representation\" : \"ORIGINAL\" , \"mimeType\" : \"image/jpeg\" , \"size\" : 13311 , \"width\" : 640 , \"height\" : 640 } ], \"restrictions\" : [] }, \"deleted\" : false , \"auctions\" : [], \"totalStock\" : \"0\" , \"sellers\" : 0 } Or check Etherscan for Ethereum and Polygon, Flowscan for Flow, or tezblock for Tezos. You can find more information about Mint in Rarible Protocol SDK . Or you can use it as a regular async function and work with regular Promises. Minting in specific blockchain networks \u00b6 We recommend using the Multichain Protocol for minting tokens. But you can also make Mint on a specific blockchain network. Ethereum With Rarible Protocol Ethereum SDK, you can mint and lazy mint ERC-721 and ERC-1155 NFT tokens in the Ethereum network. Mint Minting is using the mintAndTransfer function for ERC-721 and ERC-1155 contracts. For ERC-721, the function has the following signature: mintAndTransfer(LibERC721LazyMint.Mint721Data memory data, address to) . struct Mint721Data { uint tokenId; string tokenURI; address[] creators; LibPart.Part[] royalties; bytes[] signatures; } tokenId \u2014 tokenId of the ERC-721 standard tokenURI \u2014 suffix for the token URI. The prefix is usually ipfs://ipfs/ creators \u2014 an array of authors addresses royalties \u2014 royalty array signatures \u2014 array of signatures. Each creator must have a signature. The only exception is when the creator sends a Mint transaction. For ERC-1155, the function has the following signature: mintAndTransfer(LibERC1155LazyMint.Mint1155Data memory data, address to, uint256 _amount) . struct Mint1155Data { uint tokenId; string tokenURI; uint supply; address[] creators; LibPart.Part[] royalties; bytes[] signatures; } tokenId \u2014 tokenId of the ERC-1155 standard tokenURI \u2014 suffix for the token URI. The prefix is usually ipfs://ipfs/ supply \u2014 total number of tokens for minting creators \u2014 an array of authors addresses royalties \u2014 royalty array signatures \u2014 array of signatures. Each creator must have a signature. The only exception is when the creator sends a Mint transaction. Lazy Mint Lazy Minting is supported for ERC-721 and ERC-1155. Lazy mint To create Lazy Minting: Generate a token ID Create a Lazy Minting request body that the creator must sign The creator signs the provided data Add signature to the request body Send the data to the API For more information about Lazy Minting, see SDK page. Flow With Rarible Protocol Flow SDK, you can mint Flow NFT tokens. Mint response represents transaction result extended with txId and minted tokenId const { txId , // transaction id tokenId , // minted tokenId status , // flow transaction status statusCode , // flow transaction statusCode - for example: value 4 for sealed transaction errorMessage , events , // events generated from contract and include all events produced by transaction, deopsits withdrown etc. } = await sdk . nft . mint ( collection , \"your meta info\" , []) Tezos With Rarible Protocol Tezos SDK, you can mint Tezos NFT tokens. const result = await mint ( provider : Provider , contract : string , royalties : { [ key : string ] : BigNumber }, supply? : BigNumber , token_id? : BigNumber , metadata ?: { [ key : string ] : string }, owner? : string , ) See more information about usage Protocol SDK on https://github.com/rarible/sdk","title":"Mint"},{"location":"reference/mint/#mint","text":"You can Mint NFTs with Rarible Multichain Protocol in different blockchains. Before start, install and configure Rarible SDK and required wallets .","title":"Mint"},{"location":"reference/mint/#minting-multichain","text":"","title":"Minting Multichain"},{"location":"reference/mint/#lazy-minting-off-chain","text":"Use mintOffChain function: import { createRaribleSdk } from \"@rarible/sdk\" import { toCollectionId , toUnionAddress } from \"@rarible/types\" import type { BlockchainWallet } from \"@rarible/sdk-wallet/src\" import { MintType } from \"@rarible/sdk/build/types/nft/mint/domain\" async function mintOffChain ( wallet : BlockchainWallet , contractAddress : string ) { const sdk = createRaribleSdk ( wallet , \"dev\" ) const mintAction = await sdk . nft . mint ({ collectionId : toCollectionId ( contractAddress ), }) /* You should upload json file with item metadata in the following format: { name: string description: string | undefined image: string | undefined \"animation_url\": string | undefined \"external_url\": string | undefined attributes: TokenMetadataAttribute[] } and insert link to json file to \"uri\" field. To format your json data use \"sdk.nft.preprocessMeta()\" method */ const mintResult = await mintAction . submit ({ uri : \"<YOUR_LINK_TO_JSON>\" , royalties : [{ account : toUnionAddress ( \"<ROYLATY_ADDRESS>\" ), value : 1000 , }], creators : [{ account : toUnionAddress ( \"<CREATOR_ADDRESS>\" ), value : 10000 , }], lazyMint : true , supply : 1 , }) if ( mintResult . type === MintType . OFF_CHAIN ) { return mintResult . itemId } } collectionId \u2014 your collection address, that can be already deployed . Also, can be the address of Rarible Smart Contracts instance. You can find them on Contract Addresses page ContractAddress \u2014 BlockchainName:HexAddress = ETHEREUM:0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05 BlockchainName \u2014 ETHEREUM , FLOW , TEZOS or POLYGON uri \u2014 address of JSON file with \"image\", \"name\" and other NFT attributes. For example, on IPFS: https://ipfs.io/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp royalties \u2014 value and address for receiving royalties account \u2014 address in Union format ${blockchainGroup}:${token} . For example, TEZOS:tz1dKxdpV1hgErMTTKBorb8R5tSz8hFzPhKh value \u2014 value of the royalties. For example, 10% value is 1000 creators \u2014 value and address of the creator account \u2014 address in Union format ${blockchainGroup}:${token} . For example, TEZOS:tz1dKxdpV1hgErMTTKBorb8R5tSz8hFzPhKh value \u2014 value of the part in the ownership of the item. For example, 100% value is 10000 . If there are several owners, the total cost cannot be more than 10000 lazyMint \u2014 boolean, false if you want to mint item on the blockchain, true allow to you mint off-chain item without spending the gas supply \u2014 number of NFTs to create (not in every case it is supported, you can check it by reading sdk.nft.mint response under multiple parameters) Example of a successful response: itemId : \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:55143609719300586327244080327388661151936544170854464635146779205246455382047\" ; type : \"off-chain\" itemId \u2014 Id of your NFT, has format ${blockchain}:${token}:${tokenId} . For example, ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:12345","title":"Lazy Minting (off-chain)"},{"location":"reference/mint/#minting-on-chain","text":"Use mintOnChain function: import { createRaribleSdk } from \"@rarible/sdk\" import { toCollectionId , toUnionAddress } from \"@rarible/types\" import type { BlockchainWallet } from \"@rarible/sdk-wallet/src\" import { MintType } from \"@rarible/sdk/build/types/nft/mint/domain\" async function mintOnChain ( wallet : BlockchainWallet , contractAddress : string ) { const sdk = createRaribleSdk ( wallet , \"dev\" ) const mintAction = await sdk . nft . mint ({ collectionId : toCollectionId ( contractAddress ), }) /* You should upload json file with item metadata in the following format: { name: string description: string | undefined image: string | undefined \"animation_url\": string | undefined \"external_url\": string | undefined attributes: TokenMetadataAttribute[] } and insert link to json file to \"uri\" field. To format your json data use \"sdk.nft.preprocessMeta()\" method */ const mintResult = await mintAction . submit ({ uri : \"<YOUR_LINK_TO_JSON>\" , //optional royalties : [{ account : toUnionAddress ( \"<ROYLATY_ADDRESS>\" ), value : 1000 , }], //optional creators : [{ account : toUnionAddress ( \"<CREATOR_ADDRESS>\" ), value : 10000 , }], lazyMint : false , supply : 1 , }) if ( mintResult . type === MintType . ON_CHAIN ) { await mintResult . transaction . wait () return mintResult . itemId } }","title":"Minting (on-chain)"},{"location":"reference/mint/#minting-with-tokenid","text":"Usually the tokenId is generated automatically. If you need to get a tokenId before, for example, you want to upload data to the IPFS, use mintOnChainWithTokenId function: import { createRaribleSdk } from \"@rarible/sdk\" import { toCollectionId , toUnionAddress } from \"@rarible/types\" import type { BlockchainWallet } from \"@rarible/sdk-wallet/src\" import { MintType } from \"@rarible/sdk/build/types/nft/mint/domain\" async function mintOnChainWithTokenId ( wallet : BlockchainWallet , contractAddress : string ) { const sdk = createRaribleSdk ( wallet , \"dev\" ) const collectionId = toCollectionId ( contractAddress ) //Get tokenId for collection and mint const tokenId = await sdk . nft . generateTokenId ({ collection : collectionId , minter : toUnionAddress ( \"<CREATOR_ADDRESS>\" ), }) const mintAction = await sdk . nft . mint ({ collectionId , tokenId , }) /* You should upload json file with item metadata with the following format: { name: string description: string | undefined image: string | undefined \"animation_url\": string | undefined \"external_url\": string | undefined attributes: TokenMetadataAttribute[] } and insert link to json file to \"uri\" field. To format your json data use \"sdk.nft.preprocessMeta()\" method */ const mintResult = await mintAction . submit ({ uri : \"<YOUR_LINK_TO_JSON>\" , //optional royalties : [{ account : toUnionAddress ( \"<ROYLATY_ADDRESS>\" ), value : 1000 , }], //optional, by default creator=minter creators : [{ account : toUnionAddress ( \"<CREATOR_ADDRESS>\" ), value : 10000 , }], lazyMint : false , supply : 1 , }) if ( mintResult . type === MintType . ON_CHAIN ) { await mintResult . transaction . wait () return mintResult . itemId } }","title":"Minting with tokenId"},{"location":"reference/mint/#checking-created-nft","text":"To check the created item: Use the getItemById API method getItemById Returns Item by ID. https://api.rarible.org/v0.1/items/{itemId} Example request (staging) curl --request GET 'https://api-staging.rarible.org/v0.1/items/ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:19661880631107248865491477079747186145992059189823053172927066273904580362243' Request parameters: itemId \u2014 ItemID of your NFT, has format ${blockchain}:${token}:${tokenId} For example, ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:12345 Example response (status 200) { \"id\" : \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:19661880631107248865491477079747186145992059189823053172927066273904580362243\" , \"blockchain\" : \"ETHEREUM\" , \"collection\" : \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82\" , \"contract\" : \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82\" , \"tokenId\" : \"19661880631107248865491477079747186145992059189823053172927066273904580362243\" , \"creators\" : [ { \"account\" : \"ETHEREUM:0x2b783ae5b5b8a7a822449c7d8b6f35f9abc827f5\" , \"value\" : 10000 } ], \"owners\" : [], \"royalties\" : [], \"lazySupply\" : \"0\" , \"pending\" : [], \"mintedAt\" : \"2022-03-09T22:48:33Z\" , \"lastUpdatedAt\" : \"2022-03-09T22:50:03.530Z\" , \"supply\" : \"1\" , \"meta\" : { \"name\" : \"gbgbgbgbgbgb\" , \"description\" : \"\" , \"attributes\" : [], \"content\" : [ { \"@type\" : \"IMAGE\" , \"url\" : \"https://rarible.mypinata.cloud/ipfs/QmQCp8bhbaPwGEuHeeR8pme2q3zuSjam2JEuFgAvp4DZsU/image.jpeg\" , \"representation\" : \"ORIGINAL\" , \"mimeType\" : \"image/jpeg\" , \"size\" : 13311 , \"width\" : 640 , \"height\" : 640 } ], \"restrictions\" : [] }, \"deleted\" : false , \"auctions\" : [], \"totalStock\" : \"0\" , \"sellers\" : 0 } Or check Etherscan for Ethereum and Polygon, Flowscan for Flow, or tezblock for Tezos. You can find more information about Mint in Rarible Protocol SDK . Or you can use it as a regular async function and work with regular Promises.","title":"Checking created NFT"},{"location":"reference/mint/#minting-in-specific-blockchain-networks","text":"We recommend using the Multichain Protocol for minting tokens. But you can also make Mint on a specific blockchain network. Ethereum With Rarible Protocol Ethereum SDK, you can mint and lazy mint ERC-721 and ERC-1155 NFT tokens in the Ethereum network. Mint Minting is using the mintAndTransfer function for ERC-721 and ERC-1155 contracts. For ERC-721, the function has the following signature: mintAndTransfer(LibERC721LazyMint.Mint721Data memory data, address to) . struct Mint721Data { uint tokenId; string tokenURI; address[] creators; LibPart.Part[] royalties; bytes[] signatures; } tokenId \u2014 tokenId of the ERC-721 standard tokenURI \u2014 suffix for the token URI. The prefix is usually ipfs://ipfs/ creators \u2014 an array of authors addresses royalties \u2014 royalty array signatures \u2014 array of signatures. Each creator must have a signature. The only exception is when the creator sends a Mint transaction. For ERC-1155, the function has the following signature: mintAndTransfer(LibERC1155LazyMint.Mint1155Data memory data, address to, uint256 _amount) . struct Mint1155Data { uint tokenId; string tokenURI; uint supply; address[] creators; LibPart.Part[] royalties; bytes[] signatures; } tokenId \u2014 tokenId of the ERC-1155 standard tokenURI \u2014 suffix for the token URI. The prefix is usually ipfs://ipfs/ supply \u2014 total number of tokens for minting creators \u2014 an array of authors addresses royalties \u2014 royalty array signatures \u2014 array of signatures. Each creator must have a signature. The only exception is when the creator sends a Mint transaction. Lazy Mint Lazy Minting is supported for ERC-721 and ERC-1155. Lazy mint To create Lazy Minting: Generate a token ID Create a Lazy Minting request body that the creator must sign The creator signs the provided data Add signature to the request body Send the data to the API For more information about Lazy Minting, see SDK page. Flow With Rarible Protocol Flow SDK, you can mint Flow NFT tokens. Mint response represents transaction result extended with txId and minted tokenId const { txId , // transaction id tokenId , // minted tokenId status , // flow transaction status statusCode , // flow transaction statusCode - for example: value 4 for sealed transaction errorMessage , events , // events generated from contract and include all events produced by transaction, deopsits withdrown etc. } = await sdk . nft . mint ( collection , \"your meta info\" , []) Tezos With Rarible Protocol Tezos SDK, you can mint Tezos NFT tokens. const result = await mint ( provider : Provider , contract : string , royalties : { [ key : string ] : BigNumber }, supply? : BigNumber , token_id? : BigNumber , metadata ?: { [ key : string ] : string }, owner? : string , ) See more information about usage Protocol SDK on https://github.com/rarible/sdk","title":"Minting in specific blockchain networks"},{"location":"reference/order/","text":"Sell Order \u00b6 When you have your NFT created, there is a high chance that you will want to sell it. Or try, at least. You can Sell NFTs with Rarible Multichain Protocol in different blockchains. Before start, install and configure Rarible SDK and required wallets . List NFT for sale \u00b6 Often required to put your NFT on the sale right after creation. If it's the case for you, you can also use the mintOnChain function with sellAction : import { createRaribleSdk } from \"@rarible/sdk\" import { toItemId , toUnionAddress } from \"@rarible/types\" import type { BlockchainWallet } from \"@rarible/sdk-wallet/src\" import type { RequestCurrency } from \"@rarible/sdk/build/common/domain\" async function mintOnChain ( wallet : BlockchainWallet , assetType : RequestCurrency ) { const sdk = createRaribleSdk ( wallet , \"dev\" ) const sellResponse = await sdk . order . sell ({ itemId : toItemId ( \"<YOUR_ITEM_ID>\" ), }) const sellOrderId = await sellResponse . submit ({ amount : 1 , price : \"0.000002\" , currency : assetType , originFees : [{ account : toUnionAddress ( \"<COMISSION_ADDRESS>\" ), //2,5% value : 250 , }], payouts : [{ account : toUnionAddress ( \"<PAYOUT_ADDRESS>\" ), //5% value : 500 , }], //+1 hour expirationDate : new Date ( Date . now () + 60 * 60 * 1000 ), }) return sellOrderId } itemId \u2014 ItemID of your NFT, has format ${blockchain}:${token}:${tokenId} . For example, ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:12345 amount \u2014 amount of NFT tokens for sale price \u2014 price per 1 NFT in ETH currency \u2014 currency (ETH or specific ERC20 or Tez, Flow, etc.) originFees \u2014 value and address of the origin fees for the order account \u2014 address in Union format ${blockchainGroup}:${token} . For example, TEZOS:tz1dKxdpV1hgErMTTKBorb8R5tSz8hFzPhKh value \u2014 value of the fees. For example, 2,5% value is 250 payouts \u2014 value and address of the payouts for the order account \u2014 address in Union format ${blockchainGroup}:${token} . For example, TEZOS:tz1dKxdpV1hgErMTTKBorb8R5tSz8hFzPhKh value \u2014 value of the payouts. For example, 5% value is 500 Update listed token price \u00b6 Due to security circumstances, you can't update the token price to higher than the one created in the original sell order. If you want to boost the price, you need to cancel the sell order and create a new one. For update listed NFT price use the sellAndUpdate function: import { createRaribleSdk } from \"@rarible/sdk\" import { toItemId , toUnionAddress } from \"@rarible/types\" import type { BlockchainWallet } from \"@rarible/sdk-wallet/src\" import type { RequestCurrency } from \"@rarible/sdk/build/common/domain\" async function sellAndUpdate ( wallet : BlockchainWallet , assetType : RequestCurrency ) { const sdk = createRaribleSdk ( wallet , \"dev\" ) const sellAction = await sdk . order . sell ({ itemId : toItemId ( \"<YOUR_ITEM_ID>\" ), }) const sellOrderId = await sellAction . submit ({ amount : 1 , price : \"0.000002\" , currency : assetType , originFees : [{ account : toUnionAddress ( \"<COMISSION_ADDRESS>\" ), //2,5% value : 250 , }], payouts : [{ account : toUnionAddress ( \"<PAYOUT_ADDRESS>\" ), //5% value : 500 , }], }) const updateAction = await sdk . order . sellUpdate ({ orderId : sellOrderId }) //You can only decrease price of sell order for security reasons //If you want to force change sell price you should cancel sell order await updateAction . submit ({ price : \"0.000001\" }) } Checking created order \u00b6 To check the created order use the getOrderById API method getOrderById Returns Order by ID. https://api.rarible.org/v0.1/orders/{id} Example request (staging) curl --request GET 'https://api-staging.rarible.org/v0.1/orders/ETHEREUM:0x0293c5918e9f7fb5eec101a656e5ba73fcfd61072ad211a9e80972cc487232ed' Request parameters: id \u2014 ID of your order, has format ${blockchain}:${id} For example, ETHEREUM:0x0293c5918e9f7fb5eec101a656e5ba73fcfd61072ad211a9e80972cc487232ed Example response (status 200) { \"id\" : \"ETHEREUM:0x0293c5918e9f7fb5eec101a656e5ba73fcfd61072ad211a9e80972cc487232ed\" , \"fill\" : \"0.00001\" , \"platform\" : \"RARIBLE\" , \"status\" : \"FILLED\" , \"makeStock\" : \"0\" , \"cancelled\" : false , \"createdAt\" : \"2022-03-11T12:09:14.904Z\" , \"lastUpdatedAt\" : \"2022-03-11T12:17:21Z\" , \"makePrice\" : \"0.00001\" , \"makePriceUsd\" : \"0.026062773565248403\" , \"priceHistory\" : [ { \"date\" : \"2022-03-11T12:09:14.904Z\" , \"makeValue\" : \"1\" , \"takeValue\" : \"0.00001\" } ], \"maker\" : \"ETHEREUM:0x2c02f0563eaf96dc3ddcb514f4d1832e7cbc801f\" , \"make\" : { \"type\" : { \"@type\" : \"ERC1155_Lazy\" , \"contract\" : \"ETHEREUM:0x4ff5fedb430f7393c8c5675e753782b595feb471\" , \"tokenId\" : \"19906957776073516298368660511705840565672843874722253325423575352615771308035\" , \"uri\" : \"https://shopdefi.gq/api/metadata/c13249c9-e99b-43cd-8a2f-9da5cd26881c\" , \"supply\" : \"1\" , \"creators\" : [ { \"account\" : \"ETHEREUM:0x2c02f0563eaf96dc3ddcb514f4d1832e7cbc801f\" , \"value\" : 10000 } ], \"royalties\" : [ { \"account\" : \"ETHEREUM:0x2c02f0563eaf96dc3ddcb514f4d1832e7cbc801f\" , \"value\" : 1000 } ], \"signatures\" : [ \"0xee347802d66c1231e3b799dd35768d52df1cd0b8fac88675836c0b8c9394077302d45f29a1e1be7afcf7bd2a9e54cd235a8b632772228fb4cbd0ce013ac3cef71b\" ] }, \"value\" : \"1\" }, \"take\" : { \"type\" : { \"@type\" : \"ETH\" , \"blockchain\" : \"ETHEREUM\" }, \"value\" : \"0.00001\" }, \"salt\" : \"0xaea6697bb08038f1ee23254fef19181bab3694464b612fb6e527ecf85f4cb830\" , \"signature\" : \"0xa80eb9c4cbea283976ba4b0db925dae0aefb2d5d4dfedbaa4214ae99a2e5832552e41634ff998b558c258f8b8bd803681534c340029cd1478292ea3838d069791c\" , \"pending\" : [], \"data\" : { \"@type\" : \"ETH_RARIBLE_V2\" , \"payouts\" : [], \"originFees\" : [] } } See more information about usage Protocol SDK on https://github.com/rarible/sdk","title":"Sell Order"},{"location":"reference/order/#sell-order","text":"When you have your NFT created, there is a high chance that you will want to sell it. Or try, at least. You can Sell NFTs with Rarible Multichain Protocol in different blockchains. Before start, install and configure Rarible SDK and required wallets .","title":"Sell Order"},{"location":"reference/order/#list-nft-for-sale","text":"Often required to put your NFT on the sale right after creation. If it's the case for you, you can also use the mintOnChain function with sellAction : import { createRaribleSdk } from \"@rarible/sdk\" import { toItemId , toUnionAddress } from \"@rarible/types\" import type { BlockchainWallet } from \"@rarible/sdk-wallet/src\" import type { RequestCurrency } from \"@rarible/sdk/build/common/domain\" async function mintOnChain ( wallet : BlockchainWallet , assetType : RequestCurrency ) { const sdk = createRaribleSdk ( wallet , \"dev\" ) const sellResponse = await sdk . order . sell ({ itemId : toItemId ( \"<YOUR_ITEM_ID>\" ), }) const sellOrderId = await sellResponse . submit ({ amount : 1 , price : \"0.000002\" , currency : assetType , originFees : [{ account : toUnionAddress ( \"<COMISSION_ADDRESS>\" ), //2,5% value : 250 , }], payouts : [{ account : toUnionAddress ( \"<PAYOUT_ADDRESS>\" ), //5% value : 500 , }], //+1 hour expirationDate : new Date ( Date . now () + 60 * 60 * 1000 ), }) return sellOrderId } itemId \u2014 ItemID of your NFT, has format ${blockchain}:${token}:${tokenId} . For example, ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:12345 amount \u2014 amount of NFT tokens for sale price \u2014 price per 1 NFT in ETH currency \u2014 currency (ETH or specific ERC20 or Tez, Flow, etc.) originFees \u2014 value and address of the origin fees for the order account \u2014 address in Union format ${blockchainGroup}:${token} . For example, TEZOS:tz1dKxdpV1hgErMTTKBorb8R5tSz8hFzPhKh value \u2014 value of the fees. For example, 2,5% value is 250 payouts \u2014 value and address of the payouts for the order account \u2014 address in Union format ${blockchainGroup}:${token} . For example, TEZOS:tz1dKxdpV1hgErMTTKBorb8R5tSz8hFzPhKh value \u2014 value of the payouts. For example, 5% value is 500","title":"List NFT for sale"},{"location":"reference/order/#update-listed-token-price","text":"Due to security circumstances, you can't update the token price to higher than the one created in the original sell order. If you want to boost the price, you need to cancel the sell order and create a new one. For update listed NFT price use the sellAndUpdate function: import { createRaribleSdk } from \"@rarible/sdk\" import { toItemId , toUnionAddress } from \"@rarible/types\" import type { BlockchainWallet } from \"@rarible/sdk-wallet/src\" import type { RequestCurrency } from \"@rarible/sdk/build/common/domain\" async function sellAndUpdate ( wallet : BlockchainWallet , assetType : RequestCurrency ) { const sdk = createRaribleSdk ( wallet , \"dev\" ) const sellAction = await sdk . order . sell ({ itemId : toItemId ( \"<YOUR_ITEM_ID>\" ), }) const sellOrderId = await sellAction . submit ({ amount : 1 , price : \"0.000002\" , currency : assetType , originFees : [{ account : toUnionAddress ( \"<COMISSION_ADDRESS>\" ), //2,5% value : 250 , }], payouts : [{ account : toUnionAddress ( \"<PAYOUT_ADDRESS>\" ), //5% value : 500 , }], }) const updateAction = await sdk . order . sellUpdate ({ orderId : sellOrderId }) //You can only decrease price of sell order for security reasons //If you want to force change sell price you should cancel sell order await updateAction . submit ({ price : \"0.000001\" }) }","title":"Update listed token price"},{"location":"reference/order/#checking-created-order","text":"To check the created order use the getOrderById API method getOrderById Returns Order by ID. https://api.rarible.org/v0.1/orders/{id} Example request (staging) curl --request GET 'https://api-staging.rarible.org/v0.1/orders/ETHEREUM:0x0293c5918e9f7fb5eec101a656e5ba73fcfd61072ad211a9e80972cc487232ed' Request parameters: id \u2014 ID of your order, has format ${blockchain}:${id} For example, ETHEREUM:0x0293c5918e9f7fb5eec101a656e5ba73fcfd61072ad211a9e80972cc487232ed Example response (status 200) { \"id\" : \"ETHEREUM:0x0293c5918e9f7fb5eec101a656e5ba73fcfd61072ad211a9e80972cc487232ed\" , \"fill\" : \"0.00001\" , \"platform\" : \"RARIBLE\" , \"status\" : \"FILLED\" , \"makeStock\" : \"0\" , \"cancelled\" : false , \"createdAt\" : \"2022-03-11T12:09:14.904Z\" , \"lastUpdatedAt\" : \"2022-03-11T12:17:21Z\" , \"makePrice\" : \"0.00001\" , \"makePriceUsd\" : \"0.026062773565248403\" , \"priceHistory\" : [ { \"date\" : \"2022-03-11T12:09:14.904Z\" , \"makeValue\" : \"1\" , \"takeValue\" : \"0.00001\" } ], \"maker\" : \"ETHEREUM:0x2c02f0563eaf96dc3ddcb514f4d1832e7cbc801f\" , \"make\" : { \"type\" : { \"@type\" : \"ERC1155_Lazy\" , \"contract\" : \"ETHEREUM:0x4ff5fedb430f7393c8c5675e753782b595feb471\" , \"tokenId\" : \"19906957776073516298368660511705840565672843874722253325423575352615771308035\" , \"uri\" : \"https://shopdefi.gq/api/metadata/c13249c9-e99b-43cd-8a2f-9da5cd26881c\" , \"supply\" : \"1\" , \"creators\" : [ { \"account\" : \"ETHEREUM:0x2c02f0563eaf96dc3ddcb514f4d1832e7cbc801f\" , \"value\" : 10000 } ], \"royalties\" : [ { \"account\" : \"ETHEREUM:0x2c02f0563eaf96dc3ddcb514f4d1832e7cbc801f\" , \"value\" : 1000 } ], \"signatures\" : [ \"0xee347802d66c1231e3b799dd35768d52df1cd0b8fac88675836c0b8c9394077302d45f29a1e1be7afcf7bd2a9e54cd235a8b632772228fb4cbd0ce013ac3cef71b\" ] }, \"value\" : \"1\" }, \"take\" : { \"type\" : { \"@type\" : \"ETH\" , \"blockchain\" : \"ETHEREUM\" }, \"value\" : \"0.00001\" }, \"salt\" : \"0xaea6697bb08038f1ee23254fef19181bab3694464b612fb6e527ecf85f4cb830\" , \"signature\" : \"0xa80eb9c4cbea283976ba4b0db925dae0aefb2d5d4dfedbaa4214ae99a2e5832552e41634ff998b558c258f8b8bd803681534c340029cd1478292ea3838d069791c\" , \"pending\" : [], \"data\" : { \"@type\" : \"ETH_RARIBLE_V2\" , \"payouts\" : [], \"originFees\" : [] } } See more information about usage Protocol SDK on https://github.com/rarible/sdk","title":"Checking created order"},{"location":"reference/reference-overview/","text":"Overview \u00b6 Rarible creates Multichain SDK, an abstraction of complicated blockchain logic underneath, allowing end-users to interact with the blockchain to create some sorts of assets and list them to sell, trade, etc. In other words, Multichain SDK is ready to go, NFT marketplace functionality, which you can use out of the box. See more information about API on API Reference page. First Steps Install SDK Initialize Wallets See how to use common functionality: Create collection Mint NFT Sell NFTs Mint and Sell Create and Accept Bid Transfer tokens Burn tokens Get wallet balance Tokens conversion Check Contract Addresses and Search Capabilities","title":"Overview"},{"location":"reference/reference-overview/#overview","text":"Rarible creates Multichain SDK, an abstraction of complicated blockchain logic underneath, allowing end-users to interact with the blockchain to create some sorts of assets and list them to sell, trade, etc. In other words, Multichain SDK is ready to go, NFT marketplace functionality, which you can use out of the box. See more information about API on API Reference page. First Steps Install SDK Initialize Wallets See how to use common functionality: Create collection Mint NFT Sell NFTs Mint and Sell Create and Accept Bid Transfer tokens Burn tokens Get wallet balance Tokens conversion Check Contract Addresses and Search Capabilities","title":"Overview"},{"location":"reference/search-capabilities/","text":"Search Capabilities \u00b6 On the multichain-api.rarible.org you can find main information about Protocol API. Controllers \u00b6 Use the following controllers to search information about NFT with our multichain API: Signature controller \u2014 uses for validation of the order signature Currency controller \u2014 getting currency USD rate Item controller \u2014 getting information about NFT items Ownership controller \u2014 getting information about NFT items ownership Order controller \u2014 getting information about NFT orders Auction controller \u2014 getting information about NFT auctions Activity controller \u2014 getting information about activities with NFT Collection controller \u2014 getting information about NFT collections API usage Examples \u00b6 Items \u00b6 get Item by owner Returns Item by owner https://api.rarible.org/v0.1/items/byOwner Example request (staging) curl --request GET 'https://api-staging.rarible.org/v0.1/items/byOwner?owner=ETHEREUM:0x66606fe12f319a8f781a9af35c3d061617ea642a&size=1' Request parameters: owner \u2014 address of the item owner, has format ${blockchain}:${address} . For example, ETHEREUM:0x66606fe12f319a8f781a9af35c3d061617ea642a Example response (status 200) { \"total\" : 1 , \"continuation\" : \"1648125753039_0x08295565739cf720f2a61e5237815eacfad98c6a:2102\" , \"items\" : [ { \"id\" : \"ETHEREUM:0x08295565739cf720f2a61e5237815eacfad98c6a:2102\" , \"blockchain\" : \"ETHEREUM\" , \"collection\" : \"ETHEREUM:0x08295565739cf720f2a61e5237815eacfad98c6a\" , \"contract\" : \"ETHEREUM:0x08295565739cf720f2a61e5237815eacfad98c6a\" , \"tokenId\" : \"2102\" , \"creators\" : [ { \"account\" : \"ETHEREUM:0x66606fe12f319a8f781a9af35c3d061617ea642a\" , \"value\" : 10000 } ], \"owners\" : [], \"royalties\" : [], \"lazySupply\" : \"0\" , \"pending\" : [], \"mintedAt\" : \"2022-03-24T12:42:33Z\" , \"lastUpdatedAt\" : \"2022-03-24T12:42:33.039Z\" , \"supply\" : \"1\" , \"meta\" : { \"name\" : \"\u634c\uff1a\u4eba\u6d77\u832b\u832b #\\n2102\" , \"description\" : \"\u4eba\u6d77\u554a\u832b\u832b\u554a-\u300a\u6d77\u8349\u821e\u300bNFT \\n\\n\u4eba\u6d77\u554a \u832b\u832b\u554a \u968f\u6ce2\u9010\u6d41 \u6d6e\u6d6e\u6c89\u6c89\" , \"attributes\" : [ { \"key\" : \"\u6f14\u5531\" , \"value\" : \"\u8427\u5168\" }, { \"key\" : \"\u4f5c\u8bcd\" , \"value\" : \"\u8427\u5168\" }, { \"key\" : \"\u4f5c\u66f2\" , \"value\" : \"\u8427\u5168\" }, { \"key\" : \"\u7a00\u6709\u5ea6\" , \"value\" : \"\u7f55\u89c1\" } ], \"content\" : [ { \"@type\" : \"IMAGE\" , \"url\" : \"https://rarible.mypinata.cloud/ipfs/QmbyFuDKZc9UkxMNJ7t25cZk7mm8u77c3FENFsatxN4VNk/8.png\" , \"representation\" : \"ORIGINAL\" }, { \"@type\" : \"IMAGE\" , \"url\" : \"https://lh3.googleusercontent.com/t55AtJJ9szplBUbEchUAE_tyZuYTeSenjd7iHfVPfwsvIX3lof2kcI9jzGcpZ1Prf3oFiYLdcVsO0aFNCo-j6sgYUY0x32IEngz9s8I\" , \"representation\" : \"BIG\" }, { \"@type\" : \"IMAGE\" , \"url\" : \"https://lh3.googleusercontent.com/t55AtJJ9szplBUbEchUAE_tyZuYTeSenjd7iHfVPfwsvIX3lof2kcI9jzGcpZ1Prf3oFiYLdcVsO0aFNCo-j6sgYUY0x32IEngz9s8I=s250\" , \"representation\" : \"PREVIEW\" }, { \"@type\" : \"VIDEO\" , \"url\" : \"https://storage.opensea.io/files/cec338c0f5685f3037096b7bed283e15.wav\" , \"representation\" : \"ORIGINAL\" } ], \"restrictions\" : [] }, \"deleted\" : false , \"auctions\" : [], \"totalStock\" : \"0\" , \"sellers\" : 0 } ] } get Item by Id Returns Item by Id https://api.rarible.org/v0.1/items/{itemId} Example request (staging) curl --request GET 'https://api-staging.rarible.org/v0.1/items/ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:19661880631107248865491477079747186145992059189823053172927066273904580362243' Request parameters: itemId \u2014 Id of your NFT, has format ${blockchain}:${token}:${tokenId} . For example, ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:12345 Example response (status 200) { \"id\" : \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:19661880631107248865491477079747186145992059189823053172927066273904580362243\" , \"blockchain\" : \"ETHEREUM\" , \"collection\" : \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82\" , \"contract\" : \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82\" , \"tokenId\" : \"19661880631107248865491477079747186145992059189823053172927066273904580362243\" , \"creators\" : [ { \"account\" : \"ETHEREUM:0x2b783ae5b5b8a7a822449c7d8b6f35f9abc827f5\" , \"value\" : 10000 } ], \"owners\" : [], \"royalties\" : [], \"lazySupply\" : \"0\" , \"pending\" : [], \"mintedAt\" : \"2022-03-09T22:48:33Z\" , \"lastUpdatedAt\" : \"2022-03-09T22:50:03.530Z\" , \"supply\" : \"1\" , \"meta\" : { \"name\" : \"gbgbgbgbgbgb\" , \"description\" : \"\" , \"attributes\" : [], \"content\" : [ { \"@type\" : \"IMAGE\" , \"url\" : \"https://rarible.mypinata.cloud/ipfs/QmQCp8bhbaPwGEuHeeR8pme2q3zuSjam2JEuFgAvp4DZsU/image.jpeg\" , \"representation\" : \"ORIGINAL\" , \"mimeType\" : \"image/jpeg\" , \"size\" : 13311 , \"width\" : 640 , \"height\" : 640 } ], \"restrictions\" : [] }, \"deleted\" : false , \"auctions\" : [], \"totalStock\" : \"0\" , \"sellers\" : 0 } get All Items Returns All Items https://api.rarible.org/v0.1/items/all Example request (staging) curl --request GET 'https://api.rarible.org/v0.1/items/all?blockchains=POLYGON&size=1' Example response (status 200) { \"total\" : 1 , \"continuation\" : \"POLYGON:1648131545251_0x4d544035500d7ac1b42329c70eb58e77f8249f0f:3874767738\" , \"items\" : [ { \"id\" : \"POLYGON:0x4d544035500d7ac1b42329c70eb58e77f8249f0f:3874767738\" , \"blockchain\" : \"POLYGON\" , \"collection\" : \"POLYGON:0x4d544035500d7ac1b42329c70eb58e77f8249f0f\" , \"contract\" : \"POLYGON:0x4d544035500d7ac1b42329c70eb58e77f8249f0f\" , \"tokenId\" : \"3874767738\" , \"creators\" : [ { \"account\" : \"ETHEREUM:0x517c295d34137a2f4b3026656c09dd62e668fc72\" , \"value\" : 10000 } ], \"owners\" : [], \"royalties\" : [], \"lazySupply\" : \"0\" , \"pending\" : [], \"mintedAt\" : \"2022-03-24T14:18:11Z\" , \"lastUpdatedAt\" : \"2022-03-24T14:19:05.251Z\" , \"supply\" : \"1\" , \"meta\" : { \"name\" : \"LOK Food 5M\" , \"description\" : \"League of Kingdoms Resource\" , \"attributes\" : [], \"content\" : [ { \"@type\" : \"IMAGE\" , \"url\" : \"https://lok-nft.leagueofkingdoms.com/resource/10101020.png\" , \"representation\" : \"ORIGINAL\" , \"mimeType\" : \"image/png\" , \"width\" : 200 , \"height\" : 200 } ], \"restrictions\" : [] }, \"deleted\" : false , \"auctions\" : [], \"totalStock\" : \"0\" , \"sellers\" : 0 } ] } Orders \u00b6 get Order by Id Returns Order by Id https://api.rarible.org/v0.1/orders/{id} Example request (staging) curl --request GET 'https://api-staging.rarible.org/v0.1/orders/ETHEREUM:0x1641f3a030a1e810abe15c70320ab0e4cf1ee59c0baa3a77cf8b409aa0a0d320' Request parameters: id \u2014 order Id, has format ${blockchain}:${id} . For example, ETHEREUM:0x1641f3a030a1e810abe15c70320ab0e4cf1ee59c0baa3a77cf8b409aa0a0d320 Example response (status 200) { \"id\" : \"ETHEREUM:0x1641f3a030a1e810abe15c70320ab0e4cf1ee59c0baa3a77cf8b409aa0a0d320\" , \"fill\" : \"0\" , \"platform\" : \"OPEN_SEA\" , \"status\" : \"INACTIVE\" , \"startedAt\" : \"2022-03-24T14:27:33Z\" , \"endedAt\" : \"2022-09-20T14:29:08Z\" , \"makeStock\" : \"0\" , \"cancelled\" : false , \"createdAt\" : \"2022-03-24T14:29:15.790Z\" , \"lastUpdatedAt\" : \"2022-03-24T14:29:15.790Z\" , \"makePrice\" : \"0.01\" , \"makePriceUsd\" : \"30.198384450784797\" , \"priceHistory\" : [ { \"date\" : \"2022-03-24T14:29:15.790Z\" , \"makeValue\" : \"1\" , \"takeValue\" : \"0.01\" } ], \"maker\" : \"ETHEREUM:0xe59072c5084ec2dc16e6bcdc3560802ffbafb5cb\" , \"make\" : { \"type\" : { \"@type\" : \"ERC1155\" , \"contract\" : \"ETHEREUM:0x88b48f654c30e99bc2e4a1559b4dcf1ad93fa656\" , \"tokenId\" : \"103834860413964016633619762390589326621035685084276300587330678503415507582977\" }, \"value\" : \"1\" }, \"take\" : { \"type\" : { \"@type\" : \"ETH\" , \"blockchain\" : \"ETHEREUM\" }, \"value\" : \"0.01\" }, \"salt\" : \"0xd49cbf21e348826dff4760cf9c22af9bd877809341ad0e5d0e899d60d8d59553\" , \"signature\" : \"0x45face93c43bdb3375e02b5140c4ec380a112b82c81fa78a5f6e7d15206d997629e5427476302f66cfae79488ca5591bc667de4c8847b56c81d90e2a76a9f8021c\" , \"pending\" : [], \"data\" : { \"@type\" : \"ETH_OPEN_SEA_V1\" , \"exchange\" : \"ETHEREUM:0xdd54d660178b28f6033a953b0e55073cfa7e3744\" , \"makerRelayerFee\" : \"1250\" , \"takerRelayerFee\" : \"0\" , \"makerProtocolFee\" : \"0\" , \"takerProtocolFee\" : \"0\" , \"feeRecipient\" : \"ETHEREUM:0x5b3256965e7c3cf26e11fcaf296dfc8807c01073\" , \"feeMethod\" : \"SPLIT_FEE\" , \"side\" : \"SELL\" , \"saleKind\" : \"FIXED_PRICE\" , \"howToCall\" : \"DELEGATE_CALL\" , \"callData\" : \"0x96809f90000000000000000000000000e59072c5084ec2dc16e6bcdc3560802ffbafb5cb000000000000000000000000000000000000000000000000000000000000000000000000000000000000000088b48f654c30e99bc2e4a1559b4dcf1ad93fa656e59072c5084ec2dc16e6bcdc3560802ffbafb5cb00000000000a9e00000000010000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000000\" , \"replacementPattern\" : \"0x000000000000000000000000000000000000000000000000000000000000000000000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\" , \"staticTarget\" : \"ETHEREUM:0x0000000000000000000000000000000000000000\" , \"staticExtraData\" : \"0x\" , \"extra\" : \"0\" } } get Sell Orders by maker Returns Sell Orders by maker https://api.rarible.org/v0.1/orders/sell/byMaker Example request (staging) curl --request GET 'https://api-staging.rarible.org/v0.1/orders/sell/byMaker?maker=ETHEREUM:0xe59072c5084ec2dc16e6bcdc3560802ffbafb5cb&size=1' Request parameters: maker \u2014 the maker of the order, has format ${blockchain}:${id} . For example, ETHEREUM:0xe59072c5084ec2dc16e6bcdc3560802ffbafb5cb Example response (status 200) { \"continuation\" : \"1648132919811_0xf8e3f895591ac3f6ff4a516ea17ac1c12b21c3d93acfa3e808e16f1467bb7c52\" , \"orders\" : [ { \"id\" : \"ETHEREUM:0xf8e3f895591ac3f6ff4a516ea17ac1c12b21c3d93acfa3e808e16f1467bb7c52\" , \"fill\" : \"0\" , \"platform\" : \"OPEN_SEA\" , \"status\" : \"INACTIVE\" , \"startedAt\" : \"2022-03-24T14:40:16Z\" , \"endedAt\" : \"2022-09-20T14:41:52Z\" , \"makeStock\" : \"0\" , \"cancelled\" : false , \"createdAt\" : \"2022-03-24T14:41:59.811Z\" , \"lastUpdatedAt\" : \"2022-03-24T14:41:59.811Z\" , \"makePrice\" : \"0.01\" , \"makePriceUsd\" : \"30.198384450784797\" , \"priceHistory\" : [ { \"date\" : \"2022-03-24T14:41:59.811Z\" , \"makeValue\" : \"1\" , \"takeValue\" : \"0.01\" } ], \"maker\" : \"ETHEREUM:0xe59072c5084ec2dc16e6bcdc3560802ffbafb5cb\" , \"make\" : { \"type\" : { \"@type\" : \"ERC1155\" , \"contract\" : \"ETHEREUM:0x88b48f654c30e99bc2e4a1559b4dcf1ad93fa656\" , \"tokenId\" : \"103834860413964016633619762390589326621035685084276300587330678545196949438465\" }, \"value\" : \"1\" }, \"take\" : { \"type\" : { \"@type\" : \"ETH\" , \"blockchain\" : \"ETHEREUM\" }, \"value\" : \"0.01\" }, \"salt\" : \"0x0b06c99560930d99286981d16bdee68a8a10e872bc7718e662a144ab63eb854b\" , \"signature\" : \"0xee243d7bdb69518ea6c9c9cbfb4163e49111ec476b870f07c61c549b72927d332321ba1fceb1b2db7e26e4994a25fc18e0da2e729737deb8ae84f0c54c7f3d7c1c\" , \"pending\" : [], \"data\" : { \"@type\" : \"ETH_OPEN_SEA_V1\" , \"exchange\" : \"ETHEREUM:0xdd54d660178b28f6033a953b0e55073cfa7e3744\" , \"makerRelayerFee\" : \"1250\" , \"takerRelayerFee\" : \"0\" , \"makerProtocolFee\" : \"0\" , \"takerProtocolFee\" : \"0\" , \"feeRecipient\" : \"ETHEREUM:0x5b3256965e7c3cf26e11fcaf296dfc8807c01073\" , \"feeMethod\" : \"SPLIT_FEE\" , \"side\" : \"SELL\" , \"saleKind\" : \"FIXED_PRICE\" , \"howToCall\" : \"DELEGATE_CALL\" , \"callData\" : \"0x96809f90000000000000000000000000e59072c5084ec2dc16e6bcdc3560802ffbafb5cb000000000000000000000000000000000000000000000000000000000000000000000000000000000000000088b48f654c30e99bc2e4a1559b4dcf1ad93fa656e59072c5084ec2dc16e6bcdc3560802ffbafb5cb00000000000ac400000000010000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000000\" , \"replacementPattern\" : \"0x000000000000000000000000000000000000000000000000000000000000000000000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\" , \"staticTarget\" : \"ETHEREUM:0x0000000000000000000000000000000000000000\" , \"staticExtraData\" : \"0x\" , \"extra\" : \"0\" } } ] } get All Orders Returns all Orders https://api.rarible.org/v0.1/orders/all Example request (staging) curl --request GET 'https://api-staging.rarible.org/v0.1/orders/all?size=1' Example response (status 200) { \"continuation\" : \"ETHEREUM:1648132257821_0x487cf9fc8c7713dd634e2d0698fde08fba134ce81e515a9c7b75121096ced384\" , \"orders\" : [ { \"id\" : \"ETHEREUM:0x487cf9fc8c7713dd634e2d0698fde08fba134ce81e515a9c7b75121096ced384\" , \"fill\" : \"0\" , \"platform\" : \"RARIBLE\" , \"status\" : \"ACTIVE\" , \"makeStock\" : \"1\" , \"cancelled\" : false , \"createdAt\" : \"2022-03-24T14:30:57.821Z\" , \"lastUpdatedAt\" : \"2022-03-24T14:30:57.821Z\" , \"makePrice\" : \"0.01\" , \"makePriceUsd\" : \"30.198384450784797\" , \"priceHistory\" : [ { \"date\" : \"2022-03-24T14:30:57.821Z\" , \"makeValue\" : \"1\" , \"takeValue\" : \"0.01\" } ], \"maker\" : \"ETHEREUM:0x402a19096d7e4d1cbe74fc92b4e21bf33614e1a5\" , \"make\" : { \"type\" : { \"@type\" : \"ERC721_Lazy\" , \"contract\" : \"ETHEREUM:0x6110ea0489c929b44152e99c133e17025a684223\" , \"tokenId\" : \"29022402683878927866272288177291204022157824894707812777715415655733163720747\" , \"uri\" : \"/ipfs/Qmb37SGcSV3ELHeZSzcZt5ymERUn9ug5vtqmPQfs7yFQUm\" , \"creators\" : [ { \"account\" : \"ETHEREUM:0x402a19096d7e4d1cbe74fc92b4e21bf33614e1a5\" , \"value\" : 10000 } ], \"royalties\" : [ { \"account\" : \"ETHEREUM:0x402a19096d7e4d1cbe74fc92b4e21bf33614e1a5\" , \"value\" : 1000 } ], \"signatures\" : [ \"0x60647533cdabee46b8e40b19cfcc588585d306ce061ddaf50e5dc8187ea6e0e955e91ef1d61a4cbf17dc81136bdadccf6052d54791fa3dbad65bd5925932e7191c\" ] }, \"value\" : \"1\" }, \"take\" : { \"type\" : { \"@type\" : \"ETH\" , \"blockchain\" : \"ETHEREUM\" }, \"value\" : \"0.01\" }, \"salt\" : \"0x4605d2c0a64793ea84b6b58edf2326356d5562eeeb4e550f2b79bb965f984ac4\" , \"signature\" : \"0xd67ffbe94321dce166ff3028546914547a9f6d44ba434db20e0244f83626862e41606a1254f5c7565bce88ae78d7f5f0214553b6dd6d5cd4f9198302d5c1fa781c\" , \"pending\" : [], \"data\" : { \"@type\" : \"ETH_RARIBLE_V2\" , \"payouts\" : [], \"originFees\" : [ { \"account\" : \"ETHEREUM:0x76c5855e93bd498b6331652854c4549d34bc3a30\" , \"value\" : 250 } ] } } ] } Collections \u00b6 get Collections by owner Returns Collections by owner https://api.rarible.org/v0.1/collections/byOwner Example request (staging) curl --request GET 'https://api-staging.rarible.org/v0.1/collections/byOwner?owner=ETHEREUM:0x8b3e026252ab4299d69779b4f533913e76a40420' Request parameters: owner \u2014 address of the collection owner, has format ${blockchain}:${address} . For example, ETHEREUM:0x8b3e026252ab4299d69779b4f533913e76a40420 Example response (status 200) { \"total\" : 1 , \"collections\" : [ { \"id\" : \"ETHEREUM:0x0000000007dbc95a44e65b0439427de8236c53d3\" , \"blockchain\" : \"ETHEREUM\" , \"type\" : \"ERC721\" , \"name\" : \"Test\" , \"symbol\" : \"TEST\" , \"owner\" : \"ETHEREUM:0x8b3e026252ab4299d69779b4f533913e76a40420\" , \"features\" : [ \"APPROVE_FOR_ALL\" ], \"minters\" : [], \"meta\" : { \"name\" : \"Untitled\" , \"content\" : [] } } ] } get Collection by Id Returns Collection by Id https://api.rarible.org/v0.1/collections/{collection} Example request (staging) curl --request GET 'https://api-staging.rarible.org/v0.1/collections/POLYGON:0x00000000004ba8d1691a4c215fd2bd99771dccc7' Request parameters: collection \u2014 collection address, has format ${blockchain}:${address} . For example, POLYGON:0x00000000004ba8d1691a4c215fd2bd99771dccc7 Example response (status 200) { \"id\" : \"POLYGON:0x00000000004ba8d1691a4c215fd2bd99771dccc7\" , \"blockchain\" : \"POLYGON\" , \"type\" : \"ERC721\" , \"name\" : \"LUCA\" , \"symbol\" : \"InvoiceNFT\" , \"features\" : [ \"APPROVE_FOR_ALL\" ], \"minters\" : [], \"meta\" : { \"name\" : \"Untitled\" , \"content\" : [] } } get All Collections Returns all Collections https://api.rarible.org/v0.1/collections/all Example request (staging) curl --request GET 'https://api-staging.rarible.org/v0.1/collections/all?blockchains=ETHEREUM&size=1' Example response (status 200) { \"total\" : 1 , \"continuation\" : \"ETHEREUM:0x0000000007dbc95a44e65b0439427de8236c53d3\" , \"collections\" : [ { \"id\" : \"ETHEREUM:0x0000000007dbc95a44e65b0439427de8236c53d3\" , \"blockchain\" : \"ETHEREUM\" , \"type\" : \"ERC721\" , \"name\" : \"Test\" , \"symbol\" : \"TEST\" , \"owner\" : \"ETHEREUM:0x8b3e026252ab4299d69779b4f533913e76a40420\" , \"features\" : [ \"APPROVE_FOR_ALL\" ], \"minters\" : [], \"meta\" : { \"name\" : \"Untitled\" , \"content\" : [] } } ] } Ownerships \u00b6 get Ownerships by Item Returns Ownerships by Item https://api.rarible.org/v0.1/ownerships/byItem Example request (staging) curl --request GET 'https://api-staging.rarible.org/v0.1/ownerships/byItem?itemId=ETHEREUM:0x63ad270fc18f6f9435c3e205f06e003d3b861d33:765' Request parameters: itemId \u2014 Id of your NFT, has format ${blockchain}:${token}:${tokenId} . For example, ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:12345 Example response (status 200) { \"total\" : 1 , \"ownerships\" : [ { \"id\" : \"ETHEREUM:0x63ad270fc18f6f9435c3e205f06e003d3b861d33:765:0xe64ebc77ef72df8a7689d8928bc004b9e7ff43b3\" , \"blockchain\" : \"ETHEREUM\" , \"itemId\" : \"ETHEREUM:0x63ad270fc18f6f9435c3e205f06e003d3b861d33:765\" , \"contract\" : \"ETHEREUM:0x63ad270fc18f6f9435c3e205f06e003d3b861d33\" , \"collection\" : \"ETHEREUM:0x63ad270fc18f6f9435c3e205f06e003d3b861d33\" , \"tokenId\" : \"765\" , \"owner\" : \"ETHEREUM:0xe64ebc77ef72df8a7689d8928bc004b9e7ff43b3\" , \"value\" : \"1\" , \"createdAt\" : \"2022-03-24T16:20:05.015Z\" , \"creators\" : [], \"lazyValue\" : \"0\" , \"pending\" : [] } ] } get Ownerships by Id Returns Ownerships by Id https://api.rarible.org/v0.1/ownerships/{ownershipId} Example request (staging) curl --request GET 'https://api-staging.rarible.org/v0.1/ownerships/ETHEREUM:0x63ad270fc18f6f9435c3e205f06e003d3b861d33:765:0xe64ebc77ef72df8a7689d8928bc004b9e7ff43b3' Request parameters: ownershipId \u2014 ownership Id in format ${blockchain}:${token}:${tokenId}:${owner} . For example, ETHEREUM:0x63ad270fc18f6f9435c3e205f06e003d3b861d33:765:0xe64ebc77ef72df8a7689d8928bc004b9e7ff43b3 Example response (status 200) { \"id\" : \"ETHEREUM:0x63ad270fc18f6f9435c3e205f06e003d3b861d33:765:0xe64ebc77ef72df8a7689d8928bc004b9e7ff43b3\" , \"blockchain\" : \"ETHEREUM\" , \"itemId\" : \"ETHEREUM:0x63ad270fc18f6f9435c3e205f06e003d3b861d33:765\" , \"contract\" : \"ETHEREUM:0x63ad270fc18f6f9435c3e205f06e003d3b861d33\" , \"collection\" : \"ETHEREUM:0x63ad270fc18f6f9435c3e205f06e003d3b861d33\" , \"tokenId\" : \"765\" , \"owner\" : \"ETHEREUM:0xe64ebc77ef72df8a7689d8928bc004b9e7ff43b3\" , \"value\" : \"1\" , \"createdAt\" : \"2022-03-24T16:20:05.015Z\" , \"creators\" : [], \"lazyValue\" : \"0\" , \"pending\" : [] } Activity \u00b6 We have several query parameters for paging and continuation in the Activity controller methods: size \u2014 the maximum number of results per page to return continuation \u2014 deprecated parameter cursor \u2014 combined continuation token from the previous response, type of page token. Can be used to get the next page of results in a subsequent list request. Has format ${BLOCKCHAIN}:${TS_MS}_{ENTITY_ID};... , where: BLOCKCHAIN \u2014 blockchain name: ETHEREUM , FLOW , TEZOS , POLYGON or SOLANA TS_MS \u2014 timestamp of the data in ms ENTITY_ID \u2014 entity identifier, different blockchains have different identifier formats For example: POLYGON:1649395092000_624fc5956f6dc654e6095b90 ; ETHEREUM:1649395762000_624fc83a63c052298d2e2b61 ; SOLANA:1649395777000_000126563148:EjGVpJkNpjCakf5WcN13b8rZzxvDAnjVm7mgLam812xm:000185:4fGmEP5Cm3MURsGJ8mx1uEC7c2sWsVrAGdjC2PfCbamj5ZKZwwCRYTUWyoY3Yzo3JYr5TGqJEUnmB6ejFPChTNKJ:000000:000001 ; TEZOS:1649260825000_BMQpZgFjvunjfqe7JPbRihLxrAv89vR9wtaHBpf8H6FULqXQM6o_243 ; FLOW:1649159220612_a4a4ad0e64aa0a3e6820f8a546d9355045eb1ca2f4818b85f5c0085f8cae04b9.64 If the blockchain is not specified in the cursor , then no entries have been found for it according to the sorting results. To get the next page of results, set cursor returned by a previous list request. But we recommend using the cursor in automated mode, because it is not designed to be built by hand. If you still want to use it manually, use the following example to get the correct data. getAllActivities example https://api-staging.rarible.org/v0.1/activities/all Specify the query parameters: blockchains , activity type , and size : curl --request GET 'https://api-staging.rarible.org/v0.1/activities/all?blockchains=ETHEREUM&type=MINT&size=3' Example response (status 200) { \"continuation\" : \"1649398291000_624fd21b63c052298d2e43f9\" , \"cursor\" : \"ETHEREUM:1649398291000_624fd21b63c052298d2e43f9\" , \"activities\" : [ { \"@type\" : \"MINT\" , \"id\" : \"ETHEREUM:624fd23963c052298d2e4407\" , \"date\" : \"2022-04-08T06:12:02Z\" , \"reverted\" : false , \"owner\" : \"ETHEREUM:0x33b5606763150120076308076c91f01132a799da\" , \"contract\" : \"ETHEREUM:0x2703b3753930fe36b5af2b9b6cba1615fdf31310\" , \"tokenId\" : \"2\" , \"itemId\" : \"ETHEREUM:0x2703b3753930fe36b5af2b9b6cba1615fdf31310:2\" , \"value\" : \"1\" , \"transactionHash\" : \"0x74fd40687d29f2ac584c14b46ad871d82e0fbe3332a2679370b1117c4fac0e57\" , \"blockchainInfo\" : { \"transactionHash\" : \"0x74fd40687d29f2ac584c14b46ad871d82e0fbe3332a2679370b1117c4fac0e57\" , \"blockHash\" : \"0xbd49cf6e7aad7c7e693ea675048033bfdfdea9665374de27283ee045ba7c9b91\" , \"blockNumber\" : 10467061 , \"logIndex\" : 21 } }, { \"@type\" : \"MINT\" , \"id\" : \"ETHEREUM:624fd23963c052298d2e4406\" , \"date\" : \"2022-04-08T06:12:02Z\" , \"reverted\" : false , \"owner\" : \"ETHEREUM:0xd4f6cb0c1fe07407b7098ac7fe4265f3b2ae61f2\" , \"contract\" : \"ETHEREUM:0x1e1e3fed3e83dfe729a29ace3b588169a586fd18\" , \"tokenId\" : \"1\" , \"itemId\" : \"ETHEREUM:0x1e1e3fed3e83dfe729a29ace3b588169a586fd18:1\" , \"value\" : \"1\" , \"transactionHash\" : \"0xa47279f35076d084a5bfa5abd4de71a3226d5b5f7424ceaa52fa81d179a2b8d6\" , \"blockchainInfo\" : { \"transactionHash\" : \"0xa47279f35076d084a5bfa5abd4de71a3226d5b5f7424ceaa52fa81d179a2b8d6\" , \"blockHash\" : \"0xbd49cf6e7aad7c7e693ea675048033bfdfdea9665374de27283ee045ba7c9b91\" , \"blockNumber\" : 10467061 , \"logIndex\" : 0 } }, { \"@type\" : \"MINT\" , \"id\" : \"ETHEREUM:624fd21b63c052298d2e43f9\" , \"date\" : \"2022-04-08T06:11:31Z\" , \"reverted\" : false , \"owner\" : \"ETHEREUM:0x739cc4746e106d050f757bcece2aafc9f2eaaa28\" , \"contract\" : \"ETHEREUM:0x25b284f96106bb046b9bd99ab167f060bcf18982\" , \"tokenId\" : \"10\" , \"itemId\" : \"ETHEREUM:0x25b284f96106bb046b9bd99ab167f060bcf18982:10\" , \"value\" : \"1\" , \"transactionHash\" : \"0x990b3b2157dad093de018da254fc52adbd89737c72cbd1a443253897a74a4161\" , \"blockchainInfo\" : { \"transactionHash\" : \"0x990b3b2157dad093de018da254fc52adbd89737c72cbd1a443253897a74a4161\" , \"blockHash\" : \"0xe5b01f69dba978cb52907a6d12938550fcab5bac1572c9d7ca5c7fab30d32c84\" , \"blockNumber\" : 10467059 , \"logIndex\" : 6 } } ] } As we see, ENTITY_ID part in the cursor is the same as id of the last element in the response: { ... \"cursor\" : \"ETHEREUM:1649398291000_624fd21b63c052298d2e43f9\" , \"activities\" : [ { ... { ... \"id\" : \"ETHEREUM:624fd21b63c052298d2e43f9\" , ... } } ] } Take the resulting cursor and add it to the new query: curl --request GET 'https://api-staging.rarible.org/v0.1/activities/all?blockchains=ETHEREUM&type=MINT&cursor=ETHEREUM:1649398291000_624fd21b63c052298d2e43f9&size=3' Example response (status 200) { \"cursor\" : \"ETHEREUM:1649398276000_624fd20e63c052298d2e42f6\" , \"activities\" : [ { \"@type\" : \"MINT\" , \"id\" : \"ETHEREUM:624fd20f63c052298d2e43e3\" , \"date\" : \"2022-04-08T06:11:16Z\" , \"reverted\" : false , \"owner\" : \"ETHEREUM:0x77054b00ddbbe9c597d93156b964fc115dbc1685\" , \"contract\" : \"ETHEREUM:0xce92876be6f0e6c795d55aca4eec1986c6db35eb\" , \"tokenId\" : \"1011\" , \"itemId\" : \"ETHEREUM:0xce92876be6f0e6c795d55aca4eec1986c6db35eb:1011\" , \"value\" : \"1\" , \"transactionHash\" : \"0xf6cd37b1ce91f16b0f4a1dce86e78d59b4cba6ad7352eaa15cb6fc32c853362a\" , \"blockchainInfo\" : { \"transactionHash\" : \"0xf6cd37b1ce91f16b0f4a1dce86e78d59b4cba6ad7352eaa15cb6fc32c853362a\" , \"blockHash\" : \"0xc5a24c1dc49b5551b06f805edb4dd782cd46b3f21de71d3b250de6d767a625d9\" , \"blockNumber\" : 10467058 , \"logIndex\" : 508 } }, { \"@type\" : \"MINT\" , \"id\" : \"ETHEREUM:624fd20f63c052298d2e43e2\" , \"date\" : \"2022-04-08T06:11:16Z\" , \"reverted\" : false , \"owner\" : \"ETHEREUM:0x77054b00ddbbe9c597d93156b964fc115dbc1685\" , \"contract\" : \"ETHEREUM:0xce92876be6f0e6c795d55aca4eec1986c6db35eb\" , \"tokenId\" : \"1012\" , \"itemId\" : \"ETHEREUM:0xce92876be6f0e6c795d55aca4eec1986c6db35eb:1012\" , \"value\" : \"1\" , \"transactionHash\" : \"0xf6cd37b1ce91f16b0f4a1dce86e78d59b4cba6ad7352eaa15cb6fc32c853362a\" , \"blockchainInfo\" : { \"transactionHash\" : \"0xf6cd37b1ce91f16b0f4a1dce86e78d59b4cba6ad7352eaa15cb6fc32c853362a\" , \"blockHash\" : \"0xc5a24c1dc49b5551b06f805edb4dd782cd46b3f21de71d3b250de6d767a625d9\" , \"blockNumber\" : 10467058 , \"logIndex\" : 507 } }, { \"@type\" : \"MINT\" , \"id\" : \"ETHEREUM:624fd20e63c052298d2e42f6\" , \"date\" : \"2022-04-08T06:11:16Z\" , \"reverted\" : false , \"owner\" : \"ETHEREUM:0x0ade6d84cb1b8fe9ab8c8145f53b202c426a34f3\" , \"contract\" : \"ETHEREUM:0x4fc8df260a04683421d3949baf182f9556f3a9f9\" , \"tokenId\" : \"2\" , \"itemId\" : \"ETHEREUM:0x4fc8df260a04683421d3949baf182f9556f3a9f9:2\" , \"value\" : \"1\" , \"transactionHash\" : \"0xbf231cf9a46ff83484eb39ac73c1d4a806e8376a19fc3c6549d7777c186cd2b3\" , \"blockchainInfo\" : { \"transactionHash\" : \"0xbf231cf9a46ff83484eb39ac73c1d4a806e8376a19fc3c6549d7777c186cd2b3\" , \"blockHash\" : \"0xc5a24c1dc49b5551b06f805edb4dd782cd46b3f21de71d3b250de6d767a625d9\" , \"blockNumber\" : 10467058 , \"logIndex\" : 17 } } ] } Repeat this step with the newly obtained cursor , if necessary. On the multichain-api.rarible.org you can find more information about Protocol Multichain API.","title":"Search Capabilities"},{"location":"reference/search-capabilities/#search-capabilities","text":"On the multichain-api.rarible.org you can find main information about Protocol API.","title":"Search Capabilities"},{"location":"reference/search-capabilities/#controllers","text":"Use the following controllers to search information about NFT with our multichain API: Signature controller \u2014 uses for validation of the order signature Currency controller \u2014 getting currency USD rate Item controller \u2014 getting information about NFT items Ownership controller \u2014 getting information about NFT items ownership Order controller \u2014 getting information about NFT orders Auction controller \u2014 getting information about NFT auctions Activity controller \u2014 getting information about activities with NFT Collection controller \u2014 getting information about NFT collections","title":"Controllers"},{"location":"reference/search-capabilities/#api-usage-examples","text":"","title":"API usage Examples"},{"location":"reference/search-capabilities/#items","text":"get Item by owner Returns Item by owner https://api.rarible.org/v0.1/items/byOwner Example request (staging) curl --request GET 'https://api-staging.rarible.org/v0.1/items/byOwner?owner=ETHEREUM:0x66606fe12f319a8f781a9af35c3d061617ea642a&size=1' Request parameters: owner \u2014 address of the item owner, has format ${blockchain}:${address} . For example, ETHEREUM:0x66606fe12f319a8f781a9af35c3d061617ea642a Example response (status 200) { \"total\" : 1 , \"continuation\" : \"1648125753039_0x08295565739cf720f2a61e5237815eacfad98c6a:2102\" , \"items\" : [ { \"id\" : \"ETHEREUM:0x08295565739cf720f2a61e5237815eacfad98c6a:2102\" , \"blockchain\" : \"ETHEREUM\" , \"collection\" : \"ETHEREUM:0x08295565739cf720f2a61e5237815eacfad98c6a\" , \"contract\" : \"ETHEREUM:0x08295565739cf720f2a61e5237815eacfad98c6a\" , \"tokenId\" : \"2102\" , \"creators\" : [ { \"account\" : \"ETHEREUM:0x66606fe12f319a8f781a9af35c3d061617ea642a\" , \"value\" : 10000 } ], \"owners\" : [], \"royalties\" : [], \"lazySupply\" : \"0\" , \"pending\" : [], \"mintedAt\" : \"2022-03-24T12:42:33Z\" , \"lastUpdatedAt\" : \"2022-03-24T12:42:33.039Z\" , \"supply\" : \"1\" , \"meta\" : { \"name\" : \"\u634c\uff1a\u4eba\u6d77\u832b\u832b #\\n2102\" , \"description\" : \"\u4eba\u6d77\u554a\u832b\u832b\u554a-\u300a\u6d77\u8349\u821e\u300bNFT \\n\\n\u4eba\u6d77\u554a \u832b\u832b\u554a \u968f\u6ce2\u9010\u6d41 \u6d6e\u6d6e\u6c89\u6c89\" , \"attributes\" : [ { \"key\" : \"\u6f14\u5531\" , \"value\" : \"\u8427\u5168\" }, { \"key\" : \"\u4f5c\u8bcd\" , \"value\" : \"\u8427\u5168\" }, { \"key\" : \"\u4f5c\u66f2\" , \"value\" : \"\u8427\u5168\" }, { \"key\" : \"\u7a00\u6709\u5ea6\" , \"value\" : \"\u7f55\u89c1\" } ], \"content\" : [ { \"@type\" : \"IMAGE\" , \"url\" : \"https://rarible.mypinata.cloud/ipfs/QmbyFuDKZc9UkxMNJ7t25cZk7mm8u77c3FENFsatxN4VNk/8.png\" , \"representation\" : \"ORIGINAL\" }, { \"@type\" : \"IMAGE\" , \"url\" : \"https://lh3.googleusercontent.com/t55AtJJ9szplBUbEchUAE_tyZuYTeSenjd7iHfVPfwsvIX3lof2kcI9jzGcpZ1Prf3oFiYLdcVsO0aFNCo-j6sgYUY0x32IEngz9s8I\" , \"representation\" : \"BIG\" }, { \"@type\" : \"IMAGE\" , \"url\" : \"https://lh3.googleusercontent.com/t55AtJJ9szplBUbEchUAE_tyZuYTeSenjd7iHfVPfwsvIX3lof2kcI9jzGcpZ1Prf3oFiYLdcVsO0aFNCo-j6sgYUY0x32IEngz9s8I=s250\" , \"representation\" : \"PREVIEW\" }, { \"@type\" : \"VIDEO\" , \"url\" : \"https://storage.opensea.io/files/cec338c0f5685f3037096b7bed283e15.wav\" , \"representation\" : \"ORIGINAL\" } ], \"restrictions\" : [] }, \"deleted\" : false , \"auctions\" : [], \"totalStock\" : \"0\" , \"sellers\" : 0 } ] } get Item by Id Returns Item by Id https://api.rarible.org/v0.1/items/{itemId} Example request (staging) curl --request GET 'https://api-staging.rarible.org/v0.1/items/ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:19661880631107248865491477079747186145992059189823053172927066273904580362243' Request parameters: itemId \u2014 Id of your NFT, has format ${blockchain}:${token}:${tokenId} . For example, ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:12345 Example response (status 200) { \"id\" : \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:19661880631107248865491477079747186145992059189823053172927066273904580362243\" , \"blockchain\" : \"ETHEREUM\" , \"collection\" : \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82\" , \"contract\" : \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82\" , \"tokenId\" : \"19661880631107248865491477079747186145992059189823053172927066273904580362243\" , \"creators\" : [ { \"account\" : \"ETHEREUM:0x2b783ae5b5b8a7a822449c7d8b6f35f9abc827f5\" , \"value\" : 10000 } ], \"owners\" : [], \"royalties\" : [], \"lazySupply\" : \"0\" , \"pending\" : [], \"mintedAt\" : \"2022-03-09T22:48:33Z\" , \"lastUpdatedAt\" : \"2022-03-09T22:50:03.530Z\" , \"supply\" : \"1\" , \"meta\" : { \"name\" : \"gbgbgbgbgbgb\" , \"description\" : \"\" , \"attributes\" : [], \"content\" : [ { \"@type\" : \"IMAGE\" , \"url\" : \"https://rarible.mypinata.cloud/ipfs/QmQCp8bhbaPwGEuHeeR8pme2q3zuSjam2JEuFgAvp4DZsU/image.jpeg\" , \"representation\" : \"ORIGINAL\" , \"mimeType\" : \"image/jpeg\" , \"size\" : 13311 , \"width\" : 640 , \"height\" : 640 } ], \"restrictions\" : [] }, \"deleted\" : false , \"auctions\" : [], \"totalStock\" : \"0\" , \"sellers\" : 0 } get All Items Returns All Items https://api.rarible.org/v0.1/items/all Example request (staging) curl --request GET 'https://api.rarible.org/v0.1/items/all?blockchains=POLYGON&size=1' Example response (status 200) { \"total\" : 1 , \"continuation\" : \"POLYGON:1648131545251_0x4d544035500d7ac1b42329c70eb58e77f8249f0f:3874767738\" , \"items\" : [ { \"id\" : \"POLYGON:0x4d544035500d7ac1b42329c70eb58e77f8249f0f:3874767738\" , \"blockchain\" : \"POLYGON\" , \"collection\" : \"POLYGON:0x4d544035500d7ac1b42329c70eb58e77f8249f0f\" , \"contract\" : \"POLYGON:0x4d544035500d7ac1b42329c70eb58e77f8249f0f\" , \"tokenId\" : \"3874767738\" , \"creators\" : [ { \"account\" : \"ETHEREUM:0x517c295d34137a2f4b3026656c09dd62e668fc72\" , \"value\" : 10000 } ], \"owners\" : [], \"royalties\" : [], \"lazySupply\" : \"0\" , \"pending\" : [], \"mintedAt\" : \"2022-03-24T14:18:11Z\" , \"lastUpdatedAt\" : \"2022-03-24T14:19:05.251Z\" , \"supply\" : \"1\" , \"meta\" : { \"name\" : \"LOK Food 5M\" , \"description\" : \"League of Kingdoms Resource\" , \"attributes\" : [], \"content\" : [ { \"@type\" : \"IMAGE\" , \"url\" : \"https://lok-nft.leagueofkingdoms.com/resource/10101020.png\" , \"representation\" : \"ORIGINAL\" , \"mimeType\" : \"image/png\" , \"width\" : 200 , \"height\" : 200 } ], \"restrictions\" : [] }, \"deleted\" : false , \"auctions\" : [], \"totalStock\" : \"0\" , \"sellers\" : 0 } ] }","title":"Items"},{"location":"reference/search-capabilities/#orders","text":"get Order by Id Returns Order by Id https://api.rarible.org/v0.1/orders/{id} Example request (staging) curl --request GET 'https://api-staging.rarible.org/v0.1/orders/ETHEREUM:0x1641f3a030a1e810abe15c70320ab0e4cf1ee59c0baa3a77cf8b409aa0a0d320' Request parameters: id \u2014 order Id, has format ${blockchain}:${id} . For example, ETHEREUM:0x1641f3a030a1e810abe15c70320ab0e4cf1ee59c0baa3a77cf8b409aa0a0d320 Example response (status 200) { \"id\" : \"ETHEREUM:0x1641f3a030a1e810abe15c70320ab0e4cf1ee59c0baa3a77cf8b409aa0a0d320\" , \"fill\" : \"0\" , \"platform\" : \"OPEN_SEA\" , \"status\" : \"INACTIVE\" , \"startedAt\" : \"2022-03-24T14:27:33Z\" , \"endedAt\" : \"2022-09-20T14:29:08Z\" , \"makeStock\" : \"0\" , \"cancelled\" : false , \"createdAt\" : \"2022-03-24T14:29:15.790Z\" , \"lastUpdatedAt\" : \"2022-03-24T14:29:15.790Z\" , \"makePrice\" : \"0.01\" , \"makePriceUsd\" : \"30.198384450784797\" , \"priceHistory\" : [ { \"date\" : \"2022-03-24T14:29:15.790Z\" , \"makeValue\" : \"1\" , \"takeValue\" : \"0.01\" } ], \"maker\" : \"ETHEREUM:0xe59072c5084ec2dc16e6bcdc3560802ffbafb5cb\" , \"make\" : { \"type\" : { \"@type\" : \"ERC1155\" , \"contract\" : \"ETHEREUM:0x88b48f654c30e99bc2e4a1559b4dcf1ad93fa656\" , \"tokenId\" : \"103834860413964016633619762390589326621035685084276300587330678503415507582977\" }, \"value\" : \"1\" }, \"take\" : { \"type\" : { \"@type\" : \"ETH\" , \"blockchain\" : \"ETHEREUM\" }, \"value\" : \"0.01\" }, \"salt\" : \"0xd49cbf21e348826dff4760cf9c22af9bd877809341ad0e5d0e899d60d8d59553\" , \"signature\" : \"0x45face93c43bdb3375e02b5140c4ec380a112b82c81fa78a5f6e7d15206d997629e5427476302f66cfae79488ca5591bc667de4c8847b56c81d90e2a76a9f8021c\" , \"pending\" : [], \"data\" : { \"@type\" : \"ETH_OPEN_SEA_V1\" , \"exchange\" : \"ETHEREUM:0xdd54d660178b28f6033a953b0e55073cfa7e3744\" , \"makerRelayerFee\" : \"1250\" , \"takerRelayerFee\" : \"0\" , \"makerProtocolFee\" : \"0\" , \"takerProtocolFee\" : \"0\" , \"feeRecipient\" : \"ETHEREUM:0x5b3256965e7c3cf26e11fcaf296dfc8807c01073\" , \"feeMethod\" : \"SPLIT_FEE\" , \"side\" : \"SELL\" , \"saleKind\" : \"FIXED_PRICE\" , \"howToCall\" : \"DELEGATE_CALL\" , \"callData\" : \"0x96809f90000000000000000000000000e59072c5084ec2dc16e6bcdc3560802ffbafb5cb000000000000000000000000000000000000000000000000000000000000000000000000000000000000000088b48f654c30e99bc2e4a1559b4dcf1ad93fa656e59072c5084ec2dc16e6bcdc3560802ffbafb5cb00000000000a9e00000000010000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000000\" , \"replacementPattern\" : \"0x000000000000000000000000000000000000000000000000000000000000000000000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\" , \"staticTarget\" : \"ETHEREUM:0x0000000000000000000000000000000000000000\" , \"staticExtraData\" : \"0x\" , \"extra\" : \"0\" } } get Sell Orders by maker Returns Sell Orders by maker https://api.rarible.org/v0.1/orders/sell/byMaker Example request (staging) curl --request GET 'https://api-staging.rarible.org/v0.1/orders/sell/byMaker?maker=ETHEREUM:0xe59072c5084ec2dc16e6bcdc3560802ffbafb5cb&size=1' Request parameters: maker \u2014 the maker of the order, has format ${blockchain}:${id} . For example, ETHEREUM:0xe59072c5084ec2dc16e6bcdc3560802ffbafb5cb Example response (status 200) { \"continuation\" : \"1648132919811_0xf8e3f895591ac3f6ff4a516ea17ac1c12b21c3d93acfa3e808e16f1467bb7c52\" , \"orders\" : [ { \"id\" : \"ETHEREUM:0xf8e3f895591ac3f6ff4a516ea17ac1c12b21c3d93acfa3e808e16f1467bb7c52\" , \"fill\" : \"0\" , \"platform\" : \"OPEN_SEA\" , \"status\" : \"INACTIVE\" , \"startedAt\" : \"2022-03-24T14:40:16Z\" , \"endedAt\" : \"2022-09-20T14:41:52Z\" , \"makeStock\" : \"0\" , \"cancelled\" : false , \"createdAt\" : \"2022-03-24T14:41:59.811Z\" , \"lastUpdatedAt\" : \"2022-03-24T14:41:59.811Z\" , \"makePrice\" : \"0.01\" , \"makePriceUsd\" : \"30.198384450784797\" , \"priceHistory\" : [ { \"date\" : \"2022-03-24T14:41:59.811Z\" , \"makeValue\" : \"1\" , \"takeValue\" : \"0.01\" } ], \"maker\" : \"ETHEREUM:0xe59072c5084ec2dc16e6bcdc3560802ffbafb5cb\" , \"make\" : { \"type\" : { \"@type\" : \"ERC1155\" , \"contract\" : \"ETHEREUM:0x88b48f654c30e99bc2e4a1559b4dcf1ad93fa656\" , \"tokenId\" : \"103834860413964016633619762390589326621035685084276300587330678545196949438465\" }, \"value\" : \"1\" }, \"take\" : { \"type\" : { \"@type\" : \"ETH\" , \"blockchain\" : \"ETHEREUM\" }, \"value\" : \"0.01\" }, \"salt\" : \"0x0b06c99560930d99286981d16bdee68a8a10e872bc7718e662a144ab63eb854b\" , \"signature\" : \"0xee243d7bdb69518ea6c9c9cbfb4163e49111ec476b870f07c61c549b72927d332321ba1fceb1b2db7e26e4994a25fc18e0da2e729737deb8ae84f0c54c7f3d7c1c\" , \"pending\" : [], \"data\" : { \"@type\" : \"ETH_OPEN_SEA_V1\" , \"exchange\" : \"ETHEREUM:0xdd54d660178b28f6033a953b0e55073cfa7e3744\" , \"makerRelayerFee\" : \"1250\" , \"takerRelayerFee\" : \"0\" , \"makerProtocolFee\" : \"0\" , \"takerProtocolFee\" : \"0\" , \"feeRecipient\" : \"ETHEREUM:0x5b3256965e7c3cf26e11fcaf296dfc8807c01073\" , \"feeMethod\" : \"SPLIT_FEE\" , \"side\" : \"SELL\" , \"saleKind\" : \"FIXED_PRICE\" , \"howToCall\" : \"DELEGATE_CALL\" , \"callData\" : \"0x96809f90000000000000000000000000e59072c5084ec2dc16e6bcdc3560802ffbafb5cb000000000000000000000000000000000000000000000000000000000000000000000000000000000000000088b48f654c30e99bc2e4a1559b4dcf1ad93fa656e59072c5084ec2dc16e6bcdc3560802ffbafb5cb00000000000ac400000000010000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000000\" , \"replacementPattern\" : \"0x000000000000000000000000000000000000000000000000000000000000000000000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\" , \"staticTarget\" : \"ETHEREUM:0x0000000000000000000000000000000000000000\" , \"staticExtraData\" : \"0x\" , \"extra\" : \"0\" } } ] } get All Orders Returns all Orders https://api.rarible.org/v0.1/orders/all Example request (staging) curl --request GET 'https://api-staging.rarible.org/v0.1/orders/all?size=1' Example response (status 200) { \"continuation\" : \"ETHEREUM:1648132257821_0x487cf9fc8c7713dd634e2d0698fde08fba134ce81e515a9c7b75121096ced384\" , \"orders\" : [ { \"id\" : \"ETHEREUM:0x487cf9fc8c7713dd634e2d0698fde08fba134ce81e515a9c7b75121096ced384\" , \"fill\" : \"0\" , \"platform\" : \"RARIBLE\" , \"status\" : \"ACTIVE\" , \"makeStock\" : \"1\" , \"cancelled\" : false , \"createdAt\" : \"2022-03-24T14:30:57.821Z\" , \"lastUpdatedAt\" : \"2022-03-24T14:30:57.821Z\" , \"makePrice\" : \"0.01\" , \"makePriceUsd\" : \"30.198384450784797\" , \"priceHistory\" : [ { \"date\" : \"2022-03-24T14:30:57.821Z\" , \"makeValue\" : \"1\" , \"takeValue\" : \"0.01\" } ], \"maker\" : \"ETHEREUM:0x402a19096d7e4d1cbe74fc92b4e21bf33614e1a5\" , \"make\" : { \"type\" : { \"@type\" : \"ERC721_Lazy\" , \"contract\" : \"ETHEREUM:0x6110ea0489c929b44152e99c133e17025a684223\" , \"tokenId\" : \"29022402683878927866272288177291204022157824894707812777715415655733163720747\" , \"uri\" : \"/ipfs/Qmb37SGcSV3ELHeZSzcZt5ymERUn9ug5vtqmPQfs7yFQUm\" , \"creators\" : [ { \"account\" : \"ETHEREUM:0x402a19096d7e4d1cbe74fc92b4e21bf33614e1a5\" , \"value\" : 10000 } ], \"royalties\" : [ { \"account\" : \"ETHEREUM:0x402a19096d7e4d1cbe74fc92b4e21bf33614e1a5\" , \"value\" : 1000 } ], \"signatures\" : [ \"0x60647533cdabee46b8e40b19cfcc588585d306ce061ddaf50e5dc8187ea6e0e955e91ef1d61a4cbf17dc81136bdadccf6052d54791fa3dbad65bd5925932e7191c\" ] }, \"value\" : \"1\" }, \"take\" : { \"type\" : { \"@type\" : \"ETH\" , \"blockchain\" : \"ETHEREUM\" }, \"value\" : \"0.01\" }, \"salt\" : \"0x4605d2c0a64793ea84b6b58edf2326356d5562eeeb4e550f2b79bb965f984ac4\" , \"signature\" : \"0xd67ffbe94321dce166ff3028546914547a9f6d44ba434db20e0244f83626862e41606a1254f5c7565bce88ae78d7f5f0214553b6dd6d5cd4f9198302d5c1fa781c\" , \"pending\" : [], \"data\" : { \"@type\" : \"ETH_RARIBLE_V2\" , \"payouts\" : [], \"originFees\" : [ { \"account\" : \"ETHEREUM:0x76c5855e93bd498b6331652854c4549d34bc3a30\" , \"value\" : 250 } ] } } ] }","title":"Orders"},{"location":"reference/search-capabilities/#collections","text":"get Collections by owner Returns Collections by owner https://api.rarible.org/v0.1/collections/byOwner Example request (staging) curl --request GET 'https://api-staging.rarible.org/v0.1/collections/byOwner?owner=ETHEREUM:0x8b3e026252ab4299d69779b4f533913e76a40420' Request parameters: owner \u2014 address of the collection owner, has format ${blockchain}:${address} . For example, ETHEREUM:0x8b3e026252ab4299d69779b4f533913e76a40420 Example response (status 200) { \"total\" : 1 , \"collections\" : [ { \"id\" : \"ETHEREUM:0x0000000007dbc95a44e65b0439427de8236c53d3\" , \"blockchain\" : \"ETHEREUM\" , \"type\" : \"ERC721\" , \"name\" : \"Test\" , \"symbol\" : \"TEST\" , \"owner\" : \"ETHEREUM:0x8b3e026252ab4299d69779b4f533913e76a40420\" , \"features\" : [ \"APPROVE_FOR_ALL\" ], \"minters\" : [], \"meta\" : { \"name\" : \"Untitled\" , \"content\" : [] } } ] } get Collection by Id Returns Collection by Id https://api.rarible.org/v0.1/collections/{collection} Example request (staging) curl --request GET 'https://api-staging.rarible.org/v0.1/collections/POLYGON:0x00000000004ba8d1691a4c215fd2bd99771dccc7' Request parameters: collection \u2014 collection address, has format ${blockchain}:${address} . For example, POLYGON:0x00000000004ba8d1691a4c215fd2bd99771dccc7 Example response (status 200) { \"id\" : \"POLYGON:0x00000000004ba8d1691a4c215fd2bd99771dccc7\" , \"blockchain\" : \"POLYGON\" , \"type\" : \"ERC721\" , \"name\" : \"LUCA\" , \"symbol\" : \"InvoiceNFT\" , \"features\" : [ \"APPROVE_FOR_ALL\" ], \"minters\" : [], \"meta\" : { \"name\" : \"Untitled\" , \"content\" : [] } } get All Collections Returns all Collections https://api.rarible.org/v0.1/collections/all Example request (staging) curl --request GET 'https://api-staging.rarible.org/v0.1/collections/all?blockchains=ETHEREUM&size=1' Example response (status 200) { \"total\" : 1 , \"continuation\" : \"ETHEREUM:0x0000000007dbc95a44e65b0439427de8236c53d3\" , \"collections\" : [ { \"id\" : \"ETHEREUM:0x0000000007dbc95a44e65b0439427de8236c53d3\" , \"blockchain\" : \"ETHEREUM\" , \"type\" : \"ERC721\" , \"name\" : \"Test\" , \"symbol\" : \"TEST\" , \"owner\" : \"ETHEREUM:0x8b3e026252ab4299d69779b4f533913e76a40420\" , \"features\" : [ \"APPROVE_FOR_ALL\" ], \"minters\" : [], \"meta\" : { \"name\" : \"Untitled\" , \"content\" : [] } } ] }","title":"Collections"},{"location":"reference/search-capabilities/#ownerships","text":"get Ownerships by Item Returns Ownerships by Item https://api.rarible.org/v0.1/ownerships/byItem Example request (staging) curl --request GET 'https://api-staging.rarible.org/v0.1/ownerships/byItem?itemId=ETHEREUM:0x63ad270fc18f6f9435c3e205f06e003d3b861d33:765' Request parameters: itemId \u2014 Id of your NFT, has format ${blockchain}:${token}:${tokenId} . For example, ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:12345 Example response (status 200) { \"total\" : 1 , \"ownerships\" : [ { \"id\" : \"ETHEREUM:0x63ad270fc18f6f9435c3e205f06e003d3b861d33:765:0xe64ebc77ef72df8a7689d8928bc004b9e7ff43b3\" , \"blockchain\" : \"ETHEREUM\" , \"itemId\" : \"ETHEREUM:0x63ad270fc18f6f9435c3e205f06e003d3b861d33:765\" , \"contract\" : \"ETHEREUM:0x63ad270fc18f6f9435c3e205f06e003d3b861d33\" , \"collection\" : \"ETHEREUM:0x63ad270fc18f6f9435c3e205f06e003d3b861d33\" , \"tokenId\" : \"765\" , \"owner\" : \"ETHEREUM:0xe64ebc77ef72df8a7689d8928bc004b9e7ff43b3\" , \"value\" : \"1\" , \"createdAt\" : \"2022-03-24T16:20:05.015Z\" , \"creators\" : [], \"lazyValue\" : \"0\" , \"pending\" : [] } ] } get Ownerships by Id Returns Ownerships by Id https://api.rarible.org/v0.1/ownerships/{ownershipId} Example request (staging) curl --request GET 'https://api-staging.rarible.org/v0.1/ownerships/ETHEREUM:0x63ad270fc18f6f9435c3e205f06e003d3b861d33:765:0xe64ebc77ef72df8a7689d8928bc004b9e7ff43b3' Request parameters: ownershipId \u2014 ownership Id in format ${blockchain}:${token}:${tokenId}:${owner} . For example, ETHEREUM:0x63ad270fc18f6f9435c3e205f06e003d3b861d33:765:0xe64ebc77ef72df8a7689d8928bc004b9e7ff43b3 Example response (status 200) { \"id\" : \"ETHEREUM:0x63ad270fc18f6f9435c3e205f06e003d3b861d33:765:0xe64ebc77ef72df8a7689d8928bc004b9e7ff43b3\" , \"blockchain\" : \"ETHEREUM\" , \"itemId\" : \"ETHEREUM:0x63ad270fc18f6f9435c3e205f06e003d3b861d33:765\" , \"contract\" : \"ETHEREUM:0x63ad270fc18f6f9435c3e205f06e003d3b861d33\" , \"collection\" : \"ETHEREUM:0x63ad270fc18f6f9435c3e205f06e003d3b861d33\" , \"tokenId\" : \"765\" , \"owner\" : \"ETHEREUM:0xe64ebc77ef72df8a7689d8928bc004b9e7ff43b3\" , \"value\" : \"1\" , \"createdAt\" : \"2022-03-24T16:20:05.015Z\" , \"creators\" : [], \"lazyValue\" : \"0\" , \"pending\" : [] }","title":"Ownerships"},{"location":"reference/search-capabilities/#activity","text":"We have several query parameters for paging and continuation in the Activity controller methods: size \u2014 the maximum number of results per page to return continuation \u2014 deprecated parameter cursor \u2014 combined continuation token from the previous response, type of page token. Can be used to get the next page of results in a subsequent list request. Has format ${BLOCKCHAIN}:${TS_MS}_{ENTITY_ID};... , where: BLOCKCHAIN \u2014 blockchain name: ETHEREUM , FLOW , TEZOS , POLYGON or SOLANA TS_MS \u2014 timestamp of the data in ms ENTITY_ID \u2014 entity identifier, different blockchains have different identifier formats For example: POLYGON:1649395092000_624fc5956f6dc654e6095b90 ; ETHEREUM:1649395762000_624fc83a63c052298d2e2b61 ; SOLANA:1649395777000_000126563148:EjGVpJkNpjCakf5WcN13b8rZzxvDAnjVm7mgLam812xm:000185:4fGmEP5Cm3MURsGJ8mx1uEC7c2sWsVrAGdjC2PfCbamj5ZKZwwCRYTUWyoY3Yzo3JYr5TGqJEUnmB6ejFPChTNKJ:000000:000001 ; TEZOS:1649260825000_BMQpZgFjvunjfqe7JPbRihLxrAv89vR9wtaHBpf8H6FULqXQM6o_243 ; FLOW:1649159220612_a4a4ad0e64aa0a3e6820f8a546d9355045eb1ca2f4818b85f5c0085f8cae04b9.64 If the blockchain is not specified in the cursor , then no entries have been found for it according to the sorting results. To get the next page of results, set cursor returned by a previous list request. But we recommend using the cursor in automated mode, because it is not designed to be built by hand. If you still want to use it manually, use the following example to get the correct data. getAllActivities example https://api-staging.rarible.org/v0.1/activities/all Specify the query parameters: blockchains , activity type , and size : curl --request GET 'https://api-staging.rarible.org/v0.1/activities/all?blockchains=ETHEREUM&type=MINT&size=3' Example response (status 200) { \"continuation\" : \"1649398291000_624fd21b63c052298d2e43f9\" , \"cursor\" : \"ETHEREUM:1649398291000_624fd21b63c052298d2e43f9\" , \"activities\" : [ { \"@type\" : \"MINT\" , \"id\" : \"ETHEREUM:624fd23963c052298d2e4407\" , \"date\" : \"2022-04-08T06:12:02Z\" , \"reverted\" : false , \"owner\" : \"ETHEREUM:0x33b5606763150120076308076c91f01132a799da\" , \"contract\" : \"ETHEREUM:0x2703b3753930fe36b5af2b9b6cba1615fdf31310\" , \"tokenId\" : \"2\" , \"itemId\" : \"ETHEREUM:0x2703b3753930fe36b5af2b9b6cba1615fdf31310:2\" , \"value\" : \"1\" , \"transactionHash\" : \"0x74fd40687d29f2ac584c14b46ad871d82e0fbe3332a2679370b1117c4fac0e57\" , \"blockchainInfo\" : { \"transactionHash\" : \"0x74fd40687d29f2ac584c14b46ad871d82e0fbe3332a2679370b1117c4fac0e57\" , \"blockHash\" : \"0xbd49cf6e7aad7c7e693ea675048033bfdfdea9665374de27283ee045ba7c9b91\" , \"blockNumber\" : 10467061 , \"logIndex\" : 21 } }, { \"@type\" : \"MINT\" , \"id\" : \"ETHEREUM:624fd23963c052298d2e4406\" , \"date\" : \"2022-04-08T06:12:02Z\" , \"reverted\" : false , \"owner\" : \"ETHEREUM:0xd4f6cb0c1fe07407b7098ac7fe4265f3b2ae61f2\" , \"contract\" : \"ETHEREUM:0x1e1e3fed3e83dfe729a29ace3b588169a586fd18\" , \"tokenId\" : \"1\" , \"itemId\" : \"ETHEREUM:0x1e1e3fed3e83dfe729a29ace3b588169a586fd18:1\" , \"value\" : \"1\" , \"transactionHash\" : \"0xa47279f35076d084a5bfa5abd4de71a3226d5b5f7424ceaa52fa81d179a2b8d6\" , \"blockchainInfo\" : { \"transactionHash\" : \"0xa47279f35076d084a5bfa5abd4de71a3226d5b5f7424ceaa52fa81d179a2b8d6\" , \"blockHash\" : \"0xbd49cf6e7aad7c7e693ea675048033bfdfdea9665374de27283ee045ba7c9b91\" , \"blockNumber\" : 10467061 , \"logIndex\" : 0 } }, { \"@type\" : \"MINT\" , \"id\" : \"ETHEREUM:624fd21b63c052298d2e43f9\" , \"date\" : \"2022-04-08T06:11:31Z\" , \"reverted\" : false , \"owner\" : \"ETHEREUM:0x739cc4746e106d050f757bcece2aafc9f2eaaa28\" , \"contract\" : \"ETHEREUM:0x25b284f96106bb046b9bd99ab167f060bcf18982\" , \"tokenId\" : \"10\" , \"itemId\" : \"ETHEREUM:0x25b284f96106bb046b9bd99ab167f060bcf18982:10\" , \"value\" : \"1\" , \"transactionHash\" : \"0x990b3b2157dad093de018da254fc52adbd89737c72cbd1a443253897a74a4161\" , \"blockchainInfo\" : { \"transactionHash\" : \"0x990b3b2157dad093de018da254fc52adbd89737c72cbd1a443253897a74a4161\" , \"blockHash\" : \"0xe5b01f69dba978cb52907a6d12938550fcab5bac1572c9d7ca5c7fab30d32c84\" , \"blockNumber\" : 10467059 , \"logIndex\" : 6 } } ] } As we see, ENTITY_ID part in the cursor is the same as id of the last element in the response: { ... \"cursor\" : \"ETHEREUM:1649398291000_624fd21b63c052298d2e43f9\" , \"activities\" : [ { ... { ... \"id\" : \"ETHEREUM:624fd21b63c052298d2e43f9\" , ... } } ] } Take the resulting cursor and add it to the new query: curl --request GET 'https://api-staging.rarible.org/v0.1/activities/all?blockchains=ETHEREUM&type=MINT&cursor=ETHEREUM:1649398291000_624fd21b63c052298d2e43f9&size=3' Example response (status 200) { \"cursor\" : \"ETHEREUM:1649398276000_624fd20e63c052298d2e42f6\" , \"activities\" : [ { \"@type\" : \"MINT\" , \"id\" : \"ETHEREUM:624fd20f63c052298d2e43e3\" , \"date\" : \"2022-04-08T06:11:16Z\" , \"reverted\" : false , \"owner\" : \"ETHEREUM:0x77054b00ddbbe9c597d93156b964fc115dbc1685\" , \"contract\" : \"ETHEREUM:0xce92876be6f0e6c795d55aca4eec1986c6db35eb\" , \"tokenId\" : \"1011\" , \"itemId\" : \"ETHEREUM:0xce92876be6f0e6c795d55aca4eec1986c6db35eb:1011\" , \"value\" : \"1\" , \"transactionHash\" : \"0xf6cd37b1ce91f16b0f4a1dce86e78d59b4cba6ad7352eaa15cb6fc32c853362a\" , \"blockchainInfo\" : { \"transactionHash\" : \"0xf6cd37b1ce91f16b0f4a1dce86e78d59b4cba6ad7352eaa15cb6fc32c853362a\" , \"blockHash\" : \"0xc5a24c1dc49b5551b06f805edb4dd782cd46b3f21de71d3b250de6d767a625d9\" , \"blockNumber\" : 10467058 , \"logIndex\" : 508 } }, { \"@type\" : \"MINT\" , \"id\" : \"ETHEREUM:624fd20f63c052298d2e43e2\" , \"date\" : \"2022-04-08T06:11:16Z\" , \"reverted\" : false , \"owner\" : \"ETHEREUM:0x77054b00ddbbe9c597d93156b964fc115dbc1685\" , \"contract\" : \"ETHEREUM:0xce92876be6f0e6c795d55aca4eec1986c6db35eb\" , \"tokenId\" : \"1012\" , \"itemId\" : \"ETHEREUM:0xce92876be6f0e6c795d55aca4eec1986c6db35eb:1012\" , \"value\" : \"1\" , \"transactionHash\" : \"0xf6cd37b1ce91f16b0f4a1dce86e78d59b4cba6ad7352eaa15cb6fc32c853362a\" , \"blockchainInfo\" : { \"transactionHash\" : \"0xf6cd37b1ce91f16b0f4a1dce86e78d59b4cba6ad7352eaa15cb6fc32c853362a\" , \"blockHash\" : \"0xc5a24c1dc49b5551b06f805edb4dd782cd46b3f21de71d3b250de6d767a625d9\" , \"blockNumber\" : 10467058 , \"logIndex\" : 507 } }, { \"@type\" : \"MINT\" , \"id\" : \"ETHEREUM:624fd20e63c052298d2e42f6\" , \"date\" : \"2022-04-08T06:11:16Z\" , \"reverted\" : false , \"owner\" : \"ETHEREUM:0x0ade6d84cb1b8fe9ab8c8145f53b202c426a34f3\" , \"contract\" : \"ETHEREUM:0x4fc8df260a04683421d3949baf182f9556f3a9f9\" , \"tokenId\" : \"2\" , \"itemId\" : \"ETHEREUM:0x4fc8df260a04683421d3949baf182f9556f3a9f9:2\" , \"value\" : \"1\" , \"transactionHash\" : \"0xbf231cf9a46ff83484eb39ac73c1d4a806e8376a19fc3c6549d7777c186cd2b3\" , \"blockchainInfo\" : { \"transactionHash\" : \"0xbf231cf9a46ff83484eb39ac73c1d4a806e8376a19fc3c6549d7777c186cd2b3\" , \"blockHash\" : \"0xc5a24c1dc49b5551b06f805edb4dd782cd46b3f21de71d3b250de6d767a625d9\" , \"blockNumber\" : 10467058 , \"logIndex\" : 17 } } ] } Repeat this step with the newly obtained cursor , if necessary. On the multichain-api.rarible.org you can find more information about Protocol Multichain API.","title":"Activity"},{"location":"reference/transfer/","text":"Transfer \u00b6 You can transfer NFTs with Rarible Multichain Protocol in different blockchains. Before start, install and configure Rarible SDK and required wallets . Transfer NFTs \u00b6 Use transferItem function: import { createRaribleSdk } from \"@rarible/sdk\" import { toItemId , toUnionAddress } from \"@rarible/types\" import type { BlockchainWallet } from \"@rarible/sdk-wallet/src\" async function transferItem ( wallet : BlockchainWallet ) { const sdk = createRaribleSdk ( wallet , \"dev\" ) const transferAction = await sdk . nft . transfer ({ itemId : toItemId ( \"<YOUR_ITEM_ID>\" ), }) const tx = await transferAction . submit ({ to : toUnionAddress ( \"<ITEM_RECIPIENT>\" ), amount : 1 , }) await tx . wait () } itemId \u2014 Id of your NFT, has format ${blockchain}:${token}:${tokenId} . For example, ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:12345 to \u2014 address in Union format ${blockchainGroup}:${token} . For example, TEZOS:tz1dKxdpV1hgErMTTKBorb8R5tSz8hFzPhKh amount \u2014 amount of NFT tokens Checking transferred NFT \u00b6 To check the transferred item: Use the getItemById API method getItemById Returns Item by ID. https://api.rarible.org/v0.1/items/{itemId} Example request (staging) curl --request GET 'https://api-staging.rarible.org/v0.1/items/ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:19661880631107248865491477079747186145992059189823053172927066273904580362243' Request parameters: itemId \u2014 ItemID of your NFT, has format ${blockchain}:${token}:${tokenId} For example, ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:12345 Example response (status 200) { \"id\" : \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:19661880631107248865491477079747186145992059189823053172927066273904580362243\" , \"blockchain\" : \"ETHEREUM\" , \"collection\" : \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82\" , \"contract\" : \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82\" , \"tokenId\" : \"19661880631107248865491477079747186145992059189823053172927066273904580362243\" , \"creators\" : [ { \"account\" : \"ETHEREUM:0x2b783ae5b5b8a7a822449c7d8b6f35f9abc827f5\" , \"value\" : 10000 } ], \"owners\" : [], \"royalties\" : [], \"lazySupply\" : \"0\" , \"pending\" : [], \"mintedAt\" : \"2022-03-09T22:48:33Z\" , \"lastUpdatedAt\" : \"2022-03-09T22:50:03.530Z\" , \"supply\" : \"1\" , \"meta\" : { \"name\" : \"gbgbgbgbgbgb\" , \"description\" : \"\" , \"attributes\" : [], \"content\" : [ { \"@type\" : \"IMAGE\" , \"url\" : \"https://rarible.mypinata.cloud/ipfs/QmQCp8bhbaPwGEuHeeR8pme2q3zuSjam2JEuFgAvp4DZsU/image.jpeg\" , \"representation\" : \"ORIGINAL\" , \"mimeType\" : \"image/jpeg\" , \"size\" : 13311 , \"width\" : 640 , \"height\" : 640 } ], \"restrictions\" : [] }, \"deleted\" : false , \"auctions\" : [], \"totalStock\" : \"0\" , \"sellers\" : 0 } Or check Etherscan for Ethereum and Polygon, Flowscan for Flow, or tezblock for Tezos. See more information about usage Protocol SDK on https://github.com/rarible/sdk","title":"Transfer"},{"location":"reference/transfer/#transfer","text":"You can transfer NFTs with Rarible Multichain Protocol in different blockchains. Before start, install and configure Rarible SDK and required wallets .","title":"Transfer"},{"location":"reference/transfer/#transfer-nfts","text":"Use transferItem function: import { createRaribleSdk } from \"@rarible/sdk\" import { toItemId , toUnionAddress } from \"@rarible/types\" import type { BlockchainWallet } from \"@rarible/sdk-wallet/src\" async function transferItem ( wallet : BlockchainWallet ) { const sdk = createRaribleSdk ( wallet , \"dev\" ) const transferAction = await sdk . nft . transfer ({ itemId : toItemId ( \"<YOUR_ITEM_ID>\" ), }) const tx = await transferAction . submit ({ to : toUnionAddress ( \"<ITEM_RECIPIENT>\" ), amount : 1 , }) await tx . wait () } itemId \u2014 Id of your NFT, has format ${blockchain}:${token}:${tokenId} . For example, ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:12345 to \u2014 address in Union format ${blockchainGroup}:${token} . For example, TEZOS:tz1dKxdpV1hgErMTTKBorb8R5tSz8hFzPhKh amount \u2014 amount of NFT tokens","title":"Transfer NFTs"},{"location":"reference/transfer/#checking-transferred-nft","text":"To check the transferred item: Use the getItemById API method getItemById Returns Item by ID. https://api.rarible.org/v0.1/items/{itemId} Example request (staging) curl --request GET 'https://api-staging.rarible.org/v0.1/items/ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:19661880631107248865491477079747186145992059189823053172927066273904580362243' Request parameters: itemId \u2014 ItemID of your NFT, has format ${blockchain}:${token}:${tokenId} For example, ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:12345 Example response (status 200) { \"id\" : \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:19661880631107248865491477079747186145992059189823053172927066273904580362243\" , \"blockchain\" : \"ETHEREUM\" , \"collection\" : \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82\" , \"contract\" : \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82\" , \"tokenId\" : \"19661880631107248865491477079747186145992059189823053172927066273904580362243\" , \"creators\" : [ { \"account\" : \"ETHEREUM:0x2b783ae5b5b8a7a822449c7d8b6f35f9abc827f5\" , \"value\" : 10000 } ], \"owners\" : [], \"royalties\" : [], \"lazySupply\" : \"0\" , \"pending\" : [], \"mintedAt\" : \"2022-03-09T22:48:33Z\" , \"lastUpdatedAt\" : \"2022-03-09T22:50:03.530Z\" , \"supply\" : \"1\" , \"meta\" : { \"name\" : \"gbgbgbgbgbgb\" , \"description\" : \"\" , \"attributes\" : [], \"content\" : [ { \"@type\" : \"IMAGE\" , \"url\" : \"https://rarible.mypinata.cloud/ipfs/QmQCp8bhbaPwGEuHeeR8pme2q3zuSjam2JEuFgAvp4DZsU/image.jpeg\" , \"representation\" : \"ORIGINAL\" , \"mimeType\" : \"image/jpeg\" , \"size\" : 13311 , \"width\" : 640 , \"height\" : 640 } ], \"restrictions\" : [] }, \"deleted\" : false , \"auctions\" : [], \"totalStock\" : \"0\" , \"sellers\" : 0 } Or check Etherscan for Ethereum and Polygon, Flowscan for Flow, or tezblock for Tezos. See more information about usage Protocol SDK on https://github.com/rarible/sdk","title":"Checking transferred NFT"},{"location":"reference/wallets/","text":"Wallets initialization \u00b6 To use SDK, you have to create a Wallet \u2014 abstraction to communicate with real blockchain wallets. Initialize wallets for used blockchains or use Rarible Wallet Connector (in general for frontend). It is possible to use SDK without wallet (for ex. sdk.balances.getBalance ), but in that case you can't send transactions and sign messages: const raribleSdk = createRaribleSdk ( undefined , \"prod\" ) Initialize simple wallets \u00b6 Ethereum / Polygon You can create EthereumWallet with one of the following providers: Web3 instance. For example, Metamask ( window.ethereum ) or HDWalletProvider ethers.providers.Web3Provider ethers.Wallet import Web3 from \"web3\" import * as HDWalletProvider from \"@truffle/hdwallet-provider\" import { Web3Ethereum } from \"@rarible/web3-ethereum\" import { ethers } from \"ethers\" import { EthersEthereum , EthersWeb3ProviderEthereum } from \"@rarible/ethers-ethereum\" import { EthereumWallet } from \"@rarible/sdk-wallet\" // if using another browser provider (not HD Wallet Provider), you will need to make a connection await provider . request ({ method : \"eth_requestAccounts\" }) // creating EthereumWallet with Web3 const web3 = new Web3 ( provider ) const web3Ethereum = new Web3Ethereum ({ web3 }) const ethWallet = new EthereumWallet ( web3Ethereum ) // or with HDWalletProvider const provider = new HDWalletProvider ({ url : \"<NODE_URL>\" , privateKeys : [ \"0x0...\" ], chainId : 1 , }) const web3 = new Web3 ( provider ) const web3Ethereum = new Web3Ethereum ({ web3 }) const ethWallet = new EthereumWallet ( web3Ethereum ) // creating EthereumWallet with ethers.providers.Web3Provider const ethersWeb3Provider = new ethers . providers . Web3Provider ( provider ) const ethersProvider = new EthersWeb3ProviderEthereum ( ethersWeb3Provider ) const ethWallet = new EthereumWallet ( ethersProvider ) // creating EthereumWallet with ethers.Wallet const ethersWeb3Provider = new ethers . providers . Web3Provider ( provider ) const ethersProvider = new EthersEthereum ( new ethers . Wallet ( wallet . getPrivateKeyString (), ethersWeb3Provider )) const ethWallet = new EthereumWallet ( ethersProvider ) // Second parameter \u2014 is environment: \"prod\" | \"staging\" | \"dev\" const raribleSdk = createRaribleSdk ( ethWallet , \"staging\" ) Flow import * as fcl from \"@onflow/fcl\" import { FlowWallet } from \"@rarible/sdk-wallet\" const wallet = new FlowWallet ( fcl ) You also need to configure Flow Client Library (FCL), because Flow-sdk use @onflow/fcl-js : //example config for testnet import { config } from \"@onflow/fcl\" ; config ({ \"accessNode.api\" : \"https://access-testnet.onflow.org\" , // Mainnet: \"https://access-mainnet-beta.onflow.org\" \"discovery.wallet\" : \"https://fcl-discovery.onflow.org/testnet/authn\" // Mainnet: \"https://fcl-discovery.onflow.org/authn\" }) See more configuration details on Flow documentation . Tezos To initialize wallets, you can use: in_memory_provider (also for backend) beacon_provider (@rarible/tezos-sdk/dist/providers/beacon/beacon_provider) //in_memory_provider usage example import { in_memory_provider } from \"@rarible/tezos-sdk/dist/providers/in_memory/in_memory_provider\" import { TezosWallet } from \"@rarible/sdk-wallet\" const provider = in_memory_provider ( \"edsk...\" , nodeUrl ) const wallet = new TezosWallet ( provider ) Wallet Connector \u00b6 It is better to use Wallet Connector because there is a lot of the logic described above already implemented and the connect function for each blockchain is unified. Install \u00b6 Yarn yarn add @rarible/connector # optional: add additional connectors yarn add @rarible/connector-walletconnect yarn add @rarible/connector-fortmatic # check other @rarible/connector-* packages to see what's supported NPM npm i @rarible/connector # optional: add additional connectors npm i @rarible/connector-walletconnect npm i @rarible/connector-fortmatic # check other @rarible/connector-* packages to see what's supported Usage \u00b6 Create Connector , add all needed ConnectionProvider's import { Connector , InjectedWeb3ConnectionProvider , DappType } from \"@rarible/connector\" import { WalletConnectConnectionProvider } from \"@rarible/connector-walletconnect\" // create providers with the required options const injected = new InjectedWeb3ConnectionProvider () const walletConnect = new WalletConnectConnectionProvider () // create connector and push providers to it const connector = Connector . create ([ injected , walletConnect ]) // subscribe to connection status connector . connection . subscribe (( con ) => console . log ( \"connection: \" + JSON . stringify ( con )) ) const options = await connector . getOptions (); // get list of available option await connector . connect ( options [ 0 ]); // connect to selected provider Usage with Rarible SDK \u00b6 import { NetworkType as TezosNetwork } from \"@airgap/beacon-sdk\" import Web3 from \"web3\" import { BlockchainWallet , FlowWallet , TezosWallet , EthereumWallet } from \"@rarible/sdk-wallet\" import { Web3Ethereum } from \"@rarible/web3-ethereum\" import { Connector , IConnectorStateProvider , ConnectionProvider , InjectedWeb3ConnectionProvider , AbstractConnectionProvider , EthereumProviderConnectionResult , } from \"@rarible/connector\" import { FclConnectionProvider , FlowProviderConnectionResult } from \"@rarible/connector-fcl\" import { MEWConnectionProvider } from \"@rarible/connector-mew\" import { BeaconConnectionProvider , TezosProviderConnectionResult } from \"@rarible/connector-beacon\" import { TorusConnectionProvider } from \"@rarible/connector-torus\" import { WalletLinkConnectionProvider } from \"@rarible/connector-walletlink\" import { WalletConnectConnectionProvider } from \"@rarible/connector-walletconnect\" import { FortmaticConnectionProvider } from \"@rarible/connector-fortmatic\" import { PortisConnectionProvider } from \"@rarible/connector-portis\" const ethereumRpcMap : Record < number , string > = { 1 : \"https://node-mainnet.rarible.com\" , 3 : \"https://node-ropsten.rarible.com\" , 4 : \"https://node-rinkeby.rarible.com\" , 17 : \"https://node-e2e.rarible.com\" , } export type WalletAndAddress = { wallet : BlockchainWallet address : string } function mapEthereumWallet < O > ( provider : AbstractConnectionProvider < O , EthereumProviderConnectionResult > ) : ConnectionProvider < O , WalletAndAddress > { return provider . map ( state => ({ wallet : new EthereumWallet ( new Web3Ethereum ({ web3 : new Web3 ( state . provider ), from : state.address })), address : state.address })) } function mapFlowWallet < O > ( provider : AbstractConnectionProvider < O , FlowProviderConnectionResult > ) : ConnectionProvider < O , WalletAndAddress > { return provider . map ( state => ({ wallet : new FlowWallet ( state . fcl ), address : state.address , })) } function mapTezosWallet < O > ( provider : AbstractConnectionProvider < O , TezosProviderConnectionResult > ) : ConnectionProvider < O , WalletAndAddress > { return provider . map ( async state => { const { beacon_provider : createBeaconProvider } = await import ( \"@rarible/tezos-sdk/dist/providers/beacon/beacon_provider\" ) const provider = await createBeaconProvider ( state . wallet as any , state . toolkit ) return { wallet : new TezosWallet ( provider ), address : state.address , } }) } const injected = mapEthereumWallet ( new InjectedWeb3ConnectionProvider ()) const mew = mapEthereumWallet ( new MEWConnectionProvider ({ networkId : 4 , rpcUrl : ethereumRpcMap [ 4 ] })) const beacon = mapTezosWallet ( new BeaconConnectionProvider ({ appName : \"Rarible Test\" , accessNode : \"https://tezos-hangzhou-node.rarible.org\" , network : TezosNetwork.HANGZHOUNET })) const fcl = mapFlowWallet ( new FclConnectionProvider ({ accessNode : \"https://access-testnet.onflow.org\" , walletDiscovery : \"https://flow-wallet-testnet.blocto.app/authn\" , network : \"testnet\" , applicationTitle : \"Rari Test\" , applicationIcon : \"https://rarible.com/favicon.png?2d8af2455958e7f0c812\" })) const torus = mapEthereumWallet ( new TorusConnectionProvider ({ network : { host : \"rinkeby\" } })) const walletLink = mapEthereumWallet ( new WalletLinkConnectionProvider ({ estimationUrl : ethereumRpcMap [ 4 ], networkId : 4 , url : ethereumRpcMap [ 4 ] }, { appName : \"Rarible\" , appLogoUrl : \"https://rarible.com/static/logo-500.static.png\" , darkMode : false })) const walletConnect = mapEthereumWallet ( new WalletConnectConnectionProvider ({ rpc : { 4 : \"https://node-rinkeby.rarible.com\" }, chainId : 4 })) // Providers required secrets // const fortmatic = mapEthereumWallet(new FortmaticConnectionProvider({ apiKey: \"ENTER\", ethNetwork: { chainId: 4, rpcUrl: \"https://node-rinkeby.rarible.com\" } })) // const portis = mapEthereumWallet(new PortisConnectionProvider({ appId: \"ENTER\", network: \"rinkeby\" })) const state : IConnectorStateProvider = { async getValue () : Promise < string | undefined > { const value = localStorage . getItem ( \"saved_provider\" ) return value ? value : undefined }, async setValue ( value : string | undefined ) : Promise < void > { localStorage . setItem ( \"saved_provider\" , value || \"\" ) }, } const connector = Connector . create ( injected , state ) // use ConnectionState for store connector data (last connected provider, etc) . add ( torus ) . add ( walletLink ) . add ( mew ) . add ( beacon ) . add ( fcl ) . add ( walletConnect ) // .add(portis) // .add(fortmatic) connector . connection . subscribe (( con ) => { console . log ( \"connection: \" + JSON . stringify ( con )) if ( con . status === \"connected\" ) { const sdk = createRaribleSdk ( con . connection . wallet , \"staging\" ) // use sdk here } }) const options = await connector . getOptions () await connector . connect ( options [ 0 ]) Available providers \u00b6 Ethereum providers: InjectedWeb3ConnectionProvider - metamask, coinbase, etc FortmaticConnectionProvider PortisConnectionProvider TorusConnectionProvider WalletLinkConnectionProvider MEWConnectionProvider IframeConnectionProvider WalletConnectConnectionProvider Tezos providers: BeaconConnectionProvider Flow providers: FclConnectionProvider Read more about installation and using examples of Rarible SDK Wallet Connector.","title":"Wallets"},{"location":"reference/wallets/#wallets-initialization","text":"To use SDK, you have to create a Wallet \u2014 abstraction to communicate with real blockchain wallets. Initialize wallets for used blockchains or use Rarible Wallet Connector (in general for frontend). It is possible to use SDK without wallet (for ex. sdk.balances.getBalance ), but in that case you can't send transactions and sign messages: const raribleSdk = createRaribleSdk ( undefined , \"prod\" )","title":"Wallets initialization"},{"location":"reference/wallets/#initialize-simple-wallets","text":"Ethereum / Polygon You can create EthereumWallet with one of the following providers: Web3 instance. For example, Metamask ( window.ethereum ) or HDWalletProvider ethers.providers.Web3Provider ethers.Wallet import Web3 from \"web3\" import * as HDWalletProvider from \"@truffle/hdwallet-provider\" import { Web3Ethereum } from \"@rarible/web3-ethereum\" import { ethers } from \"ethers\" import { EthersEthereum , EthersWeb3ProviderEthereum } from \"@rarible/ethers-ethereum\" import { EthereumWallet } from \"@rarible/sdk-wallet\" // if using another browser provider (not HD Wallet Provider), you will need to make a connection await provider . request ({ method : \"eth_requestAccounts\" }) // creating EthereumWallet with Web3 const web3 = new Web3 ( provider ) const web3Ethereum = new Web3Ethereum ({ web3 }) const ethWallet = new EthereumWallet ( web3Ethereum ) // or with HDWalletProvider const provider = new HDWalletProvider ({ url : \"<NODE_URL>\" , privateKeys : [ \"0x0...\" ], chainId : 1 , }) const web3 = new Web3 ( provider ) const web3Ethereum = new Web3Ethereum ({ web3 }) const ethWallet = new EthereumWallet ( web3Ethereum ) // creating EthereumWallet with ethers.providers.Web3Provider const ethersWeb3Provider = new ethers . providers . Web3Provider ( provider ) const ethersProvider = new EthersWeb3ProviderEthereum ( ethersWeb3Provider ) const ethWallet = new EthereumWallet ( ethersProvider ) // creating EthereumWallet with ethers.Wallet const ethersWeb3Provider = new ethers . providers . Web3Provider ( provider ) const ethersProvider = new EthersEthereum ( new ethers . Wallet ( wallet . getPrivateKeyString (), ethersWeb3Provider )) const ethWallet = new EthereumWallet ( ethersProvider ) // Second parameter \u2014 is environment: \"prod\" | \"staging\" | \"dev\" const raribleSdk = createRaribleSdk ( ethWallet , \"staging\" ) Flow import * as fcl from \"@onflow/fcl\" import { FlowWallet } from \"@rarible/sdk-wallet\" const wallet = new FlowWallet ( fcl ) You also need to configure Flow Client Library (FCL), because Flow-sdk use @onflow/fcl-js : //example config for testnet import { config } from \"@onflow/fcl\" ; config ({ \"accessNode.api\" : \"https://access-testnet.onflow.org\" , // Mainnet: \"https://access-mainnet-beta.onflow.org\" \"discovery.wallet\" : \"https://fcl-discovery.onflow.org/testnet/authn\" // Mainnet: \"https://fcl-discovery.onflow.org/authn\" }) See more configuration details on Flow documentation . Tezos To initialize wallets, you can use: in_memory_provider (also for backend) beacon_provider (@rarible/tezos-sdk/dist/providers/beacon/beacon_provider) //in_memory_provider usage example import { in_memory_provider } from \"@rarible/tezos-sdk/dist/providers/in_memory/in_memory_provider\" import { TezosWallet } from \"@rarible/sdk-wallet\" const provider = in_memory_provider ( \"edsk...\" , nodeUrl ) const wallet = new TezosWallet ( provider )","title":"Initialize simple wallets"},{"location":"reference/wallets/#wallet-connector","text":"It is better to use Wallet Connector because there is a lot of the logic described above already implemented and the connect function for each blockchain is unified.","title":"Wallet Connector"},{"location":"reference/wallets/#install","text":"Yarn yarn add @rarible/connector # optional: add additional connectors yarn add @rarible/connector-walletconnect yarn add @rarible/connector-fortmatic # check other @rarible/connector-* packages to see what's supported NPM npm i @rarible/connector # optional: add additional connectors npm i @rarible/connector-walletconnect npm i @rarible/connector-fortmatic # check other @rarible/connector-* packages to see what's supported","title":"Install"},{"location":"reference/wallets/#usage","text":"Create Connector , add all needed ConnectionProvider's import { Connector , InjectedWeb3ConnectionProvider , DappType } from \"@rarible/connector\" import { WalletConnectConnectionProvider } from \"@rarible/connector-walletconnect\" // create providers with the required options const injected = new InjectedWeb3ConnectionProvider () const walletConnect = new WalletConnectConnectionProvider () // create connector and push providers to it const connector = Connector . create ([ injected , walletConnect ]) // subscribe to connection status connector . connection . subscribe (( con ) => console . log ( \"connection: \" + JSON . stringify ( con )) ) const options = await connector . getOptions (); // get list of available option await connector . connect ( options [ 0 ]); // connect to selected provider","title":"Usage"},{"location":"reference/wallets/#usage-with-rarible-sdk","text":"import { NetworkType as TezosNetwork } from \"@airgap/beacon-sdk\" import Web3 from \"web3\" import { BlockchainWallet , FlowWallet , TezosWallet , EthereumWallet } from \"@rarible/sdk-wallet\" import { Web3Ethereum } from \"@rarible/web3-ethereum\" import { Connector , IConnectorStateProvider , ConnectionProvider , InjectedWeb3ConnectionProvider , AbstractConnectionProvider , EthereumProviderConnectionResult , } from \"@rarible/connector\" import { FclConnectionProvider , FlowProviderConnectionResult } from \"@rarible/connector-fcl\" import { MEWConnectionProvider } from \"@rarible/connector-mew\" import { BeaconConnectionProvider , TezosProviderConnectionResult } from \"@rarible/connector-beacon\" import { TorusConnectionProvider } from \"@rarible/connector-torus\" import { WalletLinkConnectionProvider } from \"@rarible/connector-walletlink\" import { WalletConnectConnectionProvider } from \"@rarible/connector-walletconnect\" import { FortmaticConnectionProvider } from \"@rarible/connector-fortmatic\" import { PortisConnectionProvider } from \"@rarible/connector-portis\" const ethereumRpcMap : Record < number , string > = { 1 : \"https://node-mainnet.rarible.com\" , 3 : \"https://node-ropsten.rarible.com\" , 4 : \"https://node-rinkeby.rarible.com\" , 17 : \"https://node-e2e.rarible.com\" , } export type WalletAndAddress = { wallet : BlockchainWallet address : string } function mapEthereumWallet < O > ( provider : AbstractConnectionProvider < O , EthereumProviderConnectionResult > ) : ConnectionProvider < O , WalletAndAddress > { return provider . map ( state => ({ wallet : new EthereumWallet ( new Web3Ethereum ({ web3 : new Web3 ( state . provider ), from : state.address })), address : state.address })) } function mapFlowWallet < O > ( provider : AbstractConnectionProvider < O , FlowProviderConnectionResult > ) : ConnectionProvider < O , WalletAndAddress > { return provider . map ( state => ({ wallet : new FlowWallet ( state . fcl ), address : state.address , })) } function mapTezosWallet < O > ( provider : AbstractConnectionProvider < O , TezosProviderConnectionResult > ) : ConnectionProvider < O , WalletAndAddress > { return provider . map ( async state => { const { beacon_provider : createBeaconProvider } = await import ( \"@rarible/tezos-sdk/dist/providers/beacon/beacon_provider\" ) const provider = await createBeaconProvider ( state . wallet as any , state . toolkit ) return { wallet : new TezosWallet ( provider ), address : state.address , } }) } const injected = mapEthereumWallet ( new InjectedWeb3ConnectionProvider ()) const mew = mapEthereumWallet ( new MEWConnectionProvider ({ networkId : 4 , rpcUrl : ethereumRpcMap [ 4 ] })) const beacon = mapTezosWallet ( new BeaconConnectionProvider ({ appName : \"Rarible Test\" , accessNode : \"https://tezos-hangzhou-node.rarible.org\" , network : TezosNetwork.HANGZHOUNET })) const fcl = mapFlowWallet ( new FclConnectionProvider ({ accessNode : \"https://access-testnet.onflow.org\" , walletDiscovery : \"https://flow-wallet-testnet.blocto.app/authn\" , network : \"testnet\" , applicationTitle : \"Rari Test\" , applicationIcon : \"https://rarible.com/favicon.png?2d8af2455958e7f0c812\" })) const torus = mapEthereumWallet ( new TorusConnectionProvider ({ network : { host : \"rinkeby\" } })) const walletLink = mapEthereumWallet ( new WalletLinkConnectionProvider ({ estimationUrl : ethereumRpcMap [ 4 ], networkId : 4 , url : ethereumRpcMap [ 4 ] }, { appName : \"Rarible\" , appLogoUrl : \"https://rarible.com/static/logo-500.static.png\" , darkMode : false })) const walletConnect = mapEthereumWallet ( new WalletConnectConnectionProvider ({ rpc : { 4 : \"https://node-rinkeby.rarible.com\" }, chainId : 4 })) // Providers required secrets // const fortmatic = mapEthereumWallet(new FortmaticConnectionProvider({ apiKey: \"ENTER\", ethNetwork: { chainId: 4, rpcUrl: \"https://node-rinkeby.rarible.com\" } })) // const portis = mapEthereumWallet(new PortisConnectionProvider({ appId: \"ENTER\", network: \"rinkeby\" })) const state : IConnectorStateProvider = { async getValue () : Promise < string | undefined > { const value = localStorage . getItem ( \"saved_provider\" ) return value ? value : undefined }, async setValue ( value : string | undefined ) : Promise < void > { localStorage . setItem ( \"saved_provider\" , value || \"\" ) }, } const connector = Connector . create ( injected , state ) // use ConnectionState for store connector data (last connected provider, etc) . add ( torus ) . add ( walletLink ) . add ( mew ) . add ( beacon ) . add ( fcl ) . add ( walletConnect ) // .add(portis) // .add(fortmatic) connector . connection . subscribe (( con ) => { console . log ( \"connection: \" + JSON . stringify ( con )) if ( con . status === \"connected\" ) { const sdk = createRaribleSdk ( con . connection . wallet , \"staging\" ) // use sdk here } }) const options = await connector . getOptions () await connector . connect ( options [ 0 ])","title":"Usage with Rarible SDK"},{"location":"reference/wallets/#available-providers","text":"Ethereum providers: InjectedWeb3ConnectionProvider - metamask, coinbase, etc FortmaticConnectionProvider PortisConnectionProvider TorusConnectionProvider WalletLinkConnectionProvider MEWConnectionProvider IframeConnectionProvider WalletConnectConnectionProvider Tezos providers: BeaconConnectionProvider Flow providers: FclConnectionProvider Read more about installation and using examples of Rarible SDK Wallet Connector.","title":"Available providers"},{"location":"snippets/WalletConnectorReadme/","text":"Install \u00b6 Yarn yarn add @rarible/connector # optional: add additional connectors yarn add @rarible/connector-walletconnect yarn add @rarible/connector-fortmatic # check other @rarible/connector-* packages to see what's supported NPM npm i @rarible/connector # optional: add additional connectors npm i @rarible/connector-walletconnect npm i @rarible/connector-fortmatic # check other @rarible/connector-* packages to see what's supported Usage \u00b6 Create Connector , add all needed ConnectionProvider's import { Connector , InjectedWeb3ConnectionProvider , DappType } from \"@rarible/connector\" import { WalletConnectConnectionProvider } from \"@rarible/connector-walletconnect\" // create providers with the required options const injected = new InjectedWeb3ConnectionProvider () const walletConnect = new WalletConnectConnectionProvider () // create connector and push providers to it const connector = Connector . create ([ injected , walletConnect ]) // subscribe to connection status connector . connection . subscribe (( con ) => console . log ( \"connection: \" + JSON . stringify ( con )) ) const options = await connector . getOptions (); // get list of available option await connector . connect ( options [ 0 ]); // connect to selected provider Usage with Rarible SDK \u00b6 import { NetworkType as TezosNetwork } from \"@airgap/beacon-sdk\" import Web3 from \"web3\" import { BlockchainWallet , FlowWallet , TezosWallet , EthereumWallet } from \"@rarible/sdk-wallet\" import { Web3Ethereum } from \"@rarible/web3-ethereum\" import { Connector , IConnectorStateProvider , ConnectionProvider , InjectedWeb3ConnectionProvider , AbstractConnectionProvider , EthereumProviderConnectionResult , } from \"@rarible/connector\" import { FclConnectionProvider , FlowProviderConnectionResult } from \"@rarible/connector-fcl\" import { MEWConnectionProvider } from \"@rarible/connector-mew\" import { BeaconConnectionProvider , TezosProviderConnectionResult } from \"@rarible/connector-beacon\" import { TorusConnectionProvider } from \"@rarible/connector-torus\" import { WalletLinkConnectionProvider } from \"@rarible/connector-walletlink\" import { WalletConnectConnectionProvider } from \"@rarible/connector-walletconnect\" import { FortmaticConnectionProvider } from \"@rarible/connector-fortmatic\" import { PortisConnectionProvider } from \"@rarible/connector-portis\" const ethereumRpcMap : Record < number , string > = { 1 : \"https://node-mainnet.rarible.com\" , 3 : \"https://node-ropsten.rarible.com\" , 4 : \"https://node-rinkeby.rarible.com\" , 17 : \"https://node-e2e.rarible.com\" , } export type WalletAndAddress = { wallet : BlockchainWallet address : string } function mapEthereumWallet < O > ( provider : AbstractConnectionProvider < O , EthereumProviderConnectionResult > ) : ConnectionProvider < O , WalletAndAddress > { return provider . map ( state => ({ wallet : new EthereumWallet ( new Web3Ethereum ({ web3 : new Web3 ( state . provider ), from : state.address })), address : state.address })) } function mapFlowWallet < O > ( provider : AbstractConnectionProvider < O , FlowProviderConnectionResult > ) : ConnectionProvider < O , WalletAndAddress > { return provider . map ( state => ({ wallet : new FlowWallet ( state . fcl ), address : state.address , })) } function mapTezosWallet < O > ( provider : AbstractConnectionProvider < O , TezosProviderConnectionResult > ) : ConnectionProvider < O , WalletAndAddress > { return provider . map ( async state => { const { beacon_provider : createBeaconProvider } = await import ( \"@rarible/tezos-sdk/dist/providers/beacon/beacon_provider\" ) const provider = await createBeaconProvider ( state . wallet as any , state . toolkit ) return { wallet : new TezosWallet ( provider ), address : state.address , } }) } const injected = mapEthereumWallet ( new InjectedWeb3ConnectionProvider ()) const mew = mapEthereumWallet ( new MEWConnectionProvider ({ networkId : 4 , rpcUrl : ethereumRpcMap [ 4 ] })) const beacon = mapTezosWallet ( new BeaconConnectionProvider ({ appName : \"Rarible Test\" , accessNode : \"https://tezos-hangzhou-node.rarible.org\" , network : TezosNetwork.HANGZHOUNET })) const fcl = mapFlowWallet ( new FclConnectionProvider ({ accessNode : \"https://access-testnet.onflow.org\" , walletDiscovery : \"https://flow-wallet-testnet.blocto.app/authn\" , network : \"testnet\" , applicationTitle : \"Rari Test\" , applicationIcon : \"https://rarible.com/favicon.png?2d8af2455958e7f0c812\" })) const torus = mapEthereumWallet ( new TorusConnectionProvider ({ network : { host : \"rinkeby\" } })) const walletLink = mapEthereumWallet ( new WalletLinkConnectionProvider ({ estimationUrl : ethereumRpcMap [ 4 ], networkId : 4 , url : ethereumRpcMap [ 4 ] }, { appName : \"Rarible\" , appLogoUrl : \"https://rarible.com/static/logo-500.static.png\" , darkMode : false })) const walletConnect = mapEthereumWallet ( new WalletConnectConnectionProvider ({ rpc : { 4 : \"https://node-rinkeby.rarible.com\" }, chainId : 4 })) // Providers required secrets // const fortmatic = mapEthereumWallet(new FortmaticConnectionProvider({ apiKey: \"ENTER\", ethNetwork: { chainId: 4, rpcUrl: \"https://node-rinkeby.rarible.com\" } })) // const portis = mapEthereumWallet(new PortisConnectionProvider({ appId: \"ENTER\", network: \"rinkeby\" })) const state : IConnectorStateProvider = { async getValue () : Promise < string | undefined > { const value = localStorage . getItem ( \"saved_provider\" ) return value ? value : undefined }, async setValue ( value : string | undefined ) : Promise < void > { localStorage . setItem ( \"saved_provider\" , value || \"\" ) }, } const connector = Connector . create ( injected , state ) // use ConnectionState for store connector data (last connected provider, etc) . add ( torus ) . add ( walletLink ) . add ( mew ) . add ( beacon ) . add ( fcl ) . add ( walletConnect ) // .add(portis) // .add(fortmatic) connector . connection . subscribe (( con ) => { console . log ( \"connection: \" + JSON . stringify ( con )) if ( con . status === \"connected\" ) { const sdk = createRaribleSdk ( con . connection . wallet , \"staging\" ) // use sdk here } }) const options = await connector . getOptions () await connector . connect ( options [ 0 ]) Available providers \u00b6 Ethereum providers: InjectedWeb3ConnectionProvider - metamask, coinbase, etc FortmaticConnectionProvider PortisConnectionProvider TorusConnectionProvider WalletLinkConnectionProvider MEWConnectionProvider IframeConnectionProvider WalletConnectConnectionProvider Tezos providers: BeaconConnectionProvider Flow providers: FclConnectionProvider","title":"WalletConnectorReadme"},{"location":"snippets/WalletConnectorReadme/#install","text":"Yarn yarn add @rarible/connector # optional: add additional connectors yarn add @rarible/connector-walletconnect yarn add @rarible/connector-fortmatic # check other @rarible/connector-* packages to see what's supported NPM npm i @rarible/connector # optional: add additional connectors npm i @rarible/connector-walletconnect npm i @rarible/connector-fortmatic # check other @rarible/connector-* packages to see what's supported","title":"Install"},{"location":"snippets/WalletConnectorReadme/#usage","text":"Create Connector , add all needed ConnectionProvider's import { Connector , InjectedWeb3ConnectionProvider , DappType } from \"@rarible/connector\" import { WalletConnectConnectionProvider } from \"@rarible/connector-walletconnect\" // create providers with the required options const injected = new InjectedWeb3ConnectionProvider () const walletConnect = new WalletConnectConnectionProvider () // create connector and push providers to it const connector = Connector . create ([ injected , walletConnect ]) // subscribe to connection status connector . connection . subscribe (( con ) => console . log ( \"connection: \" + JSON . stringify ( con )) ) const options = await connector . getOptions (); // get list of available option await connector . connect ( options [ 0 ]); // connect to selected provider","title":"Usage"},{"location":"snippets/WalletConnectorReadme/#usage-with-rarible-sdk","text":"import { NetworkType as TezosNetwork } from \"@airgap/beacon-sdk\" import Web3 from \"web3\" import { BlockchainWallet , FlowWallet , TezosWallet , EthereumWallet } from \"@rarible/sdk-wallet\" import { Web3Ethereum } from \"@rarible/web3-ethereum\" import { Connector , IConnectorStateProvider , ConnectionProvider , InjectedWeb3ConnectionProvider , AbstractConnectionProvider , EthereumProviderConnectionResult , } from \"@rarible/connector\" import { FclConnectionProvider , FlowProviderConnectionResult } from \"@rarible/connector-fcl\" import { MEWConnectionProvider } from \"@rarible/connector-mew\" import { BeaconConnectionProvider , TezosProviderConnectionResult } from \"@rarible/connector-beacon\" import { TorusConnectionProvider } from \"@rarible/connector-torus\" import { WalletLinkConnectionProvider } from \"@rarible/connector-walletlink\" import { WalletConnectConnectionProvider } from \"@rarible/connector-walletconnect\" import { FortmaticConnectionProvider } from \"@rarible/connector-fortmatic\" import { PortisConnectionProvider } from \"@rarible/connector-portis\" const ethereumRpcMap : Record < number , string > = { 1 : \"https://node-mainnet.rarible.com\" , 3 : \"https://node-ropsten.rarible.com\" , 4 : \"https://node-rinkeby.rarible.com\" , 17 : \"https://node-e2e.rarible.com\" , } export type WalletAndAddress = { wallet : BlockchainWallet address : string } function mapEthereumWallet < O > ( provider : AbstractConnectionProvider < O , EthereumProviderConnectionResult > ) : ConnectionProvider < O , WalletAndAddress > { return provider . map ( state => ({ wallet : new EthereumWallet ( new Web3Ethereum ({ web3 : new Web3 ( state . provider ), from : state.address })), address : state.address })) } function mapFlowWallet < O > ( provider : AbstractConnectionProvider < O , FlowProviderConnectionResult > ) : ConnectionProvider < O , WalletAndAddress > { return provider . map ( state => ({ wallet : new FlowWallet ( state . fcl ), address : state.address , })) } function mapTezosWallet < O > ( provider : AbstractConnectionProvider < O , TezosProviderConnectionResult > ) : ConnectionProvider < O , WalletAndAddress > { return provider . map ( async state => { const { beacon_provider : createBeaconProvider } = await import ( \"@rarible/tezos-sdk/dist/providers/beacon/beacon_provider\" ) const provider = await createBeaconProvider ( state . wallet as any , state . toolkit ) return { wallet : new TezosWallet ( provider ), address : state.address , } }) } const injected = mapEthereumWallet ( new InjectedWeb3ConnectionProvider ()) const mew = mapEthereumWallet ( new MEWConnectionProvider ({ networkId : 4 , rpcUrl : ethereumRpcMap [ 4 ] })) const beacon = mapTezosWallet ( new BeaconConnectionProvider ({ appName : \"Rarible Test\" , accessNode : \"https://tezos-hangzhou-node.rarible.org\" , network : TezosNetwork.HANGZHOUNET })) const fcl = mapFlowWallet ( new FclConnectionProvider ({ accessNode : \"https://access-testnet.onflow.org\" , walletDiscovery : \"https://flow-wallet-testnet.blocto.app/authn\" , network : \"testnet\" , applicationTitle : \"Rari Test\" , applicationIcon : \"https://rarible.com/favicon.png?2d8af2455958e7f0c812\" })) const torus = mapEthereumWallet ( new TorusConnectionProvider ({ network : { host : \"rinkeby\" } })) const walletLink = mapEthereumWallet ( new WalletLinkConnectionProvider ({ estimationUrl : ethereumRpcMap [ 4 ], networkId : 4 , url : ethereumRpcMap [ 4 ] }, { appName : \"Rarible\" , appLogoUrl : \"https://rarible.com/static/logo-500.static.png\" , darkMode : false })) const walletConnect = mapEthereumWallet ( new WalletConnectConnectionProvider ({ rpc : { 4 : \"https://node-rinkeby.rarible.com\" }, chainId : 4 })) // Providers required secrets // const fortmatic = mapEthereumWallet(new FortmaticConnectionProvider({ apiKey: \"ENTER\", ethNetwork: { chainId: 4, rpcUrl: \"https://node-rinkeby.rarible.com\" } })) // const portis = mapEthereumWallet(new PortisConnectionProvider({ appId: \"ENTER\", network: \"rinkeby\" })) const state : IConnectorStateProvider = { async getValue () : Promise < string | undefined > { const value = localStorage . getItem ( \"saved_provider\" ) return value ? value : undefined }, async setValue ( value : string | undefined ) : Promise < void > { localStorage . setItem ( \"saved_provider\" , value || \"\" ) }, } const connector = Connector . create ( injected , state ) // use ConnectionState for store connector data (last connected provider, etc) . add ( torus ) . add ( walletLink ) . add ( mew ) . add ( beacon ) . add ( fcl ) . add ( walletConnect ) // .add(portis) // .add(fortmatic) connector . connection . subscribe (( con ) => { console . log ( \"connection: \" + JSON . stringify ( con )) if ( con . status === \"connected\" ) { const sdk = createRaribleSdk ( con . connection . wallet , \"staging\" ) // use sdk here } }) const options = await connector . getOptions () await connector . connect ( options [ 0 ])","title":"Usage with Rarible SDK"},{"location":"snippets/WalletConnectorReadme/#available-providers","text":"Ethereum providers: InjectedWeb3ConnectionProvider - metamask, coinbase, etc FortmaticConnectionProvider PortisConnectionProvider TorusConnectionProvider WalletLinkConnectionProvider MEWConnectionProvider IframeConnectionProvider WalletConnectConnectionProvider Tezos providers: BeaconConnectionProvider Flow providers: FclConnectionProvider","title":"Available providers"},{"location":"snippets/preparation-sdk/","text":"Before start, install and configure Rarible SDK and required wallets .","title":"Preparation sdk"},{"location":"snippets/usage-sdk-ethers/","text":"// Imports import type Wallet from \"ethereumjs-wallet\" import Web3 from \"web3\" import { ethers } from \"ethers\" import { Web3Ethereum } from \"@rarible/web3-ethereum\" import { EthersEthereum, EthersWeb3ProviderEthereum } from \"@rarible/ethers-ethereum\" // Code export function createProviders(provider: any, wallet: Wallet) { const web3 = new Web3(provider) const ethersWeb3Provider = new ethers.providers.Web3Provider(provider) return { web3, providers: [ new Web3Ethereum({ web3 }), new EthersEthereum(new ethers.Wallet(wallet.getPrivateKeyString(), ethersWeb3Provider)), new EthersWeb3ProviderEthereum(ethersWeb3Provider), ], } } const ethWallet = new EthereumWallet(ethersEthereumProviderInstance) const raribleSdk = createRaribleSdk(ethWallet, \"staging\")","title":"Usage sdk ethers"},{"location":"snippets/usage-sdk-on-server/","text":"Using SDK on server application \u00b6 The SDK was designed for use on the frontend side. To use the SDK on the server side (backend): Install packages: yarn add tslib@2.3.1 yarn add form-data yarn add node-fetch Add dependencies: global . FormData = require ( \"form-data\" ) global . window = { fetch : require ( \"node-fetch\" ), dispatchEvent : () => { }, } global . CustomEvent = function CustomEvent () { return } Try our example to buy Ethereum NFT item on Rinkeby network. Pass private key, node RPC URL, network ID, item ID for buyout and start: ETH_PRIVATE_KEY = \"0x...\" \\ ETHEREUM_RPC_URL = \"https://rinkeby.infura.io/...\" \\ ETHEREUM_NETWORK_ID = \"4\" \\ BUYOUT_ITEM_ID = \"0x1AF7A7555263F275433c6Bb0b8FdCD231F89B1D7:102581254137174039089845694331937600507918590364933200920056519678660477714440\" \\ ts-node packages/sdk/example/backend/buy.ts","title":"Usage sdk on server"},{"location":"snippets/usage-sdk-on-server/#using-sdk-on-server-application","text":"The SDK was designed for use on the frontend side. To use the SDK on the server side (backend): Install packages: yarn add tslib@2.3.1 yarn add form-data yarn add node-fetch Add dependencies: global . FormData = require ( \"form-data\" ) global . window = { fetch : require ( \"node-fetch\" ), dispatchEvent : () => { }, } global . CustomEvent = function CustomEvent () { return } Try our example to buy Ethereum NFT item on Rinkeby network. Pass private key, node RPC URL, network ID, item ID for buyout and start: ETH_PRIVATE_KEY = \"0x...\" \\ ETHEREUM_RPC_URL = \"https://rinkeby.infura.io/...\" \\ ETHEREUM_NETWORK_ID = \"4\" \\ BUYOUT_ITEM_ID = \"0x1AF7A7555263F275433c6Bb0b8FdCD231F89B1D7:102581254137174039089845694331937600507918590364933200920056519678660477714440\" \\ ts-node packages/sdk/example/backend/buy.ts","title":"Using SDK on server application"},{"location":"snippets/usage-sdk/","text":"// Imports import Web3 from \"web3\" import { createRaribleSdk } from \"@rarible/sdk\" import { EthereumWallet } from \"@rarible/sdk-wallet\" import { Blockchain } from \"@rarible/api-client\" import { Web3Ethereum } from \"@rarible/web3-ethereum\" // Code const { ethereum } = window as any const web3 = new Web3(provider) const web3Ethereum = new Web3Ethereum({ web3 }) const ethWallet = new EthereumWallet(web3Ethereum) const raribleSdk = createRaribleSdk(ethWallet, \"staging\")","title":"Usage sdk"},{"location":"use-cases/bubblesdk/","text":"Rarible SDK No-Code plugin for Bubble \u00b6 This plugin has been developed by EzCode . You can now use the Rarible Protocol SDK and build your own NFT Marketplace without deep knowledge on how to code. We have integrated the SDK in a no-code plugin for Bubble.io You can use the SDK without any programming skills and build your own NFT Marketplace entirely without code. We have integrated SDK into a no-code plugin for the biggest no-code platform Bubble.io . Link to the plugin Link to documentation Examples on using the plugin All examples are open source, you can see how it works from the inside. API supported features: \u00b6 Get Item Metadata Get Item Data Get Orders By Wallet Get Order By Hash Get NFT Ownership Get NFT Order Activities Get Order Activities By Item Get All NFT Items By Owner, Creator, Collection SDK supported features: \u00b6 ERC721 and ERC1155 supported Mint Lazy Mint (Buyer pays the fee) Custom Royalties Custom Origin Fees Create Order (Sell, Bid) Buy item Accept Bid Transfer an NFT to other wallet Cancel Order Burn For any plugin/bubble related questions we have a separate thread on Bubble\u2019s forum here . How to use: \u00b6 Instructions Place the element Rarible SDK on the page Make sure it is visible (not in a popup or a hidden group) Select the network in the plugin element field \"Environment\" Ready to go? We are working on documentation and more demo pages. NFT Marketplaces being built with this plugin: - one2all","title":"EZCode SDK plugin"},{"location":"use-cases/bubblesdk/#rarible-sdk-no-code-plugin-for-bubble","text":"This plugin has been developed by EzCode . You can now use the Rarible Protocol SDK and build your own NFT Marketplace without deep knowledge on how to code. We have integrated the SDK in a no-code plugin for Bubble.io You can use the SDK without any programming skills and build your own NFT Marketplace entirely without code. We have integrated SDK into a no-code plugin for the biggest no-code platform Bubble.io . Link to the plugin Link to documentation Examples on using the plugin All examples are open source, you can see how it works from the inside.","title":"Rarible SDK No-Code plugin for Bubble"},{"location":"use-cases/bubblesdk/#api-supported-features","text":"Get Item Metadata Get Item Data Get Orders By Wallet Get Order By Hash Get NFT Ownership Get NFT Order Activities Get Order Activities By Item Get All NFT Items By Owner, Creator, Collection","title":"API supported features:"},{"location":"use-cases/bubblesdk/#sdk-supported-features","text":"ERC721 and ERC1155 supported Mint Lazy Mint (Buyer pays the fee) Custom Royalties Custom Origin Fees Create Order (Sell, Bid) Buy item Accept Bid Transfer an NFT to other wallet Cancel Order Burn For any plugin/bubble related questions we have a separate thread on Bubble\u2019s forum here .","title":"SDK supported features:"},{"location":"use-cases/bubblesdk/#how-to-use","text":"Instructions Place the element Rarible SDK on the page Make sure it is visible (not in a popup or a hidden group) Select the network in the plugin element field \"Environment\" Ready to go? We are working on documentation and more demo pages. NFT Marketplaces being built with this plugin: - one2all","title":"How to use:"},{"location":"use-cases/coconft/","text":"cocoNFT \u00b6 TLDR: cocoNFT helps new creators get into the NFT space by building an onRamp that makes it easy to manage your wallet via social media logins. cocoNFT uses the following Smart Contract functionalities: lazy minting, exchange, and indexer. cocoNFT uses lazy minting so that the creators don't have to pay for minting making the process easy for newbies to crypto. They are planning on using the ability to support checkout right on our website via the Rarible Protocol Exchange and the indexer I believe to show a user's Lazy Minted NFTs. How cocoNFT would have changed things knowing what they know now: On the Protocol we developed code to handle many features that we needed Rarible Protocol to do. Instead of waiting for the protocol updates. As we were building found a lot of frameworks, we would have used something like starter app to jumpstart our development process. In regards to the database side cocoNFT advises understanding how you structure your database. Step by step instructions for teams to do the same: Always test on testnet before deploying to mainnet. Ropsten recommended for using Rarible APIs. Fork Rarible Protocol: https://github.com/rarible/protocol-contracts (Best to explore and get familiar) Identify which NFT token type you will be using, 721 or 1155, and make any modifications necessary in the tokens folder: https://github.com/rarible/protocol-contracts/tree/master/tokens Update the migrations files to pass in whatever parameters you want for the contract you plan to deploy: https://github.com/rarible/protocol-contracts/tree/master/tokens/migrations Note Only migration files 1-4 are necessary for initial deployment, and only #2 for 721 and #3 for 1155 if you don't want to deploy contracts for both. Take note of the addresses for the contracts. These are upgradeable contracts, so that you will be directing calls to the proxy address. Test some functions like name() or symbol() in your terminal to ensure it's working Start using Rarible's APIs for lazy minting and order creation to build out your marketplace: https://api-reference.rarible.com/#operation/upsertOrder API and/or SDK is in the works for cocoNFT.","title":"cocoNFT"},{"location":"use-cases/coconft/#coconft","text":"TLDR: cocoNFT helps new creators get into the NFT space by building an onRamp that makes it easy to manage your wallet via social media logins. cocoNFT uses the following Smart Contract functionalities: lazy minting, exchange, and indexer. cocoNFT uses lazy minting so that the creators don't have to pay for minting making the process easy for newbies to crypto. They are planning on using the ability to support checkout right on our website via the Rarible Protocol Exchange and the indexer I believe to show a user's Lazy Minted NFTs. How cocoNFT would have changed things knowing what they know now: On the Protocol we developed code to handle many features that we needed Rarible Protocol to do. Instead of waiting for the protocol updates. As we were building found a lot of frameworks, we would have used something like starter app to jumpstart our development process. In regards to the database side cocoNFT advises understanding how you structure your database. Step by step instructions for teams to do the same: Always test on testnet before deploying to mainnet. Ropsten recommended for using Rarible APIs. Fork Rarible Protocol: https://github.com/rarible/protocol-contracts (Best to explore and get familiar) Identify which NFT token type you will be using, 721 or 1155, and make any modifications necessary in the tokens folder: https://github.com/rarible/protocol-contracts/tree/master/tokens Update the migrations files to pass in whatever parameters you want for the contract you plan to deploy: https://github.com/rarible/protocol-contracts/tree/master/tokens/migrations Note Only migration files 1-4 are necessary for initial deployment, and only #2 for 721 and #3 for 1155 if you don't want to deploy contracts for both. Take note of the addresses for the contracts. These are upgradeable contracts, so that you will be directing calls to the proxy address. Test some functions like name() or symbol() in your terminal to ensure it's working Start using Rarible's APIs for lazy minting and order creation to build out your marketplace: https://api-reference.rarible.com/#operation/upsertOrder API and/or SDK is in the works for cocoNFT.","title":"cocoNFT"},{"location":"use-cases/mintgate/","text":"MintGate \u00b6 TLDR: MintGate decided to integrate Rarible protocol by building their marketplace on it to provide the best experience for their growing community of creators and influencers. The usages of the Rarible Protocol within MintGate are: Lazy Minting, Exchange, and Indexer We forked the 1155 contracts from Rarible to create a custom contract to mint from that has all the same functionality to abide by the royalties. We are using that contract and the exchange contracts + indexer that Rarible provides through the APIs. The steps for how we forked the contracts are listed below. From there we used the starter app and Eugene's sample project as templates for creating signed sale orders to submit to the exchange. We use the indexer to pull created sale order data for purchases and information display, which are all included in the Rarible APIs. How MintGate would have changed things knowing what they know now: One thing Mintgate would have done differently based on experience is to prioritize the Rarible marketplace order creation features sooner instead of focusing on lazy minting alone. Mintgate hopes Rarible will be able to complete an SDK alternative to the API's because they fail from time to time, which can cause confusion for users and bugs when there is no sale order or lazy mint created. Using a SDK would hopefully prove more reliable. Step by step instructions for how MintGate started building on Rarible protocol: Always test on testnet before deploying to mainnet. Ropsten recommended for using Rarible APIs. Fork Rarible Protocol: https://github.com/rarible/protocol-contracts (Best to explore and get familiar) Identify which NFT token type you will be using, 721 or 1155, and make any modifications necessary in the tokens folder: https://github.com/rarible/protocol-contracts/tree/master/tokens Update the migrations files to pass in whatever parameters you want for the contract you plan to deploy: https://github.com/rarible/protocol-contracts/tree/master/tokens/migrations Note Only migration files 1-4 are necessary for initial deployment, and only #2 for 721 and #3 for 1155 if you don't want to deploy contracts for both. Take note of the addresses for the contracts. These are upgradeable contracts, so you will be directing calls to the proxy address. Test some functions like name() or symbol() in your terminal to ensure it's working Start using Rarible's APIs for lazy minting and order creation to build out your marketplace: https://api-reference.rarible.com/#operation/upsertOrder APIs for MintGate for token gating are available. Full documentation and instructions can be found here: MintGate Docs","title":"MintGate"},{"location":"use-cases/mintgate/#mintgate","text":"TLDR: MintGate decided to integrate Rarible protocol by building their marketplace on it to provide the best experience for their growing community of creators and influencers. The usages of the Rarible Protocol within MintGate are: Lazy Minting, Exchange, and Indexer We forked the 1155 contracts from Rarible to create a custom contract to mint from that has all the same functionality to abide by the royalties. We are using that contract and the exchange contracts + indexer that Rarible provides through the APIs. The steps for how we forked the contracts are listed below. From there we used the starter app and Eugene's sample project as templates for creating signed sale orders to submit to the exchange. We use the indexer to pull created sale order data for purchases and information display, which are all included in the Rarible APIs. How MintGate would have changed things knowing what they know now: One thing Mintgate would have done differently based on experience is to prioritize the Rarible marketplace order creation features sooner instead of focusing on lazy minting alone. Mintgate hopes Rarible will be able to complete an SDK alternative to the API's because they fail from time to time, which can cause confusion for users and bugs when there is no sale order or lazy mint created. Using a SDK would hopefully prove more reliable. Step by step instructions for how MintGate started building on Rarible protocol: Always test on testnet before deploying to mainnet. Ropsten recommended for using Rarible APIs. Fork Rarible Protocol: https://github.com/rarible/protocol-contracts (Best to explore and get familiar) Identify which NFT token type you will be using, 721 or 1155, and make any modifications necessary in the tokens folder: https://github.com/rarible/protocol-contracts/tree/master/tokens Update the migrations files to pass in whatever parameters you want for the contract you plan to deploy: https://github.com/rarible/protocol-contracts/tree/master/tokens/migrations Note Only migration files 1-4 are necessary for initial deployment, and only #2 for 721 and #3 for 1155 if you don't want to deploy contracts for both. Take note of the addresses for the contracts. These are upgradeable contracts, so you will be directing calls to the proxy address. Test some functions like name() or symbol() in your terminal to ensure it's working Start using Rarible's APIs for lazy minting and order creation to build out your marketplace: https://api-reference.rarible.com/#operation/upsertOrder APIs for MintGate for token gating are available. Full documentation and instructions can be found here: MintGate Docs","title":"MintGate"},{"location":"use-cases/moralisplugin/","text":"Moralis Rarible Plugin \u00b6 This plugin has been developed by the Moralis team. For support, open a github issue Link to the plugin Link to documentation This plugin enables interaction with Rarible, allowing anyone to lazy-mint an NFT and sell it. Supported chains \u00b6 This plugins works with 2 different blockchains: Ethereum Mainnet (\u2018eth\u2019) Ethereum Rinkeby (\u2018rinkeby\u2019) Supported tokens \u00b6 ERC721 ERC1155 SDK \u00b6 Import the Moralis SDK in your project. < script src = \"https://cdn.jsdelivr.net/npm/web3@latest/dist/web3.min.js\" ></ script > < script src = \"https://npmcdn.com/moralis@latest/dist/moralis.js\" ></ script > Lazy mint \u00b6 You can lazy mint a token by calling the lazyMint endpoint. This endpoint returns an object that contains the tokenId and tokenAddress of the lazy minted token. await Moralis . Plugins . rarible . lazyMint ({ chain : 'rinkeby' , userAddress : '0x7f64041298CC2C045FE5eb0e897ab7b5D4BdB4F3' , tokenType : 'ERC1155' , tokenUri : '/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp' , supply : 100 , royaltiesAmount : 5 , // 0.05% royalty. Optional }) You can also lazy mint a token and sell immediately. Below we are goin to lazy mint a token and create a sell order for it. In this example, we are selling 3 out of the 100 tokens created for 1 ETH (10 ** 18) each. await Moralis . Plugins . rarible . lazyMint ({ chain : 'rinkeby' , userAddress : '0x7f64041298CC2C045FE5eb0e897ab7b5D4BdB4F3' , tokenType : 'ERC1155' , tokenUri : '/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp' , supply : 100 , royaltiesAmount : 5 , // 0.05% royalty. Optional list : true , // Only if lazy listing listTokenAmount : 3 , // Only if lazy listing listTokenValue : 10 ** 18 , // Only if lazy listing listAssetClass : 'ETH' , // only if lazy listing || optional }) Sell order \u00b6 You can create a sell order for a lazy minted token by calling the createSellOrder endpoint. In this example, we are selling 4 tokens created for 1 ETH (10 ** 18) each. await Moralis . Plugins . rarible . createSellOrder ({ chain : 'rinkeby' , userAddress : '0xE78dC206875373B351EEF2D182025bb9a64d67B3' , makeTokenId : '104734732573670734795292663651146618103387426131809974624560761860320187646009' , makeTokenAddress : '0x1AF7A7555263F275433c6Bb0b8FdCD231F89B1D7' , makeAssetClass : 'ERC1155' , makeValue : '4' , takeAssetClass : 'ETH' , takeValue : 10 ** 18 , }); ERC20 \u00b6 You can sell a lazy minted token for ERC20 instead of ETH. Make sure to specify the following parameters: takeAssetClass : 'ERC20' , takeTokenAddress : '0x5592ec0cfb4dbc12d3ab100b257153436a1f0fea' , // DAI Example: await Moralis . Plugins . rarible . createSellOrder ({ chain : 'rinkeby' , userAddress : '0xE78dC206875373B351EEF2D182025bb9a64d67B3' , makeTokenId : '104734732573670734795292663651146618103387426131809974624560761860320187646009' , makeTokenAddress : '0x1AF7A7555263F275433c6Bb0b8FdCD231F89B1D7' , makeAssetClass : 'ERC1155' , makeValue : '4' , takeAssetClass : 'ERC20' , takeTokenAddress : '0x5592ec0cfb4dbc12d3ab100b257153436a1f0fea' , // DAI takeValue : 10 ** 18 , });","title":"Moralis Lazy Mint & Sell plugin"},{"location":"use-cases/moralisplugin/#moralis-rarible-plugin","text":"This plugin has been developed by the Moralis team. For support, open a github issue Link to the plugin Link to documentation This plugin enables interaction with Rarible, allowing anyone to lazy-mint an NFT and sell it.","title":"Moralis Rarible Plugin"},{"location":"use-cases/moralisplugin/#supported-chains","text":"This plugins works with 2 different blockchains: Ethereum Mainnet (\u2018eth\u2019) Ethereum Rinkeby (\u2018rinkeby\u2019)","title":"Supported chains"},{"location":"use-cases/moralisplugin/#supported-tokens","text":"ERC721 ERC1155","title":"Supported tokens"},{"location":"use-cases/moralisplugin/#sdk","text":"Import the Moralis SDK in your project. < script src = \"https://cdn.jsdelivr.net/npm/web3@latest/dist/web3.min.js\" ></ script > < script src = \"https://npmcdn.com/moralis@latest/dist/moralis.js\" ></ script >","title":"SDK"},{"location":"use-cases/moralisplugin/#lazy-mint","text":"You can lazy mint a token by calling the lazyMint endpoint. This endpoint returns an object that contains the tokenId and tokenAddress of the lazy minted token. await Moralis . Plugins . rarible . lazyMint ({ chain : 'rinkeby' , userAddress : '0x7f64041298CC2C045FE5eb0e897ab7b5D4BdB4F3' , tokenType : 'ERC1155' , tokenUri : '/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp' , supply : 100 , royaltiesAmount : 5 , // 0.05% royalty. Optional }) You can also lazy mint a token and sell immediately. Below we are goin to lazy mint a token and create a sell order for it. In this example, we are selling 3 out of the 100 tokens created for 1 ETH (10 ** 18) each. await Moralis . Plugins . rarible . lazyMint ({ chain : 'rinkeby' , userAddress : '0x7f64041298CC2C045FE5eb0e897ab7b5D4BdB4F3' , tokenType : 'ERC1155' , tokenUri : '/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp' , supply : 100 , royaltiesAmount : 5 , // 0.05% royalty. Optional list : true , // Only if lazy listing listTokenAmount : 3 , // Only if lazy listing listTokenValue : 10 ** 18 , // Only if lazy listing listAssetClass : 'ETH' , // only if lazy listing || optional })","title":"Lazy mint"},{"location":"use-cases/moralisplugin/#sell-order","text":"You can create a sell order for a lazy minted token by calling the createSellOrder endpoint. In this example, we are selling 4 tokens created for 1 ETH (10 ** 18) each. await Moralis . Plugins . rarible . createSellOrder ({ chain : 'rinkeby' , userAddress : '0xE78dC206875373B351EEF2D182025bb9a64d67B3' , makeTokenId : '104734732573670734795292663651146618103387426131809974624560761860320187646009' , makeTokenAddress : '0x1AF7A7555263F275433c6Bb0b8FdCD231F89B1D7' , makeAssetClass : 'ERC1155' , makeValue : '4' , takeAssetClass : 'ETH' , takeValue : 10 ** 18 , });","title":"Sell order"},{"location":"use-cases/moralisplugin/#erc20","text":"You can sell a lazy minted token for ERC20 instead of ETH. Make sure to specify the following parameters: takeAssetClass : 'ERC20' , takeTokenAddress : '0x5592ec0cfb4dbc12d3ab100b257153436a1f0fea' , // DAI Example: await Moralis . Plugins . rarible . createSellOrder ({ chain : 'rinkeby' , userAddress : '0xE78dC206875373B351EEF2D182025bb9a64d67B3' , makeTokenId : '104734732573670734795292663651146618103387426131809974624560761860320187646009' , makeTokenAddress : '0x1AF7A7555263F275433c6Bb0b8FdCD231F89B1D7' , makeAssetClass : 'ERC1155' , makeValue : '4' , takeAssetClass : 'ERC20' , takeTokenAddress : '0x5592ec0cfb4dbc12d3ab100b257153436a1f0fea' , // DAI takeValue : 10 ** 18 , });","title":"ERC20"},{"location":"use-cases/picnic/","text":"Picnic \u00b6 We use Rarible to help us identify NFTs from creators and collectors in the Picnic showcase. The Rarible API provides a few great endpoints for fetching the necessary data. API Calls \u00b6 The following endpoints can be used: Production(Mainnet, Chain ID: 1): https://ethereum-api.rarible.org Staging (Ropsten, Chain ID: 3): https://ethereum-api-dev.rarible.org Staging (Rinkeby, Chain ID:4): https://ethereum-api-staging.rarible.org Getting Tokens by Owner \u00b6 Paginate through owned tokens import axios from 'axios' ; /** * Get collector's owned tokens. * @param {string} owner - owner address (0x...) * @param {object} opts - options * @param {string} opts.continuation - Rariable continuation ID * @param {integer} opts.size - size of tokens to get (default: 100). * @return */ const fetchOwnedTokens = async ( owner , opts = {}) => { const { continuation , size = 100 } = opts ; try { const result = await axios . get ( 'https://api.rarible.com/protocol/v0.1/ethereum/nft/items/byOwner' , { params : { owner , continuation }, }); const { data } = result ; // Paginate results let hist = []; if ( data . continuation && data . items . length === size ) { hist = await getOwnedTokens ( owner , { ... opts , continuation : data.continuation }); } // Return full history return [... data . items , ... hist ]; } catch ( err ) { console . error ( err ); return []; } }; The byOwner endpoint does not return token metadata. You can attempt to query this information from the blockchain directly or use another API to collect token metadata information. You can use the getItemMetaById Rarible API endpoint to get token metadata. Be mindful that you\u2019ll have to make one request per token. import axios from 'axios' ; /** * Get token metadata from token id. * @param {string} id - token ID, formatted as CONTRACT_ADDRESS:TOKEN_ID (e.g. 0x1:1001) * @return {object} */ const fetchTokenMetadata = async id => { const { data } = await axios . get ( `https://api.rarible.com/protocol/v0.1/ethereum/nft/items/ ${ id } /meta` ); if ( ! data ? . name ) { throw new Error ( 'Invalid NFT data' , { id , data }); } return data ; }; If you have question, please reach out. greg@picnic.show / [@gleuch]","title":"Picnic"},{"location":"use-cases/picnic/#picnic","text":"We use Rarible to help us identify NFTs from creators and collectors in the Picnic showcase. The Rarible API provides a few great endpoints for fetching the necessary data.","title":"Picnic"},{"location":"use-cases/picnic/#api-calls","text":"The following endpoints can be used: Production(Mainnet, Chain ID: 1): https://ethereum-api.rarible.org Staging (Ropsten, Chain ID: 3): https://ethereum-api-dev.rarible.org Staging (Rinkeby, Chain ID:4): https://ethereum-api-staging.rarible.org","title":"API Calls"},{"location":"use-cases/picnic/#getting-tokens-by-owner","text":"Paginate through owned tokens import axios from 'axios' ; /** * Get collector's owned tokens. * @param {string} owner - owner address (0x...) * @param {object} opts - options * @param {string} opts.continuation - Rariable continuation ID * @param {integer} opts.size - size of tokens to get (default: 100). * @return */ const fetchOwnedTokens = async ( owner , opts = {}) => { const { continuation , size = 100 } = opts ; try { const result = await axios . get ( 'https://api.rarible.com/protocol/v0.1/ethereum/nft/items/byOwner' , { params : { owner , continuation }, }); const { data } = result ; // Paginate results let hist = []; if ( data . continuation && data . items . length === size ) { hist = await getOwnedTokens ( owner , { ... opts , continuation : data.continuation }); } // Return full history return [... data . items , ... hist ]; } catch ( err ) { console . error ( err ); return []; } }; The byOwner endpoint does not return token metadata. You can attempt to query this information from the blockchain directly or use another API to collect token metadata information. You can use the getItemMetaById Rarible API endpoint to get token metadata. Be mindful that you\u2019ll have to make one request per token. import axios from 'axios' ; /** * Get token metadata from token id. * @param {string} id - token ID, formatted as CONTRACT_ADDRESS:TOKEN_ID (e.g. 0x1:1001) * @return {object} */ const fetchTokenMetadata = async id => { const { data } = await axios . get ( `https://api.rarible.com/protocol/v0.1/ethereum/nft/items/ ${ id } /meta` ); if ( ! data ? . name ) { throw new Error ( 'Invalid NFT data' , { id , data }); } return data ; }; If you have question, please reach out. greg@picnic.show / [@gleuch]","title":"Getting Tokens by Owner"},{"location":"use-cases/use-cases-overview/","text":"Use Cases \u00b6 Picnic \u2014 use case with Rarible Protocol SDK and API cocoNFT and MintGate \u2014 use cases with Rarible Smart Contracts and API SDK plugin for Bubble \u2014 No-Code plugin for Bubble.io with Rarible Protocol SDK Moralis Plugin \u2014 plugin for Moralis.io that enables interaction with Rarible","title":"Overview"},{"location":"use-cases/use-cases-overview/#use-cases","text":"Picnic \u2014 use case with Rarible Protocol SDK and API cocoNFT and MintGate \u2014 use cases with Rarible Smart Contracts and API SDK plugin for Bubble \u2014 No-Code plugin for Bubble.io with Rarible Protocol SDK Moralis Plugin \u2014 plugin for Moralis.io that enables interaction with Rarible","title":"Use Cases"}]}